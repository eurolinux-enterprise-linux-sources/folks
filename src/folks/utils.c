/* utils.c generated by valac 0.34.0.3-63fa6, the Vala compiler
 * generated from utils.vala, do not modify */

/*
 * Copyright (C) 2011 Collabora Ltd.
 *
 * This library is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 2.1 of the License, or
 * (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Authors:
 *       Raul Gutierrez Segales <raul.gutierrez.segales@collabora.co.uk>
 *       Travis Reitter <travis.reitter@collabora.co.uk>
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gee.h>


#define FOLKS_TYPE_UTILS (folks_utils_get_type ())
#define FOLKS_UTILS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FOLKS_TYPE_UTILS, FolksUtils))
#define FOLKS_UTILS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FOLKS_TYPE_UTILS, FolksUtilsClass))
#define FOLKS_IS_UTILS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FOLKS_TYPE_UTILS))
#define FOLKS_IS_UTILS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FOLKS_TYPE_UTILS))
#define FOLKS_UTILS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FOLKS_TYPE_UTILS, FolksUtilsClass))

typedef struct _FolksUtils FolksUtils;
typedef struct _FolksUtilsClass FolksUtilsClass;
typedef struct _FolksUtilsPrivate FolksUtilsPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define FOLKS_TYPE_ABSTRACT_FIELD_DETAILS (folks_abstract_field_details_get_type ())
#define FOLKS_ABSTRACT_FIELD_DETAILS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FOLKS_TYPE_ABSTRACT_FIELD_DETAILS, FolksAbstractFieldDetails))
#define FOLKS_ABSTRACT_FIELD_DETAILS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FOLKS_TYPE_ABSTRACT_FIELD_DETAILS, FolksAbstractFieldDetailsClass))
#define FOLKS_IS_ABSTRACT_FIELD_DETAILS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FOLKS_TYPE_ABSTRACT_FIELD_DETAILS))
#define FOLKS_IS_ABSTRACT_FIELD_DETAILS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FOLKS_TYPE_ABSTRACT_FIELD_DETAILS))
#define FOLKS_ABSTRACT_FIELD_DETAILS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FOLKS_TYPE_ABSTRACT_FIELD_DETAILS, FolksAbstractFieldDetailsClass))

typedef struct _FolksAbstractFieldDetails FolksAbstractFieldDetails;
typedef struct _FolksAbstractFieldDetailsClass FolksAbstractFieldDetailsClass;

struct _FolksUtils {
	GObject parent_instance;
	FolksUtilsPrivate * priv;
};

struct _FolksUtilsClass {
	GObjectClass parent_class;
};


static gpointer folks_utils_parent_class = NULL;

GType folks_utils_get_type (void) G_GNUC_CONST;
enum  {
	FOLKS_UTILS_DUMMY_PROPERTY
};
gboolean _folks_utils_str_equal_safe (const gchar* a, const gchar* b);
FolksUtils* folks_utils_new (void) G_GNUC_DEPRECATED;
FolksUtils* folks_utils_construct (GType object_type);
gboolean folks_utils_multi_map_str_str_equal (GeeMultiMap* a, GeeMultiMap* b);
GType folks_abstract_field_details_get_type (void) G_GNUC_CONST;
gboolean folks_utils_multi_map_str_afd_equal (GeeMultiMap* a, GeeMultiMap* b);
gboolean folks_utils_set_afd_equal (GeeSet* a, GeeSet* b);
gboolean folks_utils_set_string_afd_equal (GeeSet* a, GeeSet* b);
gboolean folks_abstract_field_details_parameters_equal (FolksAbstractFieldDetails* self, FolksAbstractFieldDetails* that);
gconstpointer folks_abstract_field_details_get_value (FolksAbstractFieldDetails* self);


gboolean _folks_utils_str_equal_safe (const gchar* a, const gchar* b) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	const gchar* _tmp2_ = NULL;
	g_return_val_if_fail (a != NULL, FALSE);
	g_return_val_if_fail (b != NULL, FALSE);
	_tmp2_ = a;
	if (g_strcmp0 (_tmp2_, "") != 0) {
		const gchar* _tmp3_ = NULL;
		_tmp3_ = b;
		_tmp1_ = g_strcmp0 (_tmp3_, "") != 0;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		const gchar* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		_tmp4_ = a;
		_tmp5_ = g_utf8_strdown (_tmp4_, (gssize) -1);
		_tmp6_ = _tmp5_;
		_tmp7_ = b;
		_tmp8_ = g_utf8_strdown (_tmp7_, (gssize) -1);
		_tmp9_ = _tmp8_;
		_tmp0_ = g_strcmp0 (_tmp6_, _tmp9_) == 0;
		_g_free0 (_tmp9_);
		_g_free0 (_tmp6_);
	} else {
		_tmp0_ = FALSE;
	}
	result = _tmp0_;
	return result;
}


/**
   * Create a new utilities object.
   *
   * This method is useless and should never be used. It will be removed in a
   * future version in favour of making the Utils class into a nested namespace.
   *
   * @return a new utilities object
   * @since 0.6.0
   */
FolksUtils* folks_utils_construct (GType object_type) {
	FolksUtils * self = NULL;
	self = (FolksUtils*) g_object_new (object_type, NULL);
	return self;
}


FolksUtils* folks_utils_new (void) {
	return folks_utils_construct (FOLKS_TYPE_UTILS);
}


/**
   * Check whether two multi-maps of strings to strings are equal. This performs
   * a deep check for equality, checking whether both maps are of the same size,
   * and that each key maps to the same set of values in both maps.
   *
   * @param a a multi-map to compare
   * @param b another multi-map to compare
   * @return ``true`` if the multi-maps are equal, ``false`` otherwise
   *
   * @since 0.6.0
   */
gboolean folks_utils_multi_map_str_str_equal (GeeMultiMap* a, GeeMultiMap* b) {
	gboolean result = FALSE;
	GeeMultiMap* _tmp0_ = NULL;
	GeeMultiMap* _tmp1_ = NULL;
	gint a_size = 0;
	GeeMultiMap* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
	gint b_size = 0;
	GeeMultiMap* _tmp5_ = NULL;
	gint _tmp6_ = 0;
	gint _tmp7_ = 0;
	gboolean _tmp8_ = FALSE;
	gint _tmp9_ = 0;
	g_return_val_if_fail (a != NULL, FALSE);
	g_return_val_if_fail (b != NULL, FALSE);
	_tmp0_ = a;
	_tmp1_ = b;
	if (_tmp0_ == _tmp1_) {
		result = TRUE;
		return result;
	}
	_tmp2_ = a;
	_tmp3_ = gee_multi_map_get_size (_tmp2_);
	_tmp4_ = _tmp3_;
	a_size = _tmp4_;
	_tmp5_ = b;
	_tmp6_ = gee_multi_map_get_size (_tmp5_);
	_tmp7_ = _tmp6_;
	b_size = _tmp7_;
	_tmp9_ = a_size;
	if (_tmp9_ == 0) {
		gint _tmp10_ = 0;
		_tmp10_ = b_size;
		_tmp8_ = _tmp10_ == 0;
	} else {
		_tmp8_ = FALSE;
	}
	if (_tmp8_) {
		result = TRUE;
		return result;
	} else {
		gint _tmp11_ = 0;
		gint _tmp12_ = 0;
		_tmp11_ = a_size;
		_tmp12_ = b_size;
		if (_tmp11_ == _tmp12_) {
			{
				GeeIterator* _key_it = NULL;
				GeeMultiMap* _tmp13_ = NULL;
				GeeSet* _tmp14_ = NULL;
				GeeSet* _tmp15_ = NULL;
				GeeIterator* _tmp16_ = NULL;
				GeeIterator* _tmp17_ = NULL;
				_tmp13_ = a;
				_tmp14_ = gee_multi_map_get_keys (_tmp13_);
				_tmp15_ = _tmp14_;
				_tmp16_ = gee_iterable_iterator ((GeeIterable*) _tmp15_);
				_tmp17_ = _tmp16_;
				_g_object_unref0 (_tmp15_);
				_key_it = _tmp17_;
				while (TRUE) {
					GeeIterator* _tmp18_ = NULL;
					gboolean _tmp19_ = FALSE;
					gchar* key = NULL;
					GeeIterator* _tmp20_ = NULL;
					gpointer _tmp21_ = NULL;
					GeeMultiMap* _tmp22_ = NULL;
					const gchar* _tmp23_ = NULL;
					gboolean _tmp24_ = FALSE;
					_tmp18_ = _key_it;
					_tmp19_ = gee_iterator_next (_tmp18_);
					if (!_tmp19_) {
						break;
					}
					_tmp20_ = _key_it;
					_tmp21_ = gee_iterator_get (_tmp20_);
					key = (gchar*) _tmp21_;
					_tmp22_ = b;
					_tmp23_ = key;
					_tmp24_ = gee_multi_map_contains (_tmp22_, _tmp23_);
					if (_tmp24_) {
						GeeCollection* a_values = NULL;
						GeeMultiMap* _tmp25_ = NULL;
						const gchar* _tmp26_ = NULL;
						GeeCollection* _tmp27_ = NULL;
						GeeCollection* b_values = NULL;
						GeeMultiMap* _tmp28_ = NULL;
						const gchar* _tmp29_ = NULL;
						GeeCollection* _tmp30_ = NULL;
						GeeCollection* _tmp31_ = NULL;
						gint _tmp32_ = 0;
						gint _tmp33_ = 0;
						GeeCollection* _tmp34_ = NULL;
						gint _tmp35_ = 0;
						gint _tmp36_ = 0;
						_tmp25_ = a;
						_tmp26_ = key;
						_tmp27_ = gee_multi_map_get (_tmp25_, _tmp26_);
						a_values = _tmp27_;
						_tmp28_ = b;
						_tmp29_ = key;
						_tmp30_ = gee_multi_map_get (_tmp28_, _tmp29_);
						b_values = _tmp30_;
						_tmp31_ = a_values;
						_tmp32_ = gee_collection_get_size (_tmp31_);
						_tmp33_ = _tmp32_;
						_tmp34_ = b_values;
						_tmp35_ = gee_collection_get_size (_tmp34_);
						_tmp36_ = _tmp35_;
						if (_tmp33_ != _tmp36_) {
							result = FALSE;
							_g_object_unref0 (b_values);
							_g_object_unref0 (a_values);
							_g_free0 (key);
							_g_object_unref0 (_key_it);
							return result;
						}
						{
							GeeIterator* _a_value_it = NULL;
							GeeCollection* _tmp37_ = NULL;
							GeeIterator* _tmp38_ = NULL;
							_tmp37_ = a_values;
							_tmp38_ = gee_iterable_iterator ((GeeIterable*) _tmp37_);
							_a_value_it = _tmp38_;
							while (TRUE) {
								GeeIterator* _tmp39_ = NULL;
								gboolean _tmp40_ = FALSE;
								gchar* a_value = NULL;
								GeeIterator* _tmp41_ = NULL;
								gpointer _tmp42_ = NULL;
								GeeCollection* _tmp43_ = NULL;
								const gchar* _tmp44_ = NULL;
								gboolean _tmp45_ = FALSE;
								_tmp39_ = _a_value_it;
								_tmp40_ = gee_iterator_next (_tmp39_);
								if (!_tmp40_) {
									break;
								}
								_tmp41_ = _a_value_it;
								_tmp42_ = gee_iterator_get (_tmp41_);
								a_value = (gchar*) _tmp42_;
								_tmp43_ = b_values;
								_tmp44_ = a_value;
								_tmp45_ = gee_collection_contains (_tmp43_, _tmp44_);
								if (!_tmp45_) {
									result = FALSE;
									_g_free0 (a_value);
									_g_object_unref0 (_a_value_it);
									_g_object_unref0 (b_values);
									_g_object_unref0 (a_values);
									_g_free0 (key);
									_g_object_unref0 (_key_it);
									return result;
								}
								_g_free0 (a_value);
							}
							_g_object_unref0 (_a_value_it);
						}
						_g_object_unref0 (b_values);
						_g_object_unref0 (a_values);
					} else {
						result = FALSE;
						_g_free0 (key);
						_g_object_unref0 (_key_it);
						return result;
					}
					_g_free0 (key);
				}
				_g_object_unref0 (_key_it);
			}
		} else {
			result = FALSE;
			return result;
		}
	}
	result = TRUE;
	return result;
}


/**
   * Check whether two multi-maps of strings to AbstractFieldDetails are equal.
   *
   * This performs a deep check for equality, checking whether both maps are of
   * the same size, and that each key maps to the same set of values in both
   * maps.
   *
   * @param a a multi-map to compare
   * @param b another multi-map to compare
   * @return ``true`` if the multi-maps are equal, ``false`` otherwise
   *
   * @since 0.6.0
   */
gboolean folks_utils_multi_map_str_afd_equal (GeeMultiMap* a, GeeMultiMap* b) {
	gboolean result = FALSE;
	GeeMultiMap* _tmp0_ = NULL;
	GeeMultiMap* _tmp1_ = NULL;
	gint a_size = 0;
	GeeMultiMap* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
	gint b_size = 0;
	GeeMultiMap* _tmp5_ = NULL;
	gint _tmp6_ = 0;
	gint _tmp7_ = 0;
	gboolean _tmp8_ = FALSE;
	gint _tmp9_ = 0;
	g_return_val_if_fail (a != NULL, FALSE);
	g_return_val_if_fail (b != NULL, FALSE);
	_tmp0_ = a;
	_tmp1_ = b;
	if (_tmp0_ == _tmp1_) {
		result = TRUE;
		return result;
	}
	_tmp2_ = a;
	_tmp3_ = gee_multi_map_get_size (_tmp2_);
	_tmp4_ = _tmp3_;
	a_size = _tmp4_;
	_tmp5_ = b;
	_tmp6_ = gee_multi_map_get_size (_tmp5_);
	_tmp7_ = _tmp6_;
	b_size = _tmp7_;
	_tmp9_ = a_size;
	if (_tmp9_ == 0) {
		gint _tmp10_ = 0;
		_tmp10_ = b_size;
		_tmp8_ = _tmp10_ == 0;
	} else {
		_tmp8_ = FALSE;
	}
	if (_tmp8_) {
		result = TRUE;
		return result;
	} else {
		gint _tmp11_ = 0;
		gint _tmp12_ = 0;
		_tmp11_ = a_size;
		_tmp12_ = b_size;
		if (_tmp11_ == _tmp12_) {
			{
				GeeIterator* _key_it = NULL;
				GeeMultiMap* _tmp13_ = NULL;
				GeeSet* _tmp14_ = NULL;
				GeeSet* _tmp15_ = NULL;
				GeeIterator* _tmp16_ = NULL;
				GeeIterator* _tmp17_ = NULL;
				_tmp13_ = a;
				_tmp14_ = gee_multi_map_get_keys (_tmp13_);
				_tmp15_ = _tmp14_;
				_tmp16_ = gee_iterable_iterator ((GeeIterable*) _tmp15_);
				_tmp17_ = _tmp16_;
				_g_object_unref0 (_tmp15_);
				_key_it = _tmp17_;
				while (TRUE) {
					GeeIterator* _tmp18_ = NULL;
					gboolean _tmp19_ = FALSE;
					gchar* key = NULL;
					GeeIterator* _tmp20_ = NULL;
					gpointer _tmp21_ = NULL;
					GeeMultiMap* _tmp22_ = NULL;
					const gchar* _tmp23_ = NULL;
					gboolean _tmp24_ = FALSE;
					_tmp18_ = _key_it;
					_tmp19_ = gee_iterator_next (_tmp18_);
					if (!_tmp19_) {
						break;
					}
					_tmp20_ = _key_it;
					_tmp21_ = gee_iterator_get (_tmp20_);
					key = (gchar*) _tmp21_;
					_tmp22_ = b;
					_tmp23_ = key;
					_tmp24_ = gee_multi_map_contains (_tmp22_, _tmp23_);
					if (_tmp24_) {
						GeeCollection* a_values = NULL;
						GeeMultiMap* _tmp25_ = NULL;
						const gchar* _tmp26_ = NULL;
						GeeCollection* _tmp27_ = NULL;
						GeeCollection* b_values = NULL;
						GeeMultiMap* _tmp28_ = NULL;
						const gchar* _tmp29_ = NULL;
						GeeCollection* _tmp30_ = NULL;
						GeeCollection* _tmp31_ = NULL;
						gint _tmp32_ = 0;
						gint _tmp33_ = 0;
						GeeCollection* _tmp34_ = NULL;
						gint _tmp35_ = 0;
						gint _tmp36_ = 0;
						_tmp25_ = a;
						_tmp26_ = key;
						_tmp27_ = gee_multi_map_get (_tmp25_, _tmp26_);
						a_values = _tmp27_;
						_tmp28_ = b;
						_tmp29_ = key;
						_tmp30_ = gee_multi_map_get (_tmp28_, _tmp29_);
						b_values = _tmp30_;
						_tmp31_ = a_values;
						_tmp32_ = gee_collection_get_size (_tmp31_);
						_tmp33_ = _tmp32_;
						_tmp34_ = b_values;
						_tmp35_ = gee_collection_get_size (_tmp34_);
						_tmp36_ = _tmp35_;
						if (_tmp33_ != _tmp36_) {
							result = FALSE;
							_g_object_unref0 (b_values);
							_g_object_unref0 (a_values);
							_g_free0 (key);
							_g_object_unref0 (_key_it);
							return result;
						}
						{
							GeeIterator* _a_value_it = NULL;
							GeeCollection* _tmp37_ = NULL;
							GeeIterator* _tmp38_ = NULL;
							_tmp37_ = a_values;
							_tmp38_ = gee_iterable_iterator ((GeeIterable*) _tmp37_);
							_a_value_it = _tmp38_;
							while (TRUE) {
								GeeIterator* _tmp39_ = NULL;
								gboolean _tmp40_ = FALSE;
								FolksAbstractFieldDetails* a_value = NULL;
								GeeIterator* _tmp41_ = NULL;
								gpointer _tmp42_ = NULL;
								GeeCollection* _tmp43_ = NULL;
								FolksAbstractFieldDetails* _tmp44_ = NULL;
								gboolean _tmp45_ = FALSE;
								_tmp39_ = _a_value_it;
								_tmp40_ = gee_iterator_next (_tmp39_);
								if (!_tmp40_) {
									break;
								}
								_tmp41_ = _a_value_it;
								_tmp42_ = gee_iterator_get (_tmp41_);
								a_value = (FolksAbstractFieldDetails*) _tmp42_;
								_tmp43_ = b_values;
								_tmp44_ = a_value;
								_tmp45_ = gee_collection_contains (_tmp43_, _tmp44_);
								if (!_tmp45_) {
									result = FALSE;
									_g_object_unref0 (a_value);
									_g_object_unref0 (_a_value_it);
									_g_object_unref0 (b_values);
									_g_object_unref0 (a_values);
									_g_free0 (key);
									_g_object_unref0 (_key_it);
									return result;
								}
								_g_object_unref0 (a_value);
							}
							_g_object_unref0 (_a_value_it);
						}
						_g_object_unref0 (b_values);
						_g_object_unref0 (a_values);
					} else {
						result = FALSE;
						_g_free0 (key);
						_g_object_unref0 (_key_it);
						return result;
					}
					_g_free0 (key);
				}
				_g_object_unref0 (_key_it);
			}
		} else {
			result = FALSE;
			return result;
		}
	}
	result = TRUE;
	return result;
}


/**
   * Check whether a set of strings to AbstractFieldDetails are equal.
   *
   * This performs a deep check for equality, checking whether both sets are of
   * the same size, and that each key maps to the same set of values in both
   * maps.
   *
   * @param a a set to compare
   * @param b another set to compare
   * @return ``true`` if the sets are equal, ``false`` otherwise
   *
   * @since 0.6.0
   */
gboolean folks_utils_set_afd_equal (GeeSet* a, GeeSet* b) {
	gboolean result = FALSE;
	GeeSet* _tmp0_ = NULL;
	GeeSet* _tmp1_ = NULL;
	gint a_size = 0;
	GeeSet* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
	gint b_size = 0;
	GeeSet* _tmp5_ = NULL;
	gint _tmp6_ = 0;
	gint _tmp7_ = 0;
	gboolean _tmp8_ = FALSE;
	gint _tmp9_ = 0;
	g_return_val_if_fail (a != NULL, FALSE);
	g_return_val_if_fail (b != NULL, FALSE);
	_tmp0_ = a;
	_tmp1_ = b;
	if (_tmp0_ == _tmp1_) {
		result = TRUE;
		return result;
	}
	_tmp2_ = a;
	_tmp3_ = gee_collection_get_size ((GeeCollection*) _tmp2_);
	_tmp4_ = _tmp3_;
	a_size = _tmp4_;
	_tmp5_ = b;
	_tmp6_ = gee_collection_get_size ((GeeCollection*) _tmp5_);
	_tmp7_ = _tmp6_;
	b_size = _tmp7_;
	_tmp9_ = a_size;
	if (_tmp9_ == 0) {
		gint _tmp10_ = 0;
		_tmp10_ = b_size;
		_tmp8_ = _tmp10_ == 0;
	} else {
		_tmp8_ = FALSE;
	}
	if (_tmp8_) {
		result = TRUE;
		return result;
	} else {
		gint _tmp11_ = 0;
		gint _tmp12_ = 0;
		_tmp11_ = a_size;
		_tmp12_ = b_size;
		if (_tmp11_ == _tmp12_) {
			{
				GeeIterator* _val_it = NULL;
				GeeSet* _tmp13_ = NULL;
				GeeIterator* _tmp14_ = NULL;
				_tmp13_ = a;
				_tmp14_ = gee_iterable_iterator ((GeeIterable*) _tmp13_);
				_val_it = _tmp14_;
				while (TRUE) {
					GeeIterator* _tmp15_ = NULL;
					gboolean _tmp16_ = FALSE;
					FolksAbstractFieldDetails* val = NULL;
					GeeIterator* _tmp17_ = NULL;
					gpointer _tmp18_ = NULL;
					GeeSet* _tmp19_ = NULL;
					FolksAbstractFieldDetails* _tmp20_ = NULL;
					gboolean _tmp21_ = FALSE;
					_tmp15_ = _val_it;
					_tmp16_ = gee_iterator_next (_tmp15_);
					if (!_tmp16_) {
						break;
					}
					_tmp17_ = _val_it;
					_tmp18_ = gee_iterator_get (_tmp17_);
					val = (FolksAbstractFieldDetails*) _tmp18_;
					_tmp19_ = b;
					_tmp20_ = val;
					_tmp21_ = gee_collection_contains ((GeeCollection*) _tmp19_, _tmp20_);
					if (!_tmp21_) {
						result = FALSE;
						_g_object_unref0 (val);
						_g_object_unref0 (_val_it);
						return result;
					}
					_g_object_unref0 (val);
				}
				_g_object_unref0 (_val_it);
			}
		} else {
			result = FALSE;
			return result;
		}
	}
	result = TRUE;
	return result;
}


/**
   * Check whether a set of AbstractFieldDetails with string values are equal.
   *
   * This performs a deep check for equality, checking whether both sets are of
   * the same size, and that each set has the same values using string compation
   * instead of AbstractFieldDetails equal function
   *
   * @param a a set to compare
   * @param b another set to compare
   * @return ``true`` if the sets are equal, ``false`` otherwise
   *
   * @since 0.9.7
   */
gboolean folks_utils_set_string_afd_equal (GeeSet* a, GeeSet* b) {
	gboolean result = FALSE;
	GeeSet* _tmp0_ = NULL;
	GeeSet* _tmp1_ = NULL;
	gint a_size = 0;
	GeeSet* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
	gint b_size = 0;
	GeeSet* _tmp5_ = NULL;
	gint _tmp6_ = 0;
	gint _tmp7_ = 0;
	gboolean _tmp8_ = FALSE;
	gint _tmp9_ = 0;
	g_return_val_if_fail (a != NULL, FALSE);
	g_return_val_if_fail (b != NULL, FALSE);
	_tmp0_ = a;
	_tmp1_ = b;
	if (_tmp0_ == _tmp1_) {
		result = TRUE;
		return result;
	}
	_tmp2_ = a;
	_tmp3_ = gee_collection_get_size ((GeeCollection*) _tmp2_);
	_tmp4_ = _tmp3_;
	a_size = _tmp4_;
	_tmp5_ = b;
	_tmp6_ = gee_collection_get_size ((GeeCollection*) _tmp5_);
	_tmp7_ = _tmp6_;
	b_size = _tmp7_;
	_tmp9_ = a_size;
	if (_tmp9_ == 0) {
		gint _tmp10_ = 0;
		_tmp10_ = b_size;
		_tmp8_ = _tmp10_ == 0;
	} else {
		_tmp8_ = FALSE;
	}
	if (_tmp8_) {
		result = TRUE;
		return result;
	} else {
		gint _tmp11_ = 0;
		gint _tmp12_ = 0;
		_tmp11_ = a_size;
		_tmp12_ = b_size;
		if (_tmp11_ == _tmp12_) {
			{
				GeeIterator* _a_val_it = NULL;
				GeeSet* _tmp13_ = NULL;
				GeeIterator* _tmp14_ = NULL;
				_tmp13_ = a;
				_tmp14_ = gee_iterable_iterator ((GeeIterable*) _tmp13_);
				_a_val_it = _tmp14_;
				while (TRUE) {
					GeeIterator* _tmp15_ = NULL;
					gboolean _tmp16_ = FALSE;
					FolksAbstractFieldDetails* a_val = NULL;
					GeeIterator* _tmp17_ = NULL;
					gpointer _tmp18_ = NULL;
					gboolean found = FALSE;
					gboolean _tmp37_ = FALSE;
					_tmp15_ = _a_val_it;
					_tmp16_ = gee_iterator_next (_tmp15_);
					if (!_tmp16_) {
						break;
					}
					_tmp17_ = _a_val_it;
					_tmp18_ = gee_iterator_get (_tmp17_);
					a_val = (FolksAbstractFieldDetails*) _tmp18_;
					found = FALSE;
					{
						GeeIterator* _b_val_it = NULL;
						GeeSet* _tmp19_ = NULL;
						GeeIterator* _tmp20_ = NULL;
						_tmp19_ = b;
						_tmp20_ = gee_iterable_iterator ((GeeIterable*) _tmp19_);
						_b_val_it = _tmp20_;
						while (TRUE) {
							GeeIterator* _tmp21_ = NULL;
							gboolean _tmp22_ = FALSE;
							FolksAbstractFieldDetails* b_val = NULL;
							GeeIterator* _tmp23_ = NULL;
							gpointer _tmp24_ = NULL;
							gboolean _tmp25_ = FALSE;
							FolksAbstractFieldDetails* _tmp26_ = NULL;
							FolksAbstractFieldDetails* _tmp27_ = NULL;
							gboolean _tmp28_ = FALSE;
							_tmp21_ = _b_val_it;
							_tmp22_ = gee_iterator_next (_tmp21_);
							if (!_tmp22_) {
								break;
							}
							_tmp23_ = _b_val_it;
							_tmp24_ = gee_iterator_get (_tmp23_);
							b_val = (FolksAbstractFieldDetails*) _tmp24_;
							_tmp26_ = a_val;
							_tmp27_ = b_val;
							_tmp28_ = folks_abstract_field_details_parameters_equal (_tmp26_, _tmp27_);
							if (_tmp28_) {
								GEqualFunc _tmp29_ = NULL;
								FolksAbstractFieldDetails* _tmp30_ = NULL;
								gconstpointer _tmp31_ = NULL;
								const gchar* _tmp32_ = NULL;
								FolksAbstractFieldDetails* _tmp33_ = NULL;
								gconstpointer _tmp34_ = NULL;
								const gchar* _tmp35_ = NULL;
								gboolean _tmp36_ = FALSE;
								_tmp29_ = g_str_equal;
								_tmp30_ = a_val;
								_tmp31_ = folks_abstract_field_details_get_value (_tmp30_);
								_tmp32_ = _tmp31_;
								_tmp33_ = b_val;
								_tmp34_ = folks_abstract_field_details_get_value (_tmp33_);
								_tmp35_ = _tmp34_;
								_tmp36_ = _tmp29_ ((const gchar*) _tmp32_, (const gchar*) _tmp35_);
								_tmp25_ = _tmp36_;
							} else {
								_tmp25_ = FALSE;
							}
							if (_tmp25_) {
								found = TRUE;
							}
							_g_object_unref0 (b_val);
						}
						_g_object_unref0 (_b_val_it);
					}
					_tmp37_ = found;
					if (!_tmp37_) {
						result = FALSE;
						_g_object_unref0 (a_val);
						_g_object_unref0 (_a_val_it);
						return result;
					}
					_g_object_unref0 (a_val);
				}
				_g_object_unref0 (_a_val_it);
			}
		} else {
			result = FALSE;
			return result;
		}
	}
	result = TRUE;
	return result;
}


static void folks_utils_class_init (FolksUtilsClass * klass) {
	folks_utils_parent_class = g_type_class_peek_parent (klass);
}


static void folks_utils_instance_init (FolksUtils * self) {
}


/**
 * Utility functions to simplify common patterns in Folks client code.
 *
 * These may be used by folks clients as well, and are part of folks' supported
 * stable API.
 *
 * @since 0.6.0
 */
GType folks_utils_get_type (void) {
	static volatile gsize folks_utils_type_id__volatile = 0;
	if (g_once_init_enter (&folks_utils_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FolksUtilsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) folks_utils_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FolksUtils), 0, (GInstanceInitFunc) folks_utils_instance_init, NULL };
		GType folks_utils_type_id;
		folks_utils_type_id = g_type_register_static (G_TYPE_OBJECT, "FolksUtils", &g_define_type_info, 0);
		g_once_init_leave (&folks_utils_type_id__volatile, folks_utils_type_id);
	}
	return folks_utils_type_id__volatile;
}



