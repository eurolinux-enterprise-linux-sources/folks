/* debug.c generated by valac 0.36.1.697-2b74, the Vala compiler
 * generated from debug.vala, do not modify */

/*
 * Copyright (C) 2010 Collabora Ltd.
 *
 * This library is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 2.1 of the License, or
 * (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Authors:
 *       Philip Withnall <philip.withnall@collabora.co.uk>
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gee.h>
#include <stdio.h>
#include <stdarg.h>


#define FOLKS_TYPE_DEBUG (folks_debug_get_type ())
#define FOLKS_DEBUG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FOLKS_TYPE_DEBUG, FolksDebug))
#define FOLKS_DEBUG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FOLKS_TYPE_DEBUG, FolksDebugClass))
#define FOLKS_IS_DEBUG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FOLKS_TYPE_DEBUG))
#define FOLKS_IS_DEBUG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FOLKS_TYPE_DEBUG))
#define FOLKS_DEBUG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FOLKS_TYPE_DEBUG, FolksDebugClass))

typedef struct _FolksDebug FolksDebug;
typedef struct _FolksDebugClass FolksDebugClass;
typedef struct _FolksDebugPrivate FolksDebugPrivate;
enum  {
	FOLKS_DEBUG_DUMMY_PROPERTY,
	FOLKS_DEBUG_COLOUR_ENABLED,
	FOLKS_DEBUG_DEBUG_OUTPUT_ENABLED,
	FOLKS_DEBUG_LAST_PROPERTY
};
static GParamSpec* folks_debug_properties[FOLKS_DEBUG_LAST_PROPERTY];
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define FOLKS_DEBUG_TYPE_DOMAINS (folks_debug_domains_get_type ())

#define FOLKS_DEBUG_TYPE_KEY_VALUE_PAIR (folks_debug_key_value_pair_get_type ())
typedef struct _FolksDebugKeyValuePair FolksDebugKeyValuePair;
enum  {
	FOLKS_DEBUG_PRINT_STATUS_SIGNAL,
	FOLKS_DEBUG_LAST_SIGNAL
};
static guint folks_debug_signals[FOLKS_DEBUG_LAST_SIGNAL] = {0};

struct _FolksDebug {
	GObject parent_instance;
	FolksDebugPrivate * priv;
};

struct _FolksDebugClass {
	GObjectClass parent_class;
};

struct _FolksDebugPrivate {
	GeeHashSet* _domains;
	gboolean _all;
	guint _indentation;
	gchar* _indentation_string;
	gboolean _colour_enabled;
	GeeHashSet* _domains_handled;
	gboolean _debug_output_enabled;
};

typedef enum  {
	FOLKS_DEBUG_DOMAINS_CORE = 1 << 0,
	FOLKS_DEBUG_DOMAINS_TELEPATHY_BACKEND = 1 << 1,
	FOLKS_DEBUG_DOMAINS_KEY_FILE_BACKEND = 1 << 2
} FolksDebugDomains;

struct _FolksDebugKeyValuePair {
	gchar* key;
	gchar* val;
};


static gpointer folks_debug_parent_class = NULL;
static FolksDebug* folks_debug__instance;
static FolksDebug* folks_debug__instance = NULL;

void g_log (const gchar* log_domain, GLogLevelFlags log_level, const gchar* format, ...) G_GNUC_PRINTF(3,4);
GType folks_debug_get_type (void) G_GNUC_CONST;
#define FOLKS_DEBUG_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), FOLKS_TYPE_DEBUG, FolksDebugPrivate))
static void _folks_debug_remove_handler (FolksDebug* self, const gchar* domain, gboolean keep_in_map);
static GType folks_debug_domains_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
#define FOLKS_DEBUG_STATUS_LOG_DOMAIN "folks-status"
static void _folks_debug_print_status_log_handler_cb (FolksDebug* self, const gchar* log_domain, GLogLevelFlags log_levels, const gchar* message);
static void _folks_debug_log_handler_cb (FolksDebug* self, const gchar* log_domain, GLogLevelFlags log_levels, const gchar* message);
gboolean folks_debug_get_debug_output_enabled (FolksDebug* self);
void _folks_debug_register_domain (FolksDebug* self, const gchar* domain);
static void _folks_debug_set_handler (FolksDebug* self, const gchar* domain, GLogLevelFlags flags, GLogFunc log_func, void* log_func_target);
static void __folks_debug_log_handler_cb_glog_func (const gchar* log_domain, GLogLevelFlags log_levels, const gchar* message, gpointer self);
static void __lambda65_ (FolksDebug* self, const gchar* domain_arg, GLogLevelFlags flags, const gchar* message);
static void ___lambda65__glog_func (const gchar* log_domain, GLogLevelFlags log_levels, const gchar* message, gpointer self);
FolksDebug* folks_debug_dup (void);
static FolksDebug* folks_debug_new (void);
static FolksDebug* folks_debug_construct (GType object_type);
FolksDebug* folks_debug_dup_with_flags (const gchar* debug_flags, gboolean colour_enabled);
void folks_debug_set_debug_output_enabled (FolksDebug* self, gboolean value);
void folks_debug_set_colour_enabled (FolksDebug* self, gboolean value);
void folks_debug_emit_print_status (FolksDebug* self);
void folks_debug_indent (FolksDebug* self);
void folks_debug_unindent (FolksDebug* self);
void folks_debug_print_line (FolksDebug* self, const gchar* domain, GLogLevelFlags level, const gchar* format, ...) G_GNUC_PRINTF(4,5);
void folks_debug_print_heading (FolksDebug* self, const gchar* domain, GLogLevelFlags level, const gchar* format, ...) G_GNUC_PRINTF(4,5);
gboolean folks_debug_get_colour_enabled (FolksDebug* self);
static gchar* _folks_debug_format_nullable_string (FolksDebug* self, const gchar* input);
void folks_debug_print_key_value_pairs (FolksDebug* self, const gchar* domain, GLogLevelFlags level, ...);
static GType folks_debug_key_value_pair_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static FolksDebugKeyValuePair* folks_debug_key_value_pair_dup (const FolksDebugKeyValuePair* self);
static void folks_debug_key_value_pair_free (FolksDebugKeyValuePair* self);
static void folks_debug_key_value_pair_copy (const FolksDebugKeyValuePair* self, FolksDebugKeyValuePair* dest);
static void folks_debug_key_value_pair_destroy (FolksDebugKeyValuePair* self);
static void _vala_array_add1 (FolksDebugKeyValuePair* * array, int* length, int* size, const FolksDebugKeyValuePair* value);
static void _vala_FolksDebugKeyValuePair_array_free (FolksDebugKeyValuePair * array, gint array_length);
static GObject * folks_debug_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void __folks_debug_print_status_log_handler_cb_glog_func (const gchar* log_domain, GLogLevelFlags log_levels, const gchar* message, gpointer self);
static void folks_debug_finalize (GObject * obj);
static void _vala_folks_debug_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_folks_debug_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


static GType folks_debug_domains_get_type (void) {
	static volatile gsize folks_debug_domains_type_id__volatile = 0;
	if (g_once_init_enter (&folks_debug_domains_type_id__volatile)) {
		static const GEnumValue values[] = {{FOLKS_DEBUG_DOMAINS_CORE, "FOLKS_DEBUG_DOMAINS_CORE", "core"}, {FOLKS_DEBUG_DOMAINS_TELEPATHY_BACKEND, "FOLKS_DEBUG_DOMAINS_TELEPATHY_BACKEND", "telepathy-backend"}, {FOLKS_DEBUG_DOMAINS_KEY_FILE_BACKEND, "FOLKS_DEBUG_DOMAINS_KEY_FILE_BACKEND", "key-file-backend"}, {0, NULL, NULL}};
		GType folks_debug_domains_type_id;
		folks_debug_domains_type_id = g_enum_register_static ("FolksDebugDomains", values);
		g_once_init_leave (&folks_debug_domains_type_id__volatile, folks_debug_domains_type_id);
	}
	return folks_debug_domains_type_id__volatile;
}


static void _folks_debug_print_status_log_handler_cb (FolksDebug* self, const gchar* log_domain, GLogLevelFlags log_levels, const gchar* message) {
	FILE* _tmp0_;
	const gchar* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (message != NULL);
	_tmp0_ = stdout;
	_tmp1_ = message;
	fprintf (_tmp0_, "%s\n", _tmp1_);
}


static void _folks_debug_log_handler_cb (FolksDebug* self, const gchar* log_domain, GLogLevelFlags log_levels, const gchar* message) {
	gboolean _tmp0_;
	gboolean _tmp1_;
	GLogFunc _tmp2_;
	void* _tmp2__target;
	const gchar* _tmp3_;
	GLogLevelFlags _tmp4_;
	const gchar* _tmp5_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (message != NULL);
	_tmp0_ = folks_debug_get_debug_output_enabled (self);
	_tmp1_ = _tmp0_;
	if (_tmp1_ == FALSE) {
		return;
	}
	_tmp2_ = g_log_default_handler;
	_tmp2__target = NULL;
	_tmp3_ = log_domain;
	_tmp4_ = log_levels;
	_tmp5_ = message;
	_tmp2_ (_tmp3_, _tmp4_, _tmp5_, _tmp2__target);
}


static void __folks_debug_log_handler_cb_glog_func (const gchar* log_domain, GLogLevelFlags log_levels, const gchar* message, gpointer self) {
	_folks_debug_log_handler_cb ((FolksDebug*) self, log_domain, log_levels, message);
}


static void __lambda65_ (FolksDebug* self, const gchar* domain_arg, GLogLevelFlags flags, const gchar* message) {
	g_return_if_fail (message != NULL);
}


static void ___lambda65__glog_func (const gchar* log_domain, GLogLevelFlags log_levels, const gchar* message, gpointer self) {
	__lambda65_ ((FolksDebug*) self, log_domain, log_levels, message);
}


void _folks_debug_register_domain (FolksDebug* self, const gchar* domain) {
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_;
	const gchar* _tmp8_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (domain != NULL);
	_tmp1_ = self->priv->_all;
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		GeeHashSet* _tmp2_;
		const gchar* _tmp3_;
		gchar* _tmp4_;
		gchar* _tmp5_;
		gboolean _tmp6_;
		_tmp2_ = self->priv->_domains;
		_tmp3_ = domain;
		_tmp4_ = g_utf8_strdown (_tmp3_, (gssize) -1);
		_tmp5_ = _tmp4_;
		_tmp6_ = gee_abstract_collection_contains ((GeeAbstractCollection*) _tmp2_, _tmp5_);
		_tmp0_ = _tmp6_;
		_g_free0 (_tmp5_);
	}
	if (_tmp0_) {
		const gchar* _tmp7_;
		_tmp7_ = domain;
		_folks_debug_set_handler (self, _tmp7_, G_LOG_LEVEL_MASK, __folks_debug_log_handler_cb_glog_func, self);
		return;
	}
	_tmp8_ = domain;
	_folks_debug_set_handler (self, _tmp8_, G_LOG_LEVEL_DEBUG, ___lambda65__glog_func, self);
}


/**
   * Create or return the singleton {@link Folks.Debug} class instance.
   * If the instance doesn't exist already, it will be created with no debug
   * domains enabled.
   *
   * This function is thread-safe.
   *
   * @return  Singleton {@link Folks.Debug} instance
   * @since 0.5.1
   */
static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


FolksDebug* folks_debug_dup (void) {
	FolksDebug* result = NULL;
	FolksDebug* _retval = NULL;
	FolksDebug* _tmp0_;
	FolksDebug* _tmp1_;
	FolksDebug* retval = NULL;
	FolksDebug* _tmp2_;
	_tmp0_ = folks_debug__instance;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_retval = _tmp1_;
	_tmp2_ = _retval;
	if (_tmp2_ == NULL) {
		FolksDebug* _tmp3_;
		FolksDebug* _tmp4_;
		_tmp3_ = folks_debug_new ();
		_g_object_unref0 (retval);
		retval = _tmp3_;
		_tmp4_ = retval;
		folks_debug__instance = _tmp4_;
	} else {
		FolksDebug* _tmp5_;
		FolksDebug* _tmp6_;
		_tmp5_ = _retval;
		_tmp6_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp5_, FOLKS_TYPE_DEBUG, FolksDebug));
		_g_object_unref0 (retval);
		retval = _tmp6_;
	}
	result = retval;
	_g_object_unref0 (_retval);
	return result;
}


/**
   * Create or return the singleton {@link Folks.Debug} class instance.
   * If the instance doesn't exist already, it will be created with the given
   * set of debug domains enabled. Otherwise, the existing instance will have
   * its set of enabled domains changed to the provided set.
   *
   * @param debug_flags A comma-separated list of debug domains to enable, or
   * null to disable debug output
   * @param colour_enabled Whether debug output should be coloured using
   * terminal escape sequences
   * @return Singleton {@link Folks.Debug} instance
   * @since 0.5.1
   */
FolksDebug* folks_debug_dup_with_flags (const gchar* debug_flags, gboolean colour_enabled) {
	FolksDebug* result = NULL;
	FolksDebug* retval = NULL;
	FolksDebug* _tmp0_;
	FolksDebug* _tmp1_;
	FolksDebug* _tmp2_;
	GeeHashSet* _tmp3_;
	gboolean _tmp4_ = FALSE;
	const gchar* _tmp5_;
	gboolean _tmp21_ = FALSE;
	FolksDebug* _tmp22_;
	gboolean _tmp23_;
	FolksDebug* _tmp28_;
	FolksDebug* _tmp29_;
	gboolean _tmp30_;
	_tmp0_ = folks_debug_dup ();
	retval = _tmp0_;
	_tmp1_ = retval;
	_tmp1_->priv->_all = FALSE;
	_tmp2_ = retval;
	_tmp3_ = gee_hash_set_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, (GDestroyNotify) g_free, NULL, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (_tmp2_->priv->_domains);
	_tmp2_->priv->_domains = _tmp3_;
	_tmp5_ = debug_flags;
	if (_tmp5_ != NULL) {
		const gchar* _tmp6_;
		_tmp6_ = debug_flags;
		_tmp4_ = g_strcmp0 (_tmp6_, "") != 0;
	} else {
		_tmp4_ = FALSE;
	}
	if (_tmp4_) {
		gchar** domains_split = NULL;
		const gchar* _tmp7_;
		gchar** _tmp8_;
		gchar** _tmp9_;
		gint domains_split_length1;
		gint _domains_split_size_;
		gchar** _tmp10_;
		gint _tmp10__length1;
		_tmp7_ = debug_flags;
		_tmp9_ = _tmp8_ = g_strsplit ((const gchar*) _tmp7_, ",", 0);
		domains_split = _tmp9_;
		domains_split_length1 = _vala_array_length (_tmp8_);
		_domains_split_size_ = domains_split_length1;
		_tmp10_ = domains_split;
		_tmp10__length1 = domains_split_length1;
		{
			gchar** domain_collection = NULL;
			gint domain_collection_length1 = 0;
			gint _domain_collection_size_ = 0;
			gint domain_it = 0;
			domain_collection = _tmp10_;
			domain_collection_length1 = _tmp10__length1;
			for (domain_it = 0; domain_it < _tmp10__length1; domain_it = domain_it + 1) {
				gchar* _tmp11_;
				gchar* domain = NULL;
				_tmp11_ = g_strdup (domain_collection[domain_it]);
				domain = _tmp11_;
				{
					gchar* domain_lower = NULL;
					const gchar* _tmp12_;
					gchar* _tmp13_;
					GCompareFunc _tmp14_;
					const gchar* _tmp15_;
					gint _tmp16_;
					_tmp12_ = domain;
					_tmp13_ = g_utf8_strdown (_tmp12_, (gssize) -1);
					domain_lower = _tmp13_;
					_tmp14_ = g_strcmp0;
					_tmp15_ = domain_lower;
					_tmp16_ = _tmp14_ (_tmp15_, "all");
					if (_tmp16_ == 0) {
						FolksDebug* _tmp17_;
						_tmp17_ = retval;
						_tmp17_->priv->_all = TRUE;
					} else {
						FolksDebug* _tmp18_;
						GeeHashSet* _tmp19_;
						const gchar* _tmp20_;
						_tmp18_ = retval;
						_tmp19_ = _tmp18_->priv->_domains;
						_tmp20_ = domain_lower;
						gee_abstract_collection_add ((GeeAbstractCollection*) _tmp19_, _tmp20_);
					}
					_g_free0 (domain_lower);
					_g_free0 (domain);
				}
			}
		}
		domains_split = (_vala_array_free (domains_split, domains_split_length1, (GDestroyNotify) g_free), NULL);
	}
	_tmp22_ = retval;
	_tmp23_ = _tmp22_->priv->_all;
	if (_tmp23_) {
		_tmp21_ = TRUE;
	} else {
		FolksDebug* _tmp24_;
		GeeHashSet* _tmp25_;
		gboolean _tmp26_;
		gboolean _tmp27_;
		_tmp24_ = retval;
		_tmp25_ = _tmp24_->priv->_domains;
		_tmp26_ = gee_collection_get_is_empty ((GeeCollection*) _tmp25_);
		_tmp27_ = _tmp26_;
		_tmp21_ = !_tmp27_;
	}
	_tmp28_ = retval;
	folks_debug_set_debug_output_enabled (_tmp28_, _tmp21_);
	_tmp29_ = retval;
	_tmp30_ = colour_enabled;
	folks_debug_set_colour_enabled (_tmp29_, _tmp30_);
	result = retval;
	return result;
}


static FolksDebug* folks_debug_construct (GType object_type) {
	FolksDebug * self = NULL;
	self = (FolksDebug*) g_object_new (object_type, NULL);
	return self;
}


static FolksDebug* folks_debug_new (void) {
	return folks_debug_construct (FOLKS_TYPE_DEBUG);
}


static void _folks_debug_set_handler (FolksDebug* self, const gchar* domain, GLogLevelFlags flags, GLogFunc log_func, void* log_func_target) {
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	GLogLevelFlags _tmp2_;
	GLogFunc _tmp3_;
	void* _tmp3__target;
	GeeHashSet* _tmp4_;
	const gchar* _tmp5_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (domain != NULL);
	_tmp0_ = domain;
	_folks_debug_remove_handler (self, _tmp0_, FALSE);
	_tmp1_ = domain;
	_tmp2_ = flags;
	_tmp3_ = log_func;
	_tmp3__target = log_func_target;
	g_log_set_handler (_tmp1_, _tmp2_, _tmp3_, _tmp3__target);
	_tmp4_ = self->priv->_domains_handled;
	_tmp5_ = domain;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp4_, _tmp5_);
}


static void _folks_debug_remove_handler (FolksDebug* self, const gchar* domain, gboolean keep_in_map) {
	GeeHashSet* _tmp0_;
	const gchar* _tmp1_;
	gboolean _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (domain != NULL);
	_tmp0_ = self->priv->_domains_handled;
	_tmp1_ = domain;
	_tmp2_ = gee_abstract_collection_contains ((GeeAbstractCollection*) _tmp0_, _tmp1_);
	if (_tmp2_) {
		const gchar* _tmp3_;
		GLogFunc _tmp4_;
		void* _tmp4__target;
		gboolean _tmp5_;
		_tmp3_ = domain;
		_tmp4_ = g_log_default_handler;
		_tmp4__target = NULL;
		g_log_set_handler (_tmp3_, (G_LOG_LEVEL_MASK | G_LOG_FLAG_RECURSION) | G_LOG_FLAG_FATAL, _tmp4_, _tmp4__target);
		_tmp5_ = keep_in_map;
		if (!_tmp5_) {
			GeeHashSet* _tmp6_;
			const gchar* _tmp7_;
			_tmp6_ = self->priv->_domains_handled;
			_tmp7_ = domain;
			gee_abstract_collection_remove ((GeeAbstractCollection*) _tmp6_, _tmp7_);
		}
	}
}


/**
   * Causes all significant objects in the library to print their current
   * status to standard output, obeying the options set on this
   * {@link Folks.Debug} instance for colouring and other formatting.
   *
   * @since 0.5.1
   */
void folks_debug_emit_print_status (FolksDebug* self) {
	g_return_if_fail (self != NULL);
	g_print ("Dumping status information…\n");
	g_signal_emit (self, folks_debug_signals[FOLKS_DEBUG_PRINT_STATUS_SIGNAL], 0);
}


/**
   * Increment the indentation level used when printing output through the
   * object.
   *
   * This is intended to be used by backend libraries only.
   *
   * @since 0.5.1
   */
void folks_debug_indent (FolksDebug* self) {
	guint _tmp0_;
	guint _tmp1_;
	gchar* _tmp2_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->_indentation;
	self->priv->_indentation = _tmp0_ + 1;
	_tmp1_ = self->priv->_indentation;
	_tmp2_ = g_strnfill ((gsize) (_tmp1_ * 2), ' ');
	_g_free0 (self->priv->_indentation_string);
	self->priv->_indentation_string = _tmp2_;
}


/**
   * Decrement the indentation level used when printing output through the
   * object.
   *
   * This is intended to be used by backend libraries only.
   *
   * @since 0.5.1
   */
void folks_debug_unindent (FolksDebug* self) {
	guint _tmp0_;
	guint _tmp1_;
	gchar* _tmp2_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->_indentation;
	self->priv->_indentation = _tmp0_ - 1;
	_tmp1_ = self->priv->_indentation;
	_tmp2_ = g_strnfill ((gsize) (_tmp1_ * 2), ' ');
	_g_free0 (self->priv->_indentation_string);
	self->priv->_indentation_string = _tmp2_;
}


/**
   * Print a debug line with the current indentation level for the specified
   * debug domain.
   *
   * This is intended to be used by backend libraries only.
   *
   * @param domain The debug domain name
   * @param level A set of log level flags for the message
   * @param format A printf-style format string for the heading
   * @param ... Arguments for the format string
   * @since 0.5.1
   */
void folks_debug_print_line (FolksDebug* self, const gchar* domain, GLogLevelFlags level, const gchar* format, ...) {
	va_list valist = {0};
	gchar* output = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	const gchar* _tmp2_;
	GLogLevelFlags _tmp3_;
	const gchar* _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (domain != NULL);
	g_return_if_fail (format != NULL);
	va_start (valist, format);
	_tmp0_ = format;
	_tmp1_ = g_strdup_vprintf (_tmp0_, valist);
	output = _tmp1_;
	_tmp2_ = domain;
	_tmp3_ = level;
	_tmp4_ = self->priv->_indentation_string;
	g_log (_tmp2_, _tmp3_, "%s%s", _tmp4_, output);
	_g_free0 (output);
	va_end (valist);
}


/**
   * Print a debug line as a heading. It will be coloured according to the
   * current indentation level so that different levels of headings stand out.
   *
   * This is intended to be used by backend libraries only.
   *
   * @param domain The debug domain name
   * @param level A set of log level flags for the message
   * @param format A printf-style format string for the heading
   * @param ... Arguments for the format string
   * @since 0.5.1
   */
void folks_debug_print_heading (FolksDebug* self, const gchar* domain, GLogLevelFlags level, const gchar* format, ...) {
	static const gint heading_colours[] = {31, 32, 34};
	gchar* wrapper_format = NULL;
	gchar* _tmp0_;
	gboolean _tmp1_;
	gboolean _tmp2_;
	va_list valist = {0};
	gchar* output = NULL;
	const gchar* _tmp8_;
	gchar* _tmp9_;
	const gchar* _tmp10_;
	GLogLevelFlags _tmp11_;
	const gchar* _tmp12_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (domain != NULL);
	g_return_if_fail (format != NULL);
	_tmp0_ = g_strdup ("%s");
	wrapper_format = _tmp0_;
	_tmp1_ = folks_debug_get_colour_enabled (self);
	_tmp2_ = _tmp1_;
	if (_tmp2_ == TRUE) {
		guint indentation = 0U;
		guint _tmp3_;
		guint _tmp4_;
		guint _tmp5_;
		gint _tmp6_;
		gchar* _tmp7_;
		_tmp3_ = self->priv->_indentation;
		_tmp4_ = CLAMP (_tmp3_, (guint) 0, (guint) (G_N_ELEMENTS (heading_colours) - 1));
		indentation = _tmp4_;
		_tmp5_ = indentation;
		_tmp6_ = heading_colours[_tmp5_];
		_tmp7_ = g_strdup_printf ("\033[1;%im%%s\033[0m", _tmp6_);
		_g_free0 (wrapper_format);
		wrapper_format = _tmp7_;
	}
	va_start (valist, format);
	_tmp8_ = format;
	_tmp9_ = g_strdup_vprintf (_tmp8_, valist);
	output = _tmp9_;
	_tmp10_ = domain;
	_tmp11_ = level;
	_tmp12_ = wrapper_format;
	folks_debug_print_line (self, _tmp10_, _tmp11_, _tmp12_, output);
	_g_free0 (output);
	va_end (valist);
	_g_free0 (wrapper_format);
}


static gchar* _folks_debug_format_nullable_string (FolksDebug* self, const gchar* input) {
	gchar* result = NULL;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_;
	gboolean _tmp2_;
	const gchar* _tmp7_;
	gchar* _tmp8_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = folks_debug_get_colour_enabled (self);
	_tmp2_ = _tmp1_;
	if (_tmp2_ == TRUE) {
		const gchar* _tmp3_;
		_tmp3_ = input;
		_tmp0_ = _tmp3_ == NULL;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		gchar* _tmp4_;
		_tmp4_ = g_strdup ("\033[1;36m(null)\033[0m");
		result = _tmp4_;
		return result;
	} else {
		const gchar* _tmp5_;
		_tmp5_ = input;
		if (_tmp5_ == NULL) {
			gchar* _tmp6_;
			_tmp6_ = g_strdup ("(null)");
			result = _tmp6_;
			return result;
		}
	}
	_tmp7_ = input;
	_tmp8_ = g_strdup ((const gchar*) _tmp7_);
	result = _tmp8_;
	return result;
}


/**
   * Print a set of key–value pairs in a table. The width of the key column is
   * automatically set to the width of the longest key. The keys and values
   * must be provided as a null-delimited list of alternating key–value varargs.
   * Values may be null but keys may not.
   *
   * This is intended to be used by backend libraries only.
   *
   * The table will be printed at the current indentation level plus one.
   *
   * @param domain The debug domain name
   * @param level A set of log level flags for the message
   * @param ... Alternating keys and values, terminated with null
   * @since 0.5.1
   */
static void _vala_array_add1 (FolksDebugKeyValuePair* * array, int* length, int* size, const FolksDebugKeyValuePair* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (FolksDebugKeyValuePair, *array, *size);
	}
	(*array)[(*length)++] = *value;
}


static void _vala_FolksDebugKeyValuePair_array_free (FolksDebugKeyValuePair * array, gint array_length) {
	if (array != NULL) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			folks_debug_key_value_pair_destroy (&array[i]);
		}
	}
	g_free (array);
}


void folks_debug_print_key_value_pairs (FolksDebug* self, const gchar* domain, GLogLevelFlags level, ...) {
	va_list valist = {0};
	FolksDebugKeyValuePair* lines = NULL;
	FolksDebugKeyValuePair* _tmp0_;
	gint lines_length1;
	gint _lines_size_;
	guint max_key_length = 0U;
	FolksDebugKeyValuePair* _tmp19_;
	gint _tmp19__length1;
	g_return_if_fail (self != NULL);
	g_return_if_fail (domain != NULL);
	va_start (valist, level);
	_tmp0_ = g_new0 (FolksDebugKeyValuePair, 0);
	lines = _tmp0_;
	lines_length1 = 0;
	_lines_size_ = lines_length1;
	max_key_length = (guint) 0;
	while (TRUE) {
		gchar* _key = NULL;
		const gchar* _tmp1_;
		gchar* _tmp2_;
		const gchar* _tmp3_;
		gchar* key = NULL;
		const gchar* _tmp4_;
		gchar* _tmp5_;
		gchar* val = NULL;
		const gchar* _tmp6_;
		gchar* _tmp7_;
		const gchar* _tmp8_;
		gint _tmp9_;
		gint _tmp10_;
		guint _tmp11_;
		guint _tmp12_;
		FolksDebugKeyValuePair* _tmp13_;
		gint _tmp13__length1;
		const gchar* _tmp14_;
		gchar* _tmp15_;
		const gchar* _tmp16_;
		gchar* _tmp17_;
		FolksDebugKeyValuePair _tmp18_ = {0};
		_tmp1_ = va_arg (valist, gchar*);
		_tmp2_ = g_strdup (_tmp1_);
		_key = _tmp2_;
		_tmp3_ = _key;
		if (_tmp3_ == NULL) {
			_g_free0 (_key);
			break;
		}
		_tmp4_ = _key;
		_tmp5_ = g_strdup ((const gchar*) _tmp4_);
		key = _tmp5_;
		_tmp6_ = va_arg (valist, gchar*);
		_tmp7_ = g_strdup (_tmp6_);
		val = _tmp7_;
		_tmp8_ = key;
		_tmp9_ = strlen (_tmp8_);
		_tmp10_ = _tmp9_;
		_tmp11_ = max_key_length;
		_tmp12_ = MAX ((guint) _tmp10_, _tmp11_);
		max_key_length = _tmp12_;
		_tmp13_ = lines;
		_tmp13__length1 = lines_length1;
		_tmp14_ = key;
		_tmp15_ = g_strdup (_tmp14_);
		_tmp16_ = val;
		_tmp17_ = g_strdup (_tmp16_);
		memset (&_tmp18_, 0, sizeof (FolksDebugKeyValuePair));
		_g_free0 (_tmp18_.key);
		_tmp18_.key = _tmp15_;
		_g_free0 (_tmp18_.val);
		_tmp18_.val = _tmp17_;
		_vala_array_add1 (&lines, &lines_length1, &_lines_size_, &_tmp18_);
		_g_free0 (val);
		_g_free0 (key);
		_g_free0 (_key);
	}
	folks_debug_indent (self);
	_tmp19_ = lines;
	_tmp19__length1 = lines_length1;
	{
		FolksDebugKeyValuePair* line_collection = NULL;
		gint line_collection_length1 = 0;
		gint _line_collection_size_ = 0;
		gint line_it = 0;
		line_collection = _tmp19_;
		line_collection_length1 = _tmp19__length1;
		for (line_it = 0; line_it < _tmp19__length1; line_it = line_it + 1) {
			FolksDebugKeyValuePair _tmp20_ = {0};
			FolksDebugKeyValuePair line = {0};
			folks_debug_key_value_pair_copy (&line_collection[line_it], &_tmp20_);
			line = _tmp20_;
			{
				gchar* padding = NULL;
				guint _tmp21_;
				FolksDebugKeyValuePair _tmp22_;
				const gchar* _tmp23_;
				gint _tmp24_;
				gint _tmp25_;
				gchar* _tmp26_;
				const gchar* _tmp27_;
				GLogLevelFlags _tmp28_;
				FolksDebugKeyValuePair _tmp29_;
				const gchar* _tmp30_;
				const gchar* _tmp31_;
				FolksDebugKeyValuePair _tmp32_;
				const gchar* _tmp33_;
				gchar* _tmp34_;
				gchar* _tmp35_;
				_tmp21_ = max_key_length;
				_tmp22_ = line;
				_tmp23_ = _tmp22_.key;
				_tmp24_ = strlen (_tmp23_);
				_tmp25_ = _tmp24_;
				_tmp26_ = g_strnfill ((gsize) (_tmp21_ - _tmp25_), ' ');
				padding = _tmp26_;
				_tmp27_ = domain;
				_tmp28_ = level;
				_tmp29_ = line;
				_tmp30_ = _tmp29_.key;
				_tmp31_ = padding;
				_tmp32_ = line;
				_tmp33_ = _tmp32_.val;
				_tmp34_ = _folks_debug_format_nullable_string (self, _tmp33_);
				_tmp35_ = _tmp34_;
				folks_debug_print_line (self, _tmp27_, _tmp28_, "%s: %s%s", _tmp30_, _tmp31_, _tmp35_);
				_g_free0 (_tmp35_);
				_g_free0 (padding);
				folks_debug_key_value_pair_destroy (&line);
			}
		}
	}
	folks_debug_unindent (self);
	lines = (_vala_FolksDebugKeyValuePair_array_free (lines, lines_length1), NULL);
	va_end (valist);
}


gboolean folks_debug_get_colour_enabled (FolksDebug* self) {
	gboolean result;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_colour_enabled;
	result = _tmp0_;
	return result;
}


void folks_debug_set_colour_enabled (FolksDebug* self, gboolean value) {
	gboolean _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_colour_enabled = _tmp0_;
	g_object_notify_by_pspec ((GObject *) self, folks_debug_properties[FOLKS_DEBUG_COLOUR_ENABLED]);
}


gboolean folks_debug_get_debug_output_enabled (FolksDebug* self) {
	gboolean result;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_debug_output_enabled;
	result = _tmp0_;
	return result;
}


void folks_debug_set_debug_output_enabled (FolksDebug* self, gboolean value) {
	gboolean _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_debug_output_enabled = _tmp0_;
	g_object_notify_by_pspec ((GObject *) self, folks_debug_properties[FOLKS_DEBUG_DEBUG_OUTPUT_ENABLED]);
}


static void __folks_debug_print_status_log_handler_cb_glog_func (const gchar* log_domain, GLogLevelFlags log_levels, const gchar* message, gpointer self) {
	_folks_debug_print_status_log_handler_cb ((FolksDebug*) self, log_domain, log_levels, message);
}


static GObject * folks_debug_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	FolksDebug * self;
	GeeHashSet* _tmp0_;
	parent_class = G_OBJECT_CLASS (folks_debug_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FOLKS_TYPE_DEBUG, FolksDebug);
	_tmp0_ = gee_hash_set_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, (GDestroyNotify) g_free, NULL, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->_domains_handled);
	self->priv->_domains_handled = _tmp0_;
	_folks_debug_set_handler (self, FOLKS_DEBUG_STATUS_LOG_DOMAIN, G_LOG_LEVEL_MASK, __folks_debug_print_status_log_handler_cb_glog_func, self);
	return obj;
}


static void folks_debug_key_value_pair_copy (const FolksDebugKeyValuePair* self, FolksDebugKeyValuePair* dest) {
	const gchar* _tmp0_;
	gchar* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	_tmp0_ = (*self).key;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 ((*dest).key);
	(*dest).key = _tmp1_;
	_tmp2_ = (*self).val;
	_tmp3_ = g_strdup (_tmp2_);
	_g_free0 ((*dest).val);
	(*dest).val = _tmp3_;
}


static void folks_debug_key_value_pair_destroy (FolksDebugKeyValuePair* self) {
	_g_free0 ((*self).key);
	_g_free0 ((*self).val);
}


static FolksDebugKeyValuePair* folks_debug_key_value_pair_dup (const FolksDebugKeyValuePair* self) {
	FolksDebugKeyValuePair* dup;
	dup = g_new0 (FolksDebugKeyValuePair, 1);
	folks_debug_key_value_pair_copy (self, dup);
	return dup;
}


static void folks_debug_key_value_pair_free (FolksDebugKeyValuePair* self) {
	folks_debug_key_value_pair_destroy (self);
	g_free (self);
}


static GType folks_debug_key_value_pair_get_type (void) {
	static volatile gsize folks_debug_key_value_pair_type_id__volatile = 0;
	if (g_once_init_enter (&folks_debug_key_value_pair_type_id__volatile)) {
		GType folks_debug_key_value_pair_type_id;
		folks_debug_key_value_pair_type_id = g_boxed_type_register_static ("FolksDebugKeyValuePair", (GBoxedCopyFunc) folks_debug_key_value_pair_dup, (GBoxedFreeFunc) folks_debug_key_value_pair_free);
		g_once_init_leave (&folks_debug_key_value_pair_type_id__volatile, folks_debug_key_value_pair_type_id);
	}
	return folks_debug_key_value_pair_type_id__volatile;
}


static void folks_debug_class_init (FolksDebugClass * klass) {
	folks_debug_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (FolksDebugPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_folks_debug_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_folks_debug_set_property;
	G_OBJECT_CLASS (klass)->constructor = folks_debug_constructor;
	G_OBJECT_CLASS (klass)->finalize = folks_debug_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), FOLKS_DEBUG_COLOUR_ENABLED, folks_debug_properties[FOLKS_DEBUG_COLOUR_ENABLED] = g_param_spec_boolean ("colour-enabled", "colour-enabled", "colour-enabled", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	/**
	   * Whether debug output is enabled. This is orthogonal to the set of enabled
	   * debug domains; filtering of debug output as a whole is done after filtering
	   * by enabled domains.
	   *
	   * @since 0.5.1
	   */
	g_object_class_install_property (G_OBJECT_CLASS (klass), FOLKS_DEBUG_DEBUG_OUTPUT_ENABLED, folks_debug_properties[FOLKS_DEBUG_DEBUG_OUTPUT_ENABLED] = g_param_spec_boolean ("debug-output-enabled", "debug-output-enabled", "debug-output-enabled", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	/**
	   * Signal emitted in the main thread whenever objects should print their
	   * current status. All significant objects in the library should connect
	   * to this and print their current status in some suitable format when it's
	   * emitted.
	   *
	   * Client processes should emit this signal by calling
	   * {@link Debug.emit_print_status}.
	   *
	   * @since 0.5.1
	   */
	folks_debug_signals[FOLKS_DEBUG_PRINT_STATUS_SIGNAL] = g_signal_new ("print-status", FOLKS_TYPE_DEBUG, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void folks_debug_instance_init (FolksDebug * self) {
	gchar* _tmp0_;
	self->priv = FOLKS_DEBUG_GET_PRIVATE (self);
	self->priv->_all = FALSE;
	self->priv->_indentation = (guint) 0;
	_tmp0_ = g_strdup ("");
	self->priv->_indentation_string = _tmp0_;
	self->priv->_colour_enabled = TRUE;
	self->priv->_debug_output_enabled = FALSE;
}


static void folks_debug_finalize (GObject * obj) {
	FolksDebug * self;
	GeeHashSet* _tmp7_;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FOLKS_TYPE_DEBUG, FolksDebug);
	{
		GeeIterator* _domain_it = NULL;
		GeeHashSet* _tmp0_;
		GeeIterator* _tmp1_;
		_tmp0_ = self->priv->_domains_handled;
		_tmp1_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) _tmp0_);
		_domain_it = _tmp1_;
		while (TRUE) {
			GeeIterator* _tmp2_;
			gboolean _tmp3_;
			gchar* domain = NULL;
			GeeIterator* _tmp4_;
			gpointer _tmp5_;
			const gchar* _tmp6_;
			_tmp2_ = _domain_it;
			_tmp3_ = gee_iterator_next (_tmp2_);
			if (!_tmp3_) {
				break;
			}
			_tmp4_ = _domain_it;
			_tmp5_ = gee_iterator_get (_tmp4_);
			domain = (gchar*) _tmp5_;
			_tmp6_ = domain;
			_folks_debug_remove_handler (self, _tmp6_, TRUE);
			_g_free0 (domain);
		}
		_g_object_unref0 (_domain_it);
	}
	_tmp7_ = self->priv->_domains_handled;
	gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp7_);
	folks_debug__instance = NULL;
	_g_object_unref0 (self->priv->_domains);
	_g_free0 (self->priv->_indentation_string);
	_g_object_unref0 (self->priv->_domains_handled);
	G_OBJECT_CLASS (folks_debug_parent_class)->finalize (obj);
}


/**
 * Manages debug output and status reporting for all folks objects.
 *
 * All GLib debug logging calls are passed through a log handler in this class,
 * which allows debug domains to be outputted according to whether they've been
 * enabled by being passed to {@link Debug.dup}.
 *
 * @since 0.5.1
 */
GType folks_debug_get_type (void) {
	static volatile gsize folks_debug_type_id__volatile = 0;
	if (g_once_init_enter (&folks_debug_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FolksDebugClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) folks_debug_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FolksDebug), 0, (GInstanceInitFunc) folks_debug_instance_init, NULL };
		GType folks_debug_type_id;
		folks_debug_type_id = g_type_register_static (G_TYPE_OBJECT, "FolksDebug", &g_define_type_info, 0);
		g_once_init_leave (&folks_debug_type_id__volatile, folks_debug_type_id);
	}
	return folks_debug_type_id__volatile;
}


static void _vala_folks_debug_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	FolksDebug * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, FOLKS_TYPE_DEBUG, FolksDebug);
	switch (property_id) {
		case FOLKS_DEBUG_COLOUR_ENABLED:
		g_value_set_boolean (value, folks_debug_get_colour_enabled (self));
		break;
		case FOLKS_DEBUG_DEBUG_OUTPUT_ENABLED:
		g_value_set_boolean (value, folks_debug_get_debug_output_enabled (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_folks_debug_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	FolksDebug * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, FOLKS_TYPE_DEBUG, FolksDebug);
	switch (property_id) {
		case FOLKS_DEBUG_COLOUR_ENABLED:
		folks_debug_set_colour_enabled (self, g_value_get_boolean (value));
		break;
		case FOLKS_DEBUG_DEBUG_OUTPUT_ENABLED:
		folks_debug_set_debug_output_enabled (self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



