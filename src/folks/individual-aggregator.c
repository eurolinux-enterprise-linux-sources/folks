/* individual-aggregator.c generated by valac 0.20.1.30-1b1d, the Vala compiler
 * generated from individual-aggregator.vala, do not modify */

/*
 * Copyright (C) 2010 Collabora Ltd.
 * Copyright (C) 2012, 2013 Philip Withnall
 *
 * This library is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 2.1 of the License, or
 * (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Authors:
 *       Travis Reitter <travis.reitter@collabora.co.uk>
 *       Philip Withnall <philip@tecnocode.co.uk>
 */

#include <glib.h>
#include <glib-object.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <folks/small-set.h>
#include <gio/gio.h>
#include <folks-internal.h>
#include <glib/gi18n-lib.h>
#include <folks/small-set-internal.h>
#include <config.h>


#define FOLKS_TYPE_INDIVIDUAL_AGGREGATOR (folks_individual_aggregator_get_type ())
#define FOLKS_INDIVIDUAL_AGGREGATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FOLKS_TYPE_INDIVIDUAL_AGGREGATOR, FolksIndividualAggregator))
#define FOLKS_INDIVIDUAL_AGGREGATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FOLKS_TYPE_INDIVIDUAL_AGGREGATOR, FolksIndividualAggregatorClass))
#define FOLKS_IS_INDIVIDUAL_AGGREGATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FOLKS_TYPE_INDIVIDUAL_AGGREGATOR))
#define FOLKS_IS_INDIVIDUAL_AGGREGATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FOLKS_TYPE_INDIVIDUAL_AGGREGATOR))
#define FOLKS_INDIVIDUAL_AGGREGATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FOLKS_TYPE_INDIVIDUAL_AGGREGATOR, FolksIndividualAggregatorClass))

typedef struct _FolksIndividualAggregator FolksIndividualAggregator;
typedef struct _FolksIndividualAggregatorClass FolksIndividualAggregatorClass;
typedef struct _FolksIndividualAggregatorPrivate FolksIndividualAggregatorPrivate;

#define FOLKS_TYPE_BACKEND_STORE (folks_backend_store_get_type ())
#define FOLKS_BACKEND_STORE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FOLKS_TYPE_BACKEND_STORE, FolksBackendStore))
#define FOLKS_BACKEND_STORE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FOLKS_TYPE_BACKEND_STORE, FolksBackendStoreClass))
#define FOLKS_IS_BACKEND_STORE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FOLKS_TYPE_BACKEND_STORE))
#define FOLKS_IS_BACKEND_STORE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FOLKS_TYPE_BACKEND_STORE))
#define FOLKS_BACKEND_STORE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FOLKS_TYPE_BACKEND_STORE, FolksBackendStoreClass))

typedef struct _FolksBackendStore FolksBackendStore;
typedef struct _FolksBackendStoreClass FolksBackendStoreClass;

#define FOLKS_TYPE_PERSONA_STORE (folks_persona_store_get_type ())
#define FOLKS_PERSONA_STORE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FOLKS_TYPE_PERSONA_STORE, FolksPersonaStore))
#define FOLKS_PERSONA_STORE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FOLKS_TYPE_PERSONA_STORE, FolksPersonaStoreClass))
#define FOLKS_IS_PERSONA_STORE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FOLKS_TYPE_PERSONA_STORE))
#define FOLKS_IS_PERSONA_STORE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FOLKS_TYPE_PERSONA_STORE))
#define FOLKS_PERSONA_STORE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FOLKS_TYPE_PERSONA_STORE, FolksPersonaStoreClass))

typedef struct _FolksPersonaStore FolksPersonaStore;
typedef struct _FolksPersonaStoreClass FolksPersonaStoreClass;

#define FOLKS_TYPE_BACKEND (folks_backend_get_type ())
#define FOLKS_BACKEND(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FOLKS_TYPE_BACKEND, FolksBackend))
#define FOLKS_BACKEND_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FOLKS_TYPE_BACKEND, FolksBackendClass))
#define FOLKS_IS_BACKEND(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FOLKS_TYPE_BACKEND))
#define FOLKS_IS_BACKEND_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FOLKS_TYPE_BACKEND))
#define FOLKS_BACKEND_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FOLKS_TYPE_BACKEND, FolksBackendClass))

typedef struct _FolksBackend FolksBackend;
typedef struct _FolksBackendClass FolksBackendClass;

#define FOLKS_TYPE_INDIVIDUAL (folks_individual_get_type ())
#define FOLKS_INDIVIDUAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FOLKS_TYPE_INDIVIDUAL, FolksIndividual))
#define FOLKS_INDIVIDUAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FOLKS_TYPE_INDIVIDUAL, FolksIndividualClass))
#define FOLKS_IS_INDIVIDUAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FOLKS_TYPE_INDIVIDUAL))
#define FOLKS_IS_INDIVIDUAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FOLKS_TYPE_INDIVIDUAL))
#define FOLKS_INDIVIDUAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FOLKS_TYPE_INDIVIDUAL, FolksIndividualClass))

typedef struct _FolksIndividual FolksIndividual;
typedef struct _FolksIndividualClass FolksIndividualClass;

#define FOLKS_TYPE_DEBUG (folks_debug_get_type ())
#define FOLKS_DEBUG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FOLKS_TYPE_DEBUG, FolksDebug))
#define FOLKS_DEBUG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FOLKS_TYPE_DEBUG, FolksDebugClass))
#define FOLKS_IS_DEBUG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FOLKS_TYPE_DEBUG))
#define FOLKS_IS_DEBUG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FOLKS_TYPE_DEBUG))
#define FOLKS_DEBUG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FOLKS_TYPE_DEBUG, FolksDebugClass))

typedef struct _FolksDebug FolksDebug;
typedef struct _FolksDebugClass FolksDebugClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define FOLKS_TYPE_TRUST_LEVEL (folks_trust_level_get_type ())

#define FOLKS_TYPE_PERSONA (folks_persona_get_type ())
#define FOLKS_PERSONA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FOLKS_TYPE_PERSONA, FolksPersona))
#define FOLKS_PERSONA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FOLKS_TYPE_PERSONA, FolksPersonaClass))
#define FOLKS_IS_PERSONA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FOLKS_TYPE_PERSONA))
#define FOLKS_IS_PERSONA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FOLKS_TYPE_PERSONA))
#define FOLKS_PERSONA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FOLKS_TYPE_PERSONA, FolksPersonaClass))

typedef struct _FolksPersona FolksPersona;
typedef struct _FolksPersonaClass FolksPersonaClass;
typedef struct _FolksIndividualAggregatorPrepareData FolksIndividualAggregatorPrepareData;
typedef struct _FolksIndividualAggregatorUnprepareData FolksIndividualAggregatorUnprepareData;

#define FOLKS_TYPE_MATCH_RESULT (folks_match_result_get_type ())

#define FOLKS_TYPE_POTENTIAL_MATCH (folks_potential_match_get_type ())
#define FOLKS_POTENTIAL_MATCH(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FOLKS_TYPE_POTENTIAL_MATCH, FolksPotentialMatch))
#define FOLKS_POTENTIAL_MATCH_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FOLKS_TYPE_POTENTIAL_MATCH, FolksPotentialMatchClass))
#define FOLKS_IS_POTENTIAL_MATCH(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FOLKS_TYPE_POTENTIAL_MATCH))
#define FOLKS_IS_POTENTIAL_MATCH_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FOLKS_TYPE_POTENTIAL_MATCH))
#define FOLKS_POTENTIAL_MATCH_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FOLKS_TYPE_POTENTIAL_MATCH, FolksPotentialMatchClass))

typedef struct _FolksPotentialMatch FolksPotentialMatch;
typedef struct _FolksPotentialMatchClass FolksPotentialMatchClass;
typedef struct _FolksIndividualAggregatorAddBackendData FolksIndividualAggregatorAddBackendData;
typedef struct _Block4Data Block4Data;

#define FOLKS_GROUP_DETAILS_TYPE_CHANGE_REASON (folks_group_details_change_reason_get_type ())
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _Block5Data Block5Data;

#define FOLKS_TYPE_PERSONA_STORE_TRUST (folks_persona_store_trust_get_type ())
typedef struct _Block6Data Block6Data;

#define FOLKS_TYPE_ANTI_LINKABLE (folks_anti_linkable_get_type ())
#define FOLKS_ANTI_LINKABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FOLKS_TYPE_ANTI_LINKABLE, FolksAntiLinkable))
#define FOLKS_IS_ANTI_LINKABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FOLKS_TYPE_ANTI_LINKABLE))
#define FOLKS_ANTI_LINKABLE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), FOLKS_TYPE_ANTI_LINKABLE, FolksAntiLinkableIface))

typedef struct _FolksAntiLinkable FolksAntiLinkable;
typedef struct _FolksAntiLinkableIface FolksAntiLinkableIface;
#define _g_ptr_array_unref0(var) ((var == NULL) ? NULL : (var = (g_ptr_array_unref (var), NULL)))
typedef struct _Block7Data Block7Data;
typedef struct _FolksIndividualAggregatorAddPersonaFromDetailsData FolksIndividualAggregatorAddPersonaFromDetailsData;
typedef struct _Block8Data Block8Data;
typedef struct _FolksIndividualAggregatorRemoveIndividualData FolksIndividualAggregatorRemoveIndividualData;
typedef struct _FolksIndividualAggregatorRemovePersonaData FolksIndividualAggregatorRemovePersonaData;
typedef struct _FolksIndividualAggregatorLinkPersonasData FolksIndividualAggregatorLinkPersonasData;

#define FOLKS_TYPE_ABSTRACT_FIELD_DETAILS (folks_abstract_field_details_get_type ())
#define FOLKS_ABSTRACT_FIELD_DETAILS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FOLKS_TYPE_ABSTRACT_FIELD_DETAILS, FolksAbstractFieldDetails))
#define FOLKS_ABSTRACT_FIELD_DETAILS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FOLKS_TYPE_ABSTRACT_FIELD_DETAILS, FolksAbstractFieldDetailsClass))
#define FOLKS_IS_ABSTRACT_FIELD_DETAILS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FOLKS_TYPE_ABSTRACT_FIELD_DETAILS))
#define FOLKS_IS_ABSTRACT_FIELD_DETAILS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FOLKS_TYPE_ABSTRACT_FIELD_DETAILS))
#define FOLKS_ABSTRACT_FIELD_DETAILS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FOLKS_TYPE_ABSTRACT_FIELD_DETAILS, FolksAbstractFieldDetailsClass))

typedef struct _FolksAbstractFieldDetails FolksAbstractFieldDetails;
typedef struct _FolksAbstractFieldDetailsClass FolksAbstractFieldDetailsClass;

#define FOLKS_TYPE_IM_FIELD_DETAILS (folks_im_field_details_get_type ())
#define FOLKS_IM_FIELD_DETAILS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FOLKS_TYPE_IM_FIELD_DETAILS, FolksImFieldDetails))
#define FOLKS_IM_FIELD_DETAILS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FOLKS_TYPE_IM_FIELD_DETAILS, FolksImFieldDetailsClass))
#define FOLKS_IS_IM_FIELD_DETAILS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FOLKS_TYPE_IM_FIELD_DETAILS))
#define FOLKS_IS_IM_FIELD_DETAILS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FOLKS_TYPE_IM_FIELD_DETAILS))
#define FOLKS_IM_FIELD_DETAILS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FOLKS_TYPE_IM_FIELD_DETAILS, FolksImFieldDetailsClass))

typedef struct _FolksImFieldDetails FolksImFieldDetails;
typedef struct _FolksImFieldDetailsClass FolksImFieldDetailsClass;

#define FOLKS_TYPE_WEB_SERVICE_FIELD_DETAILS (folks_web_service_field_details_get_type ())
#define FOLKS_WEB_SERVICE_FIELD_DETAILS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FOLKS_TYPE_WEB_SERVICE_FIELD_DETAILS, FolksWebServiceFieldDetails))
#define FOLKS_WEB_SERVICE_FIELD_DETAILS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FOLKS_TYPE_WEB_SERVICE_FIELD_DETAILS, FolksWebServiceFieldDetailsClass))
#define FOLKS_IS_WEB_SERVICE_FIELD_DETAILS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FOLKS_TYPE_WEB_SERVICE_FIELD_DETAILS))
#define FOLKS_IS_WEB_SERVICE_FIELD_DETAILS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FOLKS_TYPE_WEB_SERVICE_FIELD_DETAILS))
#define FOLKS_WEB_SERVICE_FIELD_DETAILS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FOLKS_TYPE_WEB_SERVICE_FIELD_DETAILS, FolksWebServiceFieldDetailsClass))

typedef struct _FolksWebServiceFieldDetails FolksWebServiceFieldDetails;
typedef struct _FolksWebServiceFieldDetailsClass FolksWebServiceFieldDetailsClass;

#define FOLKS_TYPE_IM_DETAILS (folks_im_details_get_type ())
#define FOLKS_IM_DETAILS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FOLKS_TYPE_IM_DETAILS, FolksImDetails))
#define FOLKS_IS_IM_DETAILS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FOLKS_TYPE_IM_DETAILS))
#define FOLKS_IM_DETAILS_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), FOLKS_TYPE_IM_DETAILS, FolksImDetailsIface))

typedef struct _FolksImDetails FolksImDetails;
typedef struct _FolksImDetailsIface FolksImDetailsIface;

#define FOLKS_TYPE_WEB_SERVICE_DETAILS (folks_web_service_details_get_type ())
#define FOLKS_WEB_SERVICE_DETAILS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FOLKS_TYPE_WEB_SERVICE_DETAILS, FolksWebServiceDetails))
#define FOLKS_IS_WEB_SERVICE_DETAILS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FOLKS_TYPE_WEB_SERVICE_DETAILS))
#define FOLKS_WEB_SERVICE_DETAILS_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), FOLKS_TYPE_WEB_SERVICE_DETAILS, FolksWebServiceDetailsIface))

typedef struct _FolksWebServiceDetails FolksWebServiceDetails;
typedef struct _FolksWebServiceDetailsIface FolksWebServiceDetailsIface;

#define FOLKS_TYPE_LOCAL_ID_DETAILS (folks_local_id_details_get_type ())
#define FOLKS_LOCAL_ID_DETAILS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FOLKS_TYPE_LOCAL_ID_DETAILS, FolksLocalIdDetails))
#define FOLKS_IS_LOCAL_ID_DETAILS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FOLKS_TYPE_LOCAL_ID_DETAILS))
#define FOLKS_LOCAL_ID_DETAILS_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), FOLKS_TYPE_LOCAL_ID_DETAILS, FolksLocalIdDetailsIface))

typedef struct _FolksLocalIdDetails FolksLocalIdDetails;
typedef struct _FolksLocalIdDetailsIface FolksLocalIdDetailsIface;

#define FOLKS_TYPE_PERSONA_DETAIL (folks_persona_detail_get_type ())
typedef struct _FolksIndividualAggregatorUnlinkIndividualData FolksIndividualAggregatorUnlinkIndividualData;
typedef struct _FolksIndividualAggregatorEnsureIndividualPropertyWriteableData FolksIndividualAggregatorEnsureIndividualPropertyWriteableData;
typedef struct _FolksIndividualAggregatorEnsurePersonasPropertyWriteableData FolksIndividualAggregatorEnsurePersonasPropertyWriteableData;
typedef struct _FolksIndividualAggregatorLookUpIndividualData FolksIndividualAggregatorLookUpIndividualData;
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

/**
 * Errors from {@link IndividualAggregator}s.
 */
typedef enum  {
	FOLKS_INDIVIDUAL_AGGREGATOR_ERROR_ADD_FAILED,
	FOLKS_INDIVIDUAL_AGGREGATOR_ERROR_NO_WRITEABLE_STORE,
	FOLKS_INDIVIDUAL_AGGREGATOR_ERROR_STORE_OFFLINE,
	FOLKS_INDIVIDUAL_AGGREGATOR_ERROR_PROPERTY_NOT_WRITEABLE,
	FOLKS_INDIVIDUAL_AGGREGATOR_ERROR_NO_PRIMARY_STORE
} FolksIndividualAggregatorError;
#define FOLKS_INDIVIDUAL_AGGREGATOR_ERROR folks_individual_aggregator_error_quark ()
struct _FolksIndividualAggregator {
	GObject parent_instance;
	FolksIndividualAggregatorPrivate * priv;
};

struct _FolksIndividualAggregatorClass {
	GObjectClass parent_class;
};

struct _FolksIndividualAggregatorPrivate {
	FolksBackendStore* _backend_store;
	GeeHashMap* _stores;
	FolksPersonaStore* _primary_store;
	FolksSmallSet* _backends;
	GHashTable* _link_map;
	gboolean _linking_enabled;
	gboolean _is_prepared;
	GStaticRecMutex __lock__is_prepared;
	gboolean _prepare_pending;
	FolksDebug* _debug;
	gchar* _configured_primary_store_type_id;
	gchar* _configured_primary_store_id;
	guint _non_quiescent_persona_store_count;
	guint _non_quiescent_backend_count;
	gboolean _is_quiescent;
	guint _quiescent_timeout_id;
	gboolean _user_configured_primary_store;
	GeeMap* _individuals;
	GeeMap* _individuals_ro;
	FolksIndividual* _user;
};

typedef enum  {
	FOLKS_TRUST_LEVEL_NONE,
	FOLKS_TRUST_LEVEL_PERSONAS
} FolksTrustLevel;

struct _FolksIndividualAggregatorPrepareData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	FolksIndividualAggregator* self;
	gboolean _tmp0_;
	gboolean _tmp1_;
	gboolean _tmp2_;
	gboolean _tmp3_;
	guint _tmp4_;
	FolksBackendStore* _tmp5_;
	GeeCollection* backends;
	FolksBackendStore* _tmp6_;
	GeeMap* _tmp7_;
	GeeMap* _tmp8_;
	GeeCollection* _tmp9_;
	GeeCollection* _tmp10_;
	GeeIterator* _backend_it;
	GeeCollection* _tmp11_;
	GeeIterator* _tmp12_;
	GeeIterator* _tmp13_;
	gboolean _tmp14_;
	FolksBackend* backend;
	GeeIterator* _tmp15_;
	gpointer _tmp16_;
	FolksBackendStore* _tmp17_;
	FolksBackend* _tmp18_;
	FolksBackendStore* _tmp19_;
	guint _tmp20_;
	gboolean _tmp21_;
	GError * _inner_error_;
};

struct _FolksIndividualAggregatorUnprepareData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	FolksIndividualAggregator* self;
	gboolean _tmp0_;
	gboolean _tmp1_;
	gboolean _tmp2_;
	gboolean _tmp3_;
	gboolean _tmp4_;
	gboolean _tmp5_;
	GeeIterator* _p_it;
	GeeHashMap* _tmp6_;
	GeeCollection* _tmp7_;
	GeeCollection* _tmp8_;
	GeeCollection* _tmp9_;
	GeeIterator* _tmp10_;
	GeeIterator* _tmp11_;
	GeeIterator* _tmp12_;
	gboolean _tmp13_;
	FolksPersonaStore* p;
	GeeIterator* _tmp14_;
	gpointer _tmp15_;
	FolksPersonaStore* _tmp16_;
	gboolean _tmp17_;
	gboolean _tmp18_;
	GError * _inner_error_;
};

typedef enum  {
	FOLKS_MATCH_RESULT_NONE = -1,
	FOLKS_MATCH_RESULT_VERY_LOW = 0,
	FOLKS_MATCH_RESULT_LOW = 1,
	FOLKS_MATCH_RESULT_MEDIUM = 2,
	FOLKS_MATCH_RESULT_HIGH = 3,
	FOLKS_MATCH_RESULT_VERY_HIGH = 4,
	FOLKS_MATCH_RESULT_MIN = FOLKS_MATCH_RESULT_NONE,
	FOLKS_MATCH_RESULT_MAX = FOLKS_MATCH_RESULT_VERY_HIGH
} FolksMatchResult;

struct _FolksIndividualAggregatorAddBackendData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	FolksIndividualAggregator* self;
	FolksBackend* backend;
	FolksSmallSet* _tmp0_;
	FolksBackend* _tmp1_;
	gboolean _tmp2_;
	FolksSmallSet* _tmp3_;
	FolksBackend* _tmp4_;
	FolksBackend* _tmp5_;
	FolksBackend* _tmp6_;
	FolksBackend* _tmp7_;
	FolksPersonaStore** stores;
	FolksBackend* _tmp8_;
	GeeMap* _tmp9_;
	GeeMap* _tmp10_;
	GeeCollection* _tmp11_;
	GeeCollection* _tmp12_;
	GeeCollection* _tmp13_;
	gint _tmp14_;
	gpointer* _tmp15_;
	FolksPersonaStore** _tmp16_;
	gint _tmp16__length1;
	gint stores_length1;
	gint _stores_size_;
	FolksPersonaStore** _tmp17_;
	gint _tmp17__length1;
	FolksPersonaStore** persona_store_collection;
	gint persona_store_collection_length1;
	gint _persona_store_collection_size_;
	gint persona_store_it;
	FolksPersonaStore* _tmp18_;
	FolksPersonaStore* persona_store;
	FolksBackend* _tmp19_;
	FolksPersonaStore* _tmp20_;
};

struct _Block4Data {
	int _ref_count_;
	FolksIndividualAggregator * self;
	gchar* store_id;
	FolksPersonaStore* store;
};

typedef enum  {
	FOLKS_GROUP_DETAILS_CHANGE_REASON_NONE = 0,
	FOLKS_GROUP_DETAILS_CHANGE_REASON_OFFLINE = 1,
	FOLKS_GROUP_DETAILS_CHANGE_REASON_KICKED = 2,
	FOLKS_GROUP_DETAILS_CHANGE_REASON_BUSY = 3,
	FOLKS_GROUP_DETAILS_CHANGE_REASON_INVITED = 4,
	FOLKS_GROUP_DETAILS_CHANGE_REASON_BANNED = 5,
	FOLKS_GROUP_DETAILS_CHANGE_REASON_ERROR = 6,
	FOLKS_GROUP_DETAILS_CHANGE_REASON_INVALID_MEMBER = 7,
	FOLKS_GROUP_DETAILS_CHANGE_REASON_NO_ANSWER = 8,
	FOLKS_GROUP_DETAILS_CHANGE_REASON_RENAMED = 9,
	FOLKS_GROUP_DETAILS_CHANGE_REASON_PERMISSION_DENIED = 10,
	FOLKS_GROUP_DETAILS_CHANGE_REASON_SEPARATED = 11
} FolksGroupDetailsChangeReason;

struct _Block5Data {
	int _ref_count_;
	FolksIndividualAggregator * self;
	FolksPersona* persona;
	GeeHashSet* candidate_inds;
};

typedef enum  {
	FOLKS_PERSONA_STORE_TRUST_NONE,
	FOLKS_PERSONA_STORE_TRUST_PARTIAL,
	FOLKS_PERSONA_STORE_TRUST_FULL
} FolksPersonaStoreTrust;

struct _Block6Data {
	int _ref_count_;
	Block5Data * _data5_;
	const gchar* prop_name;
};

typedef void (*FolksPersonaLinkablePropertyCallback) (const gchar* link, void* user_data);
typedef enum  {
	FOLKS_PROPERTY_ERROR_NOT_WRITEABLE,
	FOLKS_PROPERTY_ERROR_INVALID_VALUE,
	FOLKS_PROPERTY_ERROR_UNKNOWN_ERROR,
	FOLKS_PROPERTY_ERROR_UNAVAILABLE
} FolksPropertyError;
#define FOLKS_PROPERTY_ERROR folks_property_error_quark ()
struct _FolksAntiLinkableIface {
	GTypeInterface parent_iface;
	void (*change_anti_links) (FolksAntiLinkable* self, GeeSet* anti_links, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*change_anti_links_finish) (FolksAntiLinkable* self, GAsyncResult* _res_, GError** error);
	GeeSet* (*get_anti_links) (FolksAntiLinkable* self);
	void (*set_anti_links) (FolksAntiLinkable* self, GeeSet* value);
};

struct _Block7Data {
	int _ref_count_;
	FolksIndividualAggregator * self;
	FolksIndividual* individual;
};

typedef enum  {
	FOLKS_PERSONA_STORE_ERROR_INVALID_ARGUMENT,
	FOLKS_PERSONA_STORE_ERROR_CREATE_FAILED,
	FOLKS_PERSONA_STORE_ERROR_UNSUPPORTED_ON_USER,
	FOLKS_PERSONA_STORE_ERROR_STORE_OFFLINE,
	FOLKS_PERSONA_STORE_ERROR_READ_ONLY,
	FOLKS_PERSONA_STORE_ERROR_PERMISSION_DENIED,
	FOLKS_PERSONA_STORE_ERROR_REMOVE_FAILED,
	FOLKS_PERSONA_STORE_ERROR_UNSUPPORTED_ON_NON_USER
} FolksPersonaStoreError;
#define FOLKS_PERSONA_STORE_ERROR folks_persona_store_error_quark ()
struct _FolksIndividualAggregatorAddPersonaFromDetailsData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	FolksIndividualAggregator* self;
	FolksIndividual* parent;
	FolksPersonaStore* persona_store;
	GHashTable* details;
	FolksPersona* result;
	FolksPersona* persona;
	GHashTable* details_copy;
	GHashTable* _tmp0_;
	GHashTable* _tmp1_;
	FolksPersona* _tmp2_;
	FolksPersonaStore* _tmp3_;
	GHashTable* _tmp4_;
	FolksPersona* _tmp5_;
	GError* e;
	GError* _tmp6_;
	GError* _tmp7_;
	const gchar* _tmp8_;
	GError* _tmp9_;
	gchar* full_id;
	FolksPersonaStore* _tmp10_;
	const gchar* _tmp11_;
	const gchar* _tmp12_;
	FolksPersonaStore* _tmp13_;
	const gchar* _tmp14_;
	const gchar* _tmp15_;
	gchar* _tmp16_;
	const gchar* _tmp17_;
	const gchar* _tmp18_;
	GError* _tmp19_;
	const gchar* _tmp20_;
	GError* _tmp21_;
	gboolean _tmp22_;
	FolksIndividual* _tmp23_;
	FolksPersona* _tmp24_;
	gboolean _tmp25_;
	FolksIndividual* _tmp26_;
	GeeSet* _tmp27_;
	GeeSet* _tmp28_;
	FolksPersona* _tmp29_;
	GError * _inner_error_;
};

struct _Block8Data {
	int _ref_count_;
	FolksIndividualAggregator * self;
	GHashTable* retval;
};

struct _FolksIndividualAggregatorRemoveIndividualData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	FolksIndividualAggregator* self;
	FolksIndividual* individual;
	FolksSmallSet* personas;
	FolksIndividual* _tmp0_;
	GeeSet* _tmp1_;
	GeeSet* _tmp2_;
	FolksSmallSet* _tmp3_;
	FolksSmallSet* _persona_list;
	FolksSmallSet* _tmp4_;
	FolksSmallSet* _tmp5_;
	gint _persona_size;
	FolksSmallSet* _tmp6_;
	gint _tmp7_;
	gint _tmp8_;
	gint _persona_index;
	gint _tmp9_;
	gint _tmp10_;
	gint _tmp11_;
	FolksPersona* persona;
	FolksSmallSet* _tmp12_;
	gint _tmp13_;
	gconstpointer _tmp14_;
	FolksPersona* _tmp15_;
	FolksPersona* _tmp16_;
	FolksPersonaStore* _tmp17_;
	FolksPersonaStore* _tmp18_;
	FolksPersona* _tmp19_;
	GError * _inner_error_;
};

struct _FolksIndividualAggregatorRemovePersonaData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	FolksIndividualAggregator* self;
	FolksPersona* persona;
	FolksPersona* _tmp0_;
	FolksPersonaStore* _tmp1_;
	FolksPersonaStore* _tmp2_;
	FolksPersona* _tmp3_;
	GError * _inner_error_;
};

struct _FolksIndividualAggregatorLinkPersonasData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	FolksIndividualAggregator* self;
	GeeSet* personas;
	FolksPersonaStore* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	const gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	gchar* _tmp8_;
	const gchar* _tmp9_;
	gchar* _tmp10_;
	gchar* _tmp11_;
	const gchar* _tmp12_;
	const gchar* _tmp13_;
	gchar* _tmp14_;
	gchar* _tmp15_;
	GError* _tmp16_;
	GError* _tmp17_;
	GeeSet* _tmp18_;
	gint _tmp19_;
	gint _tmp20_;
	gboolean _tmp21_;
	GeeIterator* _p_it;
	GeeSet* _tmp22_;
	GeeIterator* _tmp23_;
	GeeIterator* _tmp24_;
	gboolean _tmp25_;
	FolksPersona* p;
	GeeIterator* _tmp26_;
	gpointer _tmp27_;
	FolksAntiLinkable* al;
	FolksPersona* _tmp28_;
	FolksAntiLinkable* _tmp29_;
	FolksAntiLinkable* _tmp30_;
	FolksAntiLinkable* _tmp31_;
	GeeSet* _tmp32_;
	GError* e;
	const gchar* _tmp33_;
	GError* _tmp34_;
	FolksPersonaStore* _tmp35_;
	const gchar* _tmp36_;
	const gchar* _tmp37_;
	const gchar* _tmp38_;
	GHashTable* details;
	GeeSet* _tmp39_;
	GHashTable* _tmp40_;
	FolksPersonaStore* _tmp41_;
	GHashTable* _tmp42_;
	FolksPersona* _tmp43_;
	FolksPersona* _tmp44_;
	GError * _inner_error_;
};

struct _FolksImDetailsIface {
	GTypeInterface parent_iface;
	void (*change_im_addresses) (FolksImDetails* self, GeeMultiMap* im_addresses, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*change_im_addresses_finish) (FolksImDetails* self, GAsyncResult* _res_, GError** error);
	GeeMultiMap* (*get_im_addresses) (FolksImDetails* self);
	void (*set_im_addresses) (FolksImDetails* self, GeeMultiMap* value);
};

struct _FolksWebServiceDetailsIface {
	GTypeInterface parent_iface;
	void (*change_web_service_addresses) (FolksWebServiceDetails* self, GeeMultiMap* web_service_addresses, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*change_web_service_addresses_finish) (FolksWebServiceDetails* self, GAsyncResult* _res_, GError** error);
	GeeMultiMap* (*get_web_service_addresses) (FolksWebServiceDetails* self);
	void (*set_web_service_addresses) (FolksWebServiceDetails* self, GeeMultiMap* value);
};

struct _FolksLocalIdDetailsIface {
	GTypeInterface parent_iface;
	void (*change_local_ids) (FolksLocalIdDetails* self, GeeSet* local_ids, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*change_local_ids_finish) (FolksLocalIdDetails* self, GAsyncResult* _res_, GError** error);
	GeeSet* (*get_local_ids) (FolksLocalIdDetails* self);
	void (*set_local_ids) (FolksLocalIdDetails* self, GeeSet* value);
};

typedef enum  {
	FOLKS_PERSONA_DETAIL_INVALID = -1,
	FOLKS_PERSONA_DETAIL_ALIAS = 0,
	FOLKS_PERSONA_DETAIL_AVATAR,
	FOLKS_PERSONA_DETAIL_BIRTHDAY,
	FOLKS_PERSONA_DETAIL_EMAIL_ADDRESSES,
	FOLKS_PERSONA_DETAIL_FULL_NAME,
	FOLKS_PERSONA_DETAIL_GENDER,
	FOLKS_PERSONA_DETAIL_IM_ADDRESSES,
	FOLKS_PERSONA_DETAIL_IS_FAVOURITE,
	FOLKS_PERSONA_DETAIL_LOCAL_IDS,
	FOLKS_PERSONA_DETAIL_LOCATION,
	FOLKS_PERSONA_DETAIL_NICKNAME,
	FOLKS_PERSONA_DETAIL_NOTES,
	FOLKS_PERSONA_DETAIL_PHONE_NUMBERS,
	FOLKS_PERSONA_DETAIL_POSTAL_ADDRESSES,
	FOLKS_PERSONA_DETAIL_ROLES,
	FOLKS_PERSONA_DETAIL_STRUCTURED_NAME,
	FOLKS_PERSONA_DETAIL_URLS,
	FOLKS_PERSONA_DETAIL_WEB_SERVICE_ADDRESSES,
	FOLKS_PERSONA_DETAIL_GROUPS,
	FOLKS_PERSONA_DETAIL_IM_INTERACTION_COUNT,
	FOLKS_PERSONA_DETAIL_LAST_IM_INTERACTION_DATETIME,
	FOLKS_PERSONA_DETAIL_CALL_INTERACTION_COUNT,
	FOLKS_PERSONA_DETAIL_LAST_CALL_INTERACTION_DATETIME,
	FOLKS_PERSONA_DETAIL_ANTI_LINKS
} FolksPersonaDetail;

struct _FolksIndividualAggregatorUnlinkIndividualData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	FolksIndividualAggregator* self;
	FolksIndividual* individual;
	gboolean _tmp0_;
	FolksIndividual* _tmp1_;
	const gchar* _tmp2_;
	const gchar* _tmp3_;
	FolksIndividual* _tmp4_;
	const gchar* _tmp5_;
	const gchar* _tmp6_;
	FolksSmallSet* individual_personas;
	FolksIndividual* _tmp7_;
	GeeSet* _tmp8_;
	GeeSet* _tmp9_;
	FolksSmallSet* _tmp10_;
	FolksSmallSet* _pers_list;
	FolksSmallSet* _tmp11_;
	FolksSmallSet* _tmp12_;
	gint _pers_size;
	FolksSmallSet* _tmp13_;
	gint _tmp14_;
	gint _tmp15_;
	gint _pers_index;
	gint _tmp16_;
	gint _tmp17_;
	gint _tmp18_;
	FolksPersona* pers;
	FolksSmallSet* _tmp19_;
	gint _tmp20_;
	gconstpointer _tmp21_;
	FolksPersona* _tmp22_;
	FolksSmallSet* personas;
	FolksSmallSet* _tmp23_;
	FolksSmallSet* _tmp24_;
	FolksPersona* _tmp25_;
	FolksPersona* _tmp26_;
	const gchar* _tmp27_;
	const gchar* _tmp28_;
	FolksPersona* _tmp29_;
	FolksPersona* writeable_persona;
	FolksSmallSet* _tmp30_;
	FolksPersona* _tmp31_;
	FolksPersona* _tmp32_;
	const gchar* _tmp33_;
	const gchar* _tmp34_;
	FolksPersona* _tmp35_;
	FolksSmallSet* anti_link_personas;
	FolksSmallSet* _tmp36_;
	FolksSmallSet* _tmp37_;
	FolksSmallSet* _tmp38_;
	FolksPersona* _tmp39_;
	FolksAntiLinkable* al;
	FolksPersona* _tmp40_;
	FolksAntiLinkable* _tmp41_;
	FolksAntiLinkable* _tmp42_;
	FolksAntiLinkable* _tmp43_;
	FolksSmallSet* _tmp44_;
	GError* e1;
	GError* _tmp45_;
	const gchar* _tmp46_;
	GError * _inner_error_;
};

struct _FolksIndividualAggregatorEnsureIndividualPropertyWriteableData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	FolksIndividualAggregator* self;
	FolksIndividual* individual;
	gchar* property_name;
	FolksPersona* result;
	FolksIndividual* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	const gchar* _tmp3_;
	FolksPersona* p;
	FolksIndividual* _tmp4_;
	GeeSet* _tmp5_;
	GeeSet* _tmp6_;
	const gchar* _tmp7_;
	FolksPersona* _tmp8_;
	GError * _inner_error_;
};

struct _FolksIndividualAggregatorEnsurePersonasPropertyWriteableData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	FolksIndividualAggregator* self;
	GeeSet* personas;
	gchar* property_name;
	FolksPersona* result;
	GeeIterator* _p1_it;
	GeeSet* _tmp0_;
	GeeIterator* _tmp1_;
	GeeIterator* _tmp2_;
	gboolean _tmp3_;
	FolksPersona* p1;
	GeeIterator* _tmp4_;
	gpointer _tmp5_;
	const gchar* _tmp6_;
	FolksPersona* _tmp7_;
	gchar** _tmp8_;
	gint _tmp8__length1;
	gchar** _tmp9_;
	gint _tmp9__length1;
	FolksPersona* _tmp10_;
	const gchar* _tmp11_;
	const gchar* _tmp12_;
	GHashTable* details;
	GeeSet* _tmp13_;
	GHashTable* _tmp14_;
	FolksPersona* new_persona;
	gboolean _tmp15_;
	FolksPersonaStore* _tmp16_;
	const gchar* _tmp17_;
	FolksPersonaStore* _tmp18_;
	gchar** _tmp19_;
	gint _tmp19__length1;
	gchar** _tmp20_;
	gint _tmp20__length1;
	gboolean _tmp21_;
	FolksPersona* _tmp22_;
	FolksPersonaStore* _tmp23_;
	GHashTable* _tmp24_;
	FolksPersona* _tmp25_;
	GError* e1;
	FolksPersona* _tmp26_;
	GeeIterator* _s_it;
	GeeHashMap* _tmp27_;
	GeeCollection* _tmp28_;
	GeeCollection* _tmp29_;
	GeeCollection* _tmp30_;
	GeeIterator* _tmp31_;
	GeeIterator* _tmp32_;
	GeeIterator* _tmp33_;
	gboolean _tmp34_;
	FolksPersonaStore* s;
	GeeIterator* _tmp35_;
	gpointer _tmp36_;
	gboolean _tmp37_;
	FolksPersonaStore* _tmp38_;
	FolksPersonaStore* _tmp39_;
	const gchar* _tmp40_;
	FolksPersonaStore* _tmp41_;
	gchar** _tmp42_;
	gint _tmp42__length1;
	gchar** _tmp43_;
	gint _tmp43__length1;
	gboolean _tmp44_;
	FolksPersonaStore* _tmp45_;
	const gchar* _tmp46_;
	const gchar* _tmp47_;
	FolksPersona* _tmp48_;
	FolksPersonaStore* _tmp49_;
	GHashTable* _tmp50_;
	FolksPersona* _tmp51_;
	GError* e2;
	gboolean _tmp52_;
	FolksPersona* _tmp53_;
	FolksPersonaStore* _tmp54_;
	gboolean _tmp55_;
	const gchar* _tmp56_;
	gchar* _tmp57_;
	gchar* _tmp58_;
	const gchar* _tmp59_;
	gchar* _tmp60_;
	gchar* _tmp61_;
	gchar* _tmp62_;
	gchar* _tmp63_;
	const gchar* _tmp64_;
	gchar* _tmp65_;
	gchar* _tmp66_;
	const gchar* _tmp67_;
	const gchar* _tmp68_;
	gchar* _tmp69_;
	gchar* _tmp70_;
	GError* _tmp71_;
	GError* _tmp72_;
	FolksPersona* _tmp73_;
	const gchar* _tmp74_;
	const gchar* _tmp75_;
	GError* _tmp76_;
	FolksPersona* _tmp77_;
	FolksPersona* _tmp78_;
	GError * _inner_error_;
};

struct _FolksIndividualAggregatorLookUpIndividualData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	FolksIndividualAggregator* self;
	gchar* id;
	FolksIndividual* result;
	GeeMap* _tmp0_;
	const gchar* _tmp1_;
	gpointer _tmp2_;
	GError * _inner_error_;
};


static gpointer folks_individual_aggregator_parent_class = NULL;

GQuark folks_individual_aggregator_error_quark (void);
GType folks_individual_aggregator_get_type (void) G_GNUC_CONST;
GType folks_backend_store_get_type (void) G_GNUC_CONST;
GType folks_persona_store_get_type (void) G_GNUC_CONST;
GType folks_backend_get_type (void) G_GNUC_CONST;
GType folks_individual_get_type (void) G_GNUC_CONST;
GType folks_debug_get_type (void) G_GNUC_CONST;
#define FOLKS_INDIVIDUAL_AGGREGATOR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), FOLKS_TYPE_INDIVIDUAL_AGGREGATOR, FolksIndividualAggregatorPrivate))
enum  {
	FOLKS_INDIVIDUAL_AGGREGATOR_DUMMY_PROPERTY,
	FOLKS_INDIVIDUAL_AGGREGATOR_IS_PREPARED,
	FOLKS_INDIVIDUAL_AGGREGATOR_IS_QUIESCENT,
	FOLKS_INDIVIDUAL_AGGREGATOR_PRIMARY_STORE,
	FOLKS_INDIVIDUAL_AGGREGATOR_INDIVIDUALS,
	FOLKS_INDIVIDUAL_AGGREGATOR_USER
};
static void _folks_individual_aggregator_backend_available_cb (FolksIndividualAggregator* self, FolksBackendStore* backend_store, FolksBackend* backend);
static void __folks_individual_aggregator_backend_available_cb_folks_backend_store_backend_available (FolksBackendStore* _sender, FolksBackend* backend, gpointer self);
static void _folks_individual_aggregator_debug_print_status (FolksIndividualAggregator* self, FolksDebug* debug);
static void __folks_individual_aggregator_debug_print_status_folks_debug_print_status (FolksDebug* _sender, gpointer self);
#define FOLKS_INDIVIDUAL_AGGREGATOR__FOLKS_GSETTINGS_SCHEMA "org.freedesktop.folks"
#define FOLKS_INDIVIDUAL_AGGREGATOR__PRIMARY_STORE_CONFIG_KEY "primary-store"
#define FOLKS_INDIVIDUAL_AGGREGATOR__QUIESCENT_TIMEOUT ((guint) 30)
FolksIndividualAggregator* folks_individual_aggregator_new (void);
FolksIndividualAggregator* folks_individual_aggregator_construct (GType object_type);
FolksBackendStore* folks_backend_store_dup (void);
FolksIndividualAggregator* folks_individual_aggregator_new_with_backend_store (FolksBackendStore* store);
FolksIndividualAggregator* folks_individual_aggregator_construct_with_backend_store (GType object_type, FolksBackendStore* store);
static void _folks_individual_aggregator_configure_primary_store (FolksIndividualAggregator* self, const gchar* store_config_ids);
#define FOLKS_DEBUG_STATUS_LOG_DOMAIN "folks-status"
void folks_debug_print_heading (FolksDebug* self, const gchar* domain, GLogLevelFlags level, const gchar* format, ...);
void folks_debug_print_key_value_pairs (FolksDebug* self, const gchar* domain, GLogLevelFlags level, ...);
void folks_debug_print_line (FolksDebug* self, const gchar* domain, GLogLevelFlags level, const gchar* format, ...);
GeeMap* folks_individual_aggregator_get_individuals (FolksIndividualAggregator* self);
void folks_debug_indent (FolksDebug* self);
GType folks_trust_level_get_type (void) G_GNUC_CONST;
FolksTrustLevel folks_individual_get_trust_level (FolksIndividual* self);
gboolean folks_individual_get_is_user (FolksIndividual* self);
const gchar* folks_individual_get_id (FolksIndividual* self);
GType folks_persona_get_type (void) G_GNUC_CONST;
GeeSet* folks_individual_get_personas (FolksIndividual* self);
gboolean folks_persona_get_is_user (FolksPersona* self);
const gchar* folks_persona_get_uid (FolksPersona* self);
const gchar* folks_persona_get_iid (FolksPersona* self);
const gchar* folks_persona_get_display_id (FolksPersona* self);
void folks_debug_unindent (FolksDebug* self);
static void folks_individual_aggregator_prepare_data_free (gpointer _data);
void folks_individual_aggregator_prepare (FolksIndividualAggregator* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void folks_individual_aggregator_prepare_finish (FolksIndividualAggregator* self, GAsyncResult* _res_, GError** error);
static gboolean folks_individual_aggregator_prepare_co (FolksIndividualAggregatorPrepareData* _data_);
GeeMap* folks_backend_store_get_enabled_backends (FolksBackendStore* self);
void folks_backend_store_load_backends (FolksBackendStore* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void folks_backend_store_load_backends_finish (FolksBackendStore* self, GAsyncResult* _res_, GError** error);
static void folks_individual_aggregator_prepare_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void _folks_individual_aggregator_notify_if_is_quiescent (FolksIndividualAggregator* self);
static void folks_individual_aggregator_unprepare_data_free (gpointer _data);
void folks_individual_aggregator_unprepare (FolksIndividualAggregator* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void folks_individual_aggregator_unprepare_finish (FolksIndividualAggregator* self, GAsyncResult* _res_, GError** error);
static gboolean folks_individual_aggregator_unprepare_co (FolksIndividualAggregatorUnprepareData* _data_);
void folks_persona_store_flush (FolksPersonaStore* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void folks_persona_store_flush_finish (FolksPersonaStore* self, GAsyncResult* _res_);
static void folks_individual_aggregator_unprepare_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
GType folks_match_result_get_type (void) G_GNUC_CONST;
GeeMap* folks_individual_aggregator_get_potential_matches (FolksIndividualAggregator* self, FolksIndividual* matchee, FolksMatchResult min_threshold);
GType folks_potential_match_get_type (void) G_GNUC_CONST;
FolksPotentialMatch* folks_potential_match_new (void);
FolksPotentialMatch* folks_potential_match_construct (GType object_type);
FolksMatchResult folks_potential_match_potential_match (FolksPotentialMatch* self, FolksIndividual* a, FolksIndividual* b);
GeeMap* folks_individual_aggregator_get_all_potential_matches (FolksIndividualAggregator* self, FolksMatchResult min_threshold);
static void _folks_individual_aggregator_add_backend_data_free (gpointer _data);
static void _folks_individual_aggregator_add_backend (FolksIndividualAggregator* self, FolksBackend* backend, GAsyncReadyCallback _callback_, gpointer _user_data_);
static void _folks_individual_aggregator_add_backend_finish (FolksIndividualAggregator* self, GAsyncResult* _res_);
static gboolean _folks_individual_aggregator_add_backend_co (FolksIndividualAggregatorAddBackendData* _data_);
static void _folks_individual_aggregator_backend_persona_store_added_cb (FolksIndividualAggregator* self, FolksBackend* backend, FolksPersonaStore* store);
static void __folks_individual_aggregator_backend_persona_store_added_cb_folks_backend_persona_store_added (FolksBackend* _sender, FolksPersonaStore* store, gpointer self);
static void _folks_individual_aggregator_backend_persona_store_removed_cb (FolksIndividualAggregator* self, FolksBackend* backend, FolksPersonaStore* store);
static void __folks_individual_aggregator_backend_persona_store_removed_cb_folks_backend_persona_store_removed (FolksBackend* _sender, FolksPersonaStore* store, gpointer self);
static void _folks_individual_aggregator_backend_is_quiescent_changed_cb (FolksIndividualAggregator* self, GObject* obj, GParamSpec* pspec);
static void __folks_individual_aggregator_backend_is_quiescent_changed_cb_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
GeeMap* folks_backend_get_persona_stores (FolksBackend* self);
gboolean folks_backend_get_is_quiescent (FolksBackend* self);
static gboolean _folks_individual_aggregator_quiescent_timeout_cb (FolksIndividualAggregator* self);
static gboolean __folks_individual_aggregator_quiescent_timeout_cb_gsource_func (gpointer self);
static void _folks_individual_aggregator_set_primary_store (FolksIndividualAggregator* self, FolksPersonaStore* store);
const gchar* folks_persona_store_get_type_id (FolksPersonaStore* self);
const gchar* folks_persona_store_get_id (FolksPersonaStore* self);
void folks_persona_store_set_is_primary_store (FolksPersonaStore* self, gboolean value);
static Block4Data* block4_data_ref (Block4Data* _data4_);
static void block4_data_unref (void * _userdata_);
const gchar* folks_backend_get_name (FolksBackend* self);
static gchar* _folks_individual_aggregator_get_store_full_id (FolksIndividualAggregator* self, const gchar* type_id, const gchar* id);
static gboolean _folks_individual_aggregator_maybe_configure_as_primary (FolksIndividualAggregator* self, FolksPersonaStore* store);
GType folks_group_details_change_reason_get_type (void) G_GNUC_CONST;
static void _folks_individual_aggregator_personas_changed_cb (FolksIndividualAggregator* self, FolksPersonaStore* store, GeeSet* added, GeeSet* removed, const gchar* message, FolksPersona* actor, FolksGroupDetailsChangeReason reason);
static void __folks_individual_aggregator_personas_changed_cb_folks_persona_store_personas_changed (FolksPersonaStore* _sender, GeeSet* added, GeeSet* removed, const gchar* message, FolksPersona* actor, FolksGroupDetailsChangeReason reason, gpointer self);
static void _folks_individual_aggregator_is_primary_store_changed_cb (FolksIndividualAggregator* self, GObject* object, GParamSpec* pspec);
static void __folks_individual_aggregator_is_primary_store_changed_cb_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
static void _folks_individual_aggregator_persona_store_is_quiescent_changed_cb (FolksIndividualAggregator* self, GObject* obj, GParamSpec* pspec);
static void __folks_individual_aggregator_persona_store_is_quiescent_changed_cb_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
static void _folks_individual_aggregator_persona_store_is_user_set_default_changed_cb (FolksIndividualAggregator* self, GObject* obj, GParamSpec* pspec);
static void __folks_individual_aggregator_persona_store_is_user_set_default_changed_cb_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
gboolean folks_persona_store_get_is_quiescent (FolksPersonaStore* self);
GeeMap* folks_persona_store_get_personas (FolksPersonaStore* self);
void folks_persona_store_prepare (FolksPersonaStore* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void folks_persona_store_prepare_finish (FolksPersonaStore* self, GAsyncResult* _res_, GError** error);
static void __lambda67_ (Block4Data* _data4_, GObject* obj, GAsyncResult* _result_);
static void ___lambda67__gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self);
static void _folks_individual_aggregator_emit_individuals_changed (FolksIndividualAggregator* self, GeeSet* added, GeeSet* removed, GeeMultiMap* changes, const gchar* message, FolksPersona* actor, FolksGroupDetailsChangeReason reason);
gboolean folks_debug_get_debug_output_enabled (FolksDebug* self);
static void _folks_individual_aggregator_connect_to_individual (FolksIndividualAggregator* self, FolksIndividual* individual);
static void _folks_individual_aggregator_individual_removed_cb (FolksIndividualAggregator* self, FolksIndividual* i, FolksIndividual* replacement);
static void __folks_individual_aggregator_individual_removed_cb_folks_individual_removed (FolksIndividual* _sender, FolksIndividual* replacement_individual, gpointer self);
static void _folks_individual_aggregator_disconnect_from_individual (FolksIndividualAggregator* self, FolksIndividual* individual);
static void _folks_individual_aggregator_add_personas (FolksIndividualAggregator* self, GeeSet* added, FolksIndividual** user, GeeHashMultiMap** individuals_changes);
static Block5Data* block5_data_ref (Block5Data* _data5_);
static void block5_data_unref (void * _userdata_);
GType folks_persona_store_trust_get_type (void) G_GNUC_CONST;
FolksPersonaStore* folks_persona_get_store (FolksPersona* self);
FolksPersonaStoreTrust folks_persona_store_get_trust_level (FolksPersonaStore* self);
gboolean folks_individual_has_anti_link_with_persona (FolksIndividual* self, FolksPersona* p);
gchar** folks_persona_get_linkable_properties (FolksPersona* self, int* result_length1);
static Block6Data* block6_data_ref (Block6Data* _data6_);
static void block6_data_unref (void * _userdata_);
void folks_persona_linkable_property_to_links (FolksPersona* self, const gchar* prop_name, FolksPersonaLinkablePropertyCallback callback, void* callback_target);
static void _______lambda65_ (Block6Data* _data6_, const gchar* l);
static void ________lambda65__folks_persona_linkable_property_callback (const gchar* link, gpointer self);
FolksIndividual* folks_individual_new (GeeSet* personas);
FolksIndividual* folks_individual_construct (GType object_type, GeeSet* personas);
static void _folks_individual_aggregator_add_persona_to_link_map (FolksIndividualAggregator* self, FolksPersona* persona, FolksIndividual* individual);
static void _folks_individual_aggregator_remove_individual_from_link_map (FolksIndividualAggregator* self, FolksIndividual* individual);
static void _folks_individual_aggregator_persona_linkable_property_changed_cb (FolksIndividualAggregator* self, GObject* obj, GParamSpec* pspec);
static void _folks_individual_aggregator_persona_anti_links_changed_cb (FolksIndividualAggregator* self, GObject* obj, GParamSpec* pspec);
static void _folks_individual_aggregator_connect_to_persona (FolksIndividualAggregator* self, FolksPersona* persona);
static void __folks_individual_aggregator_persona_linkable_property_changed_cb_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
GQuark folks_property_error_quark (void);
GType folks_anti_linkable_get_type (void) G_GNUC_CONST;
static void __folks_individual_aggregator_persona_anti_links_changed_cb_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
static void _folks_individual_aggregator_disconnect_from_persona (FolksIndividualAggregator* self, FolksPersona* persona);
static void _folks_individual_aggregator_link_map_set (FolksIndividualAggregator* self, const gchar* key, FolksIndividual* individual);
static void _g_object_unref0_ (gpointer var);
static Block7Data* block7_data_ref (Block7Data* _data7_);
static void block7_data_unref (void * _userdata_);
static void _____lambda66_ (Block7Data* _data7_, const gchar* l);
static void ______lambda66__folks_persona_linkable_property_callback (const gchar* link, gpointer self);
FolksIndividual* folks_individual_aggregator_get_user (FolksIndividualAggregator* self);
FolksIndividual* folks_persona_get_individual (FolksPersona* self);
void folks_individual_set_personas (FolksIndividual* self, GeeSet* value);
static void folks_individual_aggregator_set_user (FolksIndividualAggregator* self, FolksIndividual* value);
void folks_individual_replace (FolksIndividual* self, FolksIndividual* replacement_individual);
gboolean folks_persona_store_get_is_primary_store (FolksPersonaStore* self);
gboolean folks_persona_store_get_is_user_set_default (FolksPersonaStore* self);
static void folks_individual_aggregator_add_persona_from_details_data_free (gpointer _data);
void folks_individual_aggregator_add_persona_from_details (FolksIndividualAggregator* self, FolksIndividual* parent, FolksPersonaStore* persona_store, GHashTable* details, GAsyncReadyCallback _callback_, gpointer _user_data_);
FolksPersona* folks_individual_aggregator_add_persona_from_details_finish (FolksIndividualAggregator* self, GAsyncResult* _res_, GError** error);
static gboolean folks_individual_aggregator_add_persona_from_details_co (FolksIndividualAggregatorAddPersonaFromDetailsData* _data_);
static GHashTable* _folks_individual_aggregator_asv_copy (FolksIndividualAggregator* self, GHashTable* asv);
void folks_persona_store_add_persona_from_details (FolksPersonaStore* self, GHashTable* details, GAsyncReadyCallback _callback_, gpointer _user_data_);
GQuark folks_persona_store_error_quark (void);
FolksPersona* folks_persona_store_add_persona_from_details_finish (FolksPersonaStore* self, GAsyncResult* _res_, GError** error);
static void folks_individual_aggregator_add_persona_from_details_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static Block8Data* block8_data_ref (Block8Data* _data8_);
static void block8_data_unref (void * _userdata_);
static void _g_free0_ (gpointer var);
static void _vala_GValue_free (GValue* self);
static void __vala_GValue_free0_ (gpointer var);
static void __lambda68_ (Block8Data* _data8_, const gchar* k, GValue* v);
static GValue* _g_value_dup (GValue* self);
static void ___lambda68__gh_func (gconstpointer key, gconstpointer value, gpointer self);
static void folks_individual_aggregator_remove_individual_data_free (gpointer _data);
void folks_individual_aggregator_remove_individual (FolksIndividualAggregator* self, FolksIndividual* individual, GAsyncReadyCallback _callback_, gpointer _user_data_);
void folks_individual_aggregator_remove_individual_finish (FolksIndividualAggregator* self, GAsyncResult* _res_, GError** error);
static gboolean folks_individual_aggregator_remove_individual_co (FolksIndividualAggregatorRemoveIndividualData* _data_);
void folks_persona_store_remove_persona (FolksPersonaStore* self, FolksPersona* persona, GAsyncReadyCallback _callback_, gpointer _user_data_);
void folks_persona_store_remove_persona_finish (FolksPersonaStore* self, GAsyncResult* _res_, GError** error);
static void folks_individual_aggregator_remove_individual_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void folks_individual_aggregator_remove_persona_data_free (gpointer _data);
void folks_individual_aggregator_remove_persona (FolksIndividualAggregator* self, FolksPersona* persona, GAsyncReadyCallback _callback_, gpointer _user_data_);
void folks_individual_aggregator_remove_persona_finish (FolksIndividualAggregator* self, GAsyncResult* _res_, GError** error);
static gboolean folks_individual_aggregator_remove_persona_co (FolksIndividualAggregatorRemovePersonaData* _data_);
static void folks_individual_aggregator_remove_persona_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void folks_individual_aggregator_link_personas_data_free (gpointer _data);
void folks_individual_aggregator_link_personas (FolksIndividualAggregator* self, GeeSet* personas, GAsyncReadyCallback _callback_, gpointer _user_data_);
void folks_individual_aggregator_link_personas_finish (FolksIndividualAggregator* self, GAsyncResult* _res_, GError** error);
static gboolean folks_individual_aggregator_link_personas_co (FolksIndividualAggregatorLinkPersonasData* _data_);
void folks_anti_linkable_remove_anti_links (FolksAntiLinkable* self, GeeSet* other_personas, GAsyncReadyCallback _callback_, gpointer _user_data_);
void folks_anti_linkable_remove_anti_links_finish (FolksAntiLinkable* self, GAsyncResult* _res_, GError** error);
static void folks_individual_aggregator_link_personas_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static GHashTable* _folks_individual_aggregator_build_linking_details (FolksIndividualAggregator* self, GeeSet* personas);
GType folks_abstract_field_details_get_type (void) G_GNUC_CONST;
GType folks_im_field_details_get_type (void) G_GNUC_CONST;
guint folks_abstract_field_details_hash_static (FolksAbstractFieldDetails* value);
static guint _folks_abstract_field_details_hash_static_gee_hash_data_func (gconstpointer v, gpointer self);
gboolean folks_abstract_field_details_equal_static (FolksAbstractFieldDetails* left, FolksAbstractFieldDetails* right);
static gboolean _folks_abstract_field_details_equal_static_gee_equal_data_func (gconstpointer a, gconstpointer b, gpointer self);
GType folks_web_service_field_details_get_type (void) G_GNUC_CONST;
GType folks_im_details_get_type (void) G_GNUC_CONST;
GeeMultiMap* folks_im_details_get_im_addresses (FolksImDetails* self);
GType folks_web_service_details_get_type (void) G_GNUC_CONST;
GeeMultiMap* folks_web_service_details_get_web_service_addresses (FolksWebServiceDetails* self);
GType folks_local_id_details_get_type (void) G_GNUC_CONST;
GeeSet* folks_local_id_details_get_local_ids (FolksLocalIdDetails* self);
GType folks_persona_detail_get_type (void) G_GNUC_CONST;
const gchar* folks_persona_store_detail_key (FolksPersonaDetail detail);
static void folks_individual_aggregator_unlink_individual_data_free (gpointer _data);
void folks_individual_aggregator_unlink_individual (FolksIndividualAggregator* self, FolksIndividual* individual, GAsyncReadyCallback _callback_, gpointer _user_data_);
void folks_individual_aggregator_unlink_individual_finish (FolksIndividualAggregator* self, GAsyncResult* _res_, GError** error);
static gboolean folks_individual_aggregator_unlink_individual_co (FolksIndividualAggregatorUnlinkIndividualData* _data_);
static void _folks_individual_aggregator_ensure_personas_property_writeable (FolksIndividualAggregator* self, GeeSet* personas, const gchar* property_name, GAsyncReadyCallback _callback_, gpointer _user_data_);
static FolksPersona* _folks_individual_aggregator_ensure_personas_property_writeable_finish (FolksIndividualAggregator* self, GAsyncResult* _res_, GError** error);
static void folks_individual_aggregator_unlink_individual_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
void folks_anti_linkable_add_anti_links (FolksAntiLinkable* self, GeeSet* other_personas, GAsyncReadyCallback _callback_, gpointer _user_data_);
void folks_anti_linkable_add_anti_links_finish (FolksAntiLinkable* self, GAsyncResult* _res_, GError** error);
static void folks_individual_aggregator_ensure_individual_property_writeable_data_free (gpointer _data);
void folks_individual_aggregator_ensure_individual_property_writeable (FolksIndividualAggregator* self, FolksIndividual* individual, const gchar* property_name, GAsyncReadyCallback _callback_, gpointer _user_data_);
FolksPersona* folks_individual_aggregator_ensure_individual_property_writeable_finish (FolksIndividualAggregator* self, GAsyncResult* _res_, GError** error);
static gboolean folks_individual_aggregator_ensure_individual_property_writeable_co (FolksIndividualAggregatorEnsureIndividualPropertyWriteableData* _data_);
static void folks_individual_aggregator_ensure_individual_property_writeable_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void _folks_individual_aggregator_ensure_personas_property_writeable_data_free (gpointer _data);
static gboolean _folks_individual_aggregator_ensure_personas_property_writeable_co (FolksIndividualAggregatorEnsurePersonasPropertyWriteableData* _data_);
gchar** folks_persona_get_writeable_properties (FolksPersona* self, int* result_length1);
static gboolean _vala_string_array_contains (gchar** stack, int stack_length, gchar* needle);
gchar** folks_persona_store_get_always_writeable_properties (FolksPersonaStore* self, int* result_length1);
static void _folks_individual_aggregator_ensure_personas_property_writeable_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void folks_individual_aggregator_look_up_individual_data_free (gpointer _data);
void folks_individual_aggregator_look_up_individual (FolksIndividualAggregator* self, const gchar* id, GAsyncReadyCallback _callback_, gpointer _user_data_);
FolksIndividual* folks_individual_aggregator_look_up_individual_finish (FolksIndividualAggregator* self, GAsyncResult* _res_, GError** error);
static gboolean folks_individual_aggregator_look_up_individual_co (FolksIndividualAggregatorLookUpIndividualData* _data_);
static void folks_individual_aggregator_look_up_individual_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
gboolean folks_individual_aggregator_get_is_prepared (FolksIndividualAggregator* self);
gboolean folks_individual_aggregator_get_is_quiescent (FolksIndividualAggregator* self);
FolksPersonaStore* folks_individual_aggregator_get_primary_store (FolksIndividualAggregator* self);
static void folks_individual_aggregator_set_individuals (FolksIndividualAggregator* self, GeeMap* value);
static void g_cclosure_user_marshal_VOID__OBJECT_OBJECT_STRING_OBJECT_ENUM (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static GObject * folks_individual_aggregator_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void _g_ptr_array_unref0_ (gpointer var);
FolksDebug* folks_debug_dup (void);
static void folks_individual_aggregator_finalize (GObject* obj);
static void _vala_folks_individual_aggregator_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_folks_individual_aggregator_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


GQuark folks_individual_aggregator_error_quark (void) {
	return g_quark_from_static_string ("folks_individual_aggregator_error-quark");
}


static void __folks_individual_aggregator_backend_available_cb_folks_backend_store_backend_available (FolksBackendStore* _sender, FolksBackend* backend, gpointer self) {
	_folks_individual_aggregator_backend_available_cb (self, _sender, backend);
}


static void __folks_individual_aggregator_debug_print_status_folks_debug_print_status (FolksDebug* _sender, gpointer self) {
	_folks_individual_aggregator_debug_print_status (self, _sender);
}


/**
   * Create a new IndividualAggregator.
   *
   * Clients should connect to the
   * {@link IndividualAggregator.individuals_changed} signal (or the
   * {@link IndividualAggregator.individuals_changed_detailed} signal), then
   * call {@link IndividualAggregator.prepare} to load the backends and start
   * aggregating individuals.
   *
   * An example of how to set up an IndividualAggregator:
   * {{{
   *   IndividualAggregator agg = new IndividualAggregator ();
   *   agg.individuals_changed_detailed.connect (individuals_changed_cb);
   *   agg.prepare ();
   * }}}
   */
FolksIndividualAggregator* folks_individual_aggregator_construct (GType object_type) {
	FolksIndividualAggregator * self = NULL;
	FolksBackendStore* _tmp0_ = NULL;
	self = (FolksIndividualAggregator*) g_object_new (object_type, NULL);
	_tmp0_ = folks_backend_store_dup ();
	_g_object_unref0 (self->priv->_backend_store);
	self->priv->_backend_store = _tmp0_;
	return self;
}


FolksIndividualAggregator* folks_individual_aggregator_new (void) {
	return folks_individual_aggregator_construct (FOLKS_TYPE_INDIVIDUAL_AGGREGATOR);
}


/**
   * Create a new IndividualAggregator with a custom {@link BackendStore}.
   *
   * This behaves the same as the default constructor for 
   * {@link IndividualAggregator}, but uses the given {@link BackendStore}
   * rather than the default one.
   *
   * @param store the {@link BackendStore} to use instead of the default one.
   *
   * @since 0.9.0
   */
static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


FolksIndividualAggregator* folks_individual_aggregator_construct_with_backend_store (GType object_type, FolksBackendStore* store) {
	FolksIndividualAggregator * self = NULL;
	FolksBackendStore* _tmp0_;
	FolksBackendStore* _tmp1_;
	g_return_val_if_fail (store != NULL, NULL);
	self = (FolksIndividualAggregator*) g_object_new (object_type, NULL);
	_tmp0_ = store;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_backend_store);
	self->priv->_backend_store = _tmp1_;
	return self;
}


FolksIndividualAggregator* folks_individual_aggregator_new_with_backend_store (FolksBackendStore* store) {
	return folks_individual_aggregator_construct_with_backend_store (FOLKS_TYPE_INDIVIDUAL_AGGREGATOR, store);
}


static gint string_index_of (const gchar* self, const gchar* needle, gint start_index) {
	gint result = 0;
	gchar* _result_ = NULL;
	gint _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (needle != NULL, 0);
	_tmp0_ = start_index;
	_tmp1_ = needle;
	_tmp2_ = strstr (((gchar*) self) + _tmp0_, (gchar*) _tmp1_);
	_result_ = _tmp2_;
	_tmp3_ = _result_;
	if (_tmp3_ != NULL) {
		gchar* _tmp4_;
		_tmp4_ = _result_;
		result = (gint) (_tmp4_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}


static void _folks_individual_aggregator_configure_primary_store (FolksIndividualAggregator* self, const gchar* store_config_ids) {
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	gint _tmp2_ = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (store_config_ids != NULL);
	_tmp0_ = store_config_ids;
	g_debug ("individual-aggregator.vala:441: _configure_primary_store to '%s'", _tmp0_);
	self->priv->_user_configured_primary_store = TRUE;
	_tmp1_ = store_config_ids;
	_tmp2_ = string_index_of (_tmp1_, ":", 0);
	if (_tmp2_ != (-1)) {
		gchar** ids = NULL;
		const gchar* _tmp3_;
		gchar** _tmp4_;
		gchar** _tmp5_ = NULL;
		gint ids_length1;
		gint _ids_size_;
		gchar** _tmp6_;
		gint _tmp6__length1;
		const gchar* _tmp7_;
		gchar* _tmp8_;
		gchar** _tmp9_;
		gint _tmp9__length1;
		const gchar* _tmp10_;
		gchar* _tmp11_;
		_tmp3_ = store_config_ids;
		_tmp5_ = _tmp4_ = g_strsplit (_tmp3_, ":", 2);
		ids = _tmp5_;
		ids_length1 = _vala_array_length (_tmp4_);
		_ids_size_ = ids_length1;
		_tmp6_ = ids;
		_tmp6__length1 = ids_length1;
		_tmp7_ = _tmp6_[0];
		_tmp8_ = g_strdup (_tmp7_);
		_g_free0 (self->priv->_configured_primary_store_type_id);
		self->priv->_configured_primary_store_type_id = _tmp8_;
		_tmp9_ = ids;
		_tmp9__length1 = ids_length1;
		_tmp10_ = _tmp9_[1];
		_tmp11_ = g_strdup (_tmp10_);
		_g_free0 (self->priv->_configured_primary_store_id);
		self->priv->_configured_primary_store_id = _tmp11_;
		ids = (_vala_array_free (ids, ids_length1, (GDestroyNotify) g_free), NULL);
	} else {
		const gchar* _tmp12_;
		gchar* _tmp13_;
		gchar* _tmp14_;
		_tmp12_ = store_config_ids;
		_tmp13_ = g_strdup (_tmp12_);
		_g_free0 (self->priv->_configured_primary_store_type_id);
		self->priv->_configured_primary_store_type_id = _tmp13_;
		_tmp14_ = g_strdup ("");
		_g_free0 (self->priv->_configured_primary_store_id);
		self->priv->_configured_primary_store_id = _tmp14_;
	}
}


static gint g_ptr_array_get_length (GPtrArray* self) {
	gint result;
	guint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->len;
	result = (gint) _tmp0_;
	return result;
}


static void g_ptr_array_set_length (GPtrArray* self, gint value) {
	gint _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	g_ptr_array_set_size (self, _tmp0_);
}


static void _folks_individual_aggregator_debug_print_status (FolksIndividualAggregator* self, FolksDebug* debug) {
	static const char domain[] = FOLKS_DEBUG_STATUS_LOG_DOMAIN;
	static const GLogLevelFlags level = G_LOG_LEVEL_INFO;
	FolksDebug* _tmp0_;
	const gchar* _tmp1_ = NULL;
	gboolean _tmp2_;
	const gchar* _tmp3_ = NULL;
	gboolean _tmp4_;
	gchar* _tmp5_ = NULL;
	gboolean _tmp6_;
	FolksDebug* _tmp11_;
	guint _tmp12_;
	gchar* _tmp13_ = NULL;
	gchar* _tmp14_;
	FolksPersonaStore* _tmp15_;
	gchar* _tmp16_ = NULL;
	gchar* _tmp17_;
	const gchar* _tmp18_;
	const gchar* _tmp19_;
	const gchar* _tmp20_;
	const gchar* _tmp21_;
	const gchar* _tmp22_;
	FolksDebug* _tmp23_;
	GeeMap* _tmp24_;
	GeeMap* _tmp25_;
	gint _tmp26_;
	gint _tmp27_;
	FolksDebug* _tmp28_;
	FolksDebug* _tmp98_;
	FolksDebug* _tmp99_;
	GHashTable* _tmp100_;
	guint _tmp101_ = 0U;
	FolksDebug* _tmp102_;
	GHashTableIter iter = {0};
	GHashTable* _tmp103_;
	const gchar* link_key = NULL;
	GPtrArray* individuals = NULL;
	FolksDebug* _tmp124_;
	FolksDebug* _tmp125_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (debug != NULL);
	_tmp0_ = debug;
	folks_debug_print_heading (_tmp0_, domain, level, "IndividualAggregator (%p)", self);
	_tmp2_ = self->priv->_linking_enabled;
	if (_tmp2_) {
		_tmp1_ = "yes";
	} else {
		_tmp1_ = "no";
	}
	_tmp4_ = self->priv->_is_prepared;
	if (_tmp4_) {
		_tmp3_ = "yes";
	} else {
		_tmp3_ = "no";
	}
	_tmp6_ = self->priv->_is_quiescent;
	if (_tmp6_) {
		gchar* _tmp7_;
		_tmp7_ = g_strdup ("yes");
		_g_free0 (_tmp5_);
		_tmp5_ = _tmp7_;
	} else {
		guint _tmp8_;
		guint _tmp9_;
		gchar* _tmp10_ = NULL;
		_tmp8_ = self->priv->_non_quiescent_backend_count;
		_tmp9_ = self->priv->_non_quiescent_persona_store_count;
		_tmp10_ = g_strdup_printf ("no (%u backends, %u persona stores left)", _tmp8_, _tmp9_);
		_g_free0 (_tmp5_);
		_tmp5_ = _tmp10_;
	}
	_tmp11_ = debug;
	_tmp12_ = ((GObject*) self)->ref_count;
	_tmp13_ = g_strdup_printf ("%u", _tmp12_);
	_tmp14_ = _tmp13_;
	_tmp15_ = self->priv->_primary_store;
	_tmp16_ = g_strdup_printf ("%p", _tmp15_);
	_tmp17_ = _tmp16_;
	_tmp18_ = self->priv->_configured_primary_store_type_id;
	_tmp19_ = self->priv->_configured_primary_store_id;
	_tmp20_ = _tmp1_;
	_tmp21_ = _tmp3_;
	_tmp22_ = _tmp5_;
	folks_debug_print_key_value_pairs (_tmp11_, domain, level, "Ref. count", _tmp14_, "Primary store", _tmp17_, "Configured store type id", _tmp18_, "Configured store id", _tmp19_, "Linking enabled?", _tmp20_, "Prepared?", _tmp21_, "Quiescent?", _tmp22_, NULL);
	_g_free0 (_tmp17_);
	_g_free0 (_tmp14_);
	_tmp23_ = debug;
	_tmp24_ = folks_individual_aggregator_get_individuals (self);
	_tmp25_ = _tmp24_;
	_tmp26_ = gee_map_get_size (_tmp25_);
	_tmp27_ = _tmp26_;
	folks_debug_print_line (_tmp23_, domain, level, "%u Individuals:", (guint) _tmp27_);
	_tmp28_ = debug;
	folks_debug_indent (_tmp28_);
	{
		GeeIterator* _individual_it = NULL;
		GeeMap* _tmp29_;
		GeeMap* _tmp30_;
		GeeCollection* _tmp31_;
		GeeCollection* _tmp32_;
		GeeCollection* _tmp33_;
		GeeIterator* _tmp34_ = NULL;
		GeeIterator* _tmp35_;
		_tmp29_ = folks_individual_aggregator_get_individuals (self);
		_tmp30_ = _tmp29_;
		_tmp31_ = gee_map_get_values (_tmp30_);
		_tmp32_ = _tmp31_;
		_tmp33_ = _tmp32_;
		_tmp34_ = gee_iterable_iterator ((GeeIterable*) _tmp33_);
		_tmp35_ = _tmp34_;
		_g_object_unref0 (_tmp33_);
		_individual_it = _tmp35_;
		while (TRUE) {
			GeeIterator* _tmp36_;
			gboolean _tmp37_ = FALSE;
			FolksIndividual* individual = NULL;
			GeeIterator* _tmp38_;
			gpointer _tmp39_ = NULL;
			gchar* trust_level = NULL;
			FolksIndividual* _tmp40_;
			FolksTrustLevel _tmp41_;
			FolksTrustLevel _tmp42_;
			FolksDebug* _tmp45_;
			FolksIndividual* _tmp46_;
			const gchar* _tmp47_ = NULL;
			FolksIndividual* _tmp48_;
			gboolean _tmp49_;
			gboolean _tmp50_;
			FolksDebug* _tmp51_;
			FolksIndividual* _tmp52_;
			guint _tmp53_;
			gchar* _tmp54_ = NULL;
			gchar* _tmp55_;
			FolksIndividual* _tmp56_;
			const gchar* _tmp57_;
			const gchar* _tmp58_;
			const gchar* _tmp59_;
			const gchar* _tmp60_;
			FolksDebug* _tmp61_;
			FolksIndividual* _tmp62_;
			GeeSet* _tmp63_;
			GeeSet* _tmp64_;
			gint _tmp65_;
			gint _tmp66_;
			FolksDebug* _tmp67_;
			FolksDebug* _tmp97_;
			_tmp36_ = _individual_it;
			_tmp37_ = gee_iterator_next (_tmp36_);
			if (!_tmp37_) {
				break;
			}
			_tmp38_ = _individual_it;
			_tmp39_ = gee_iterator_get (_tmp38_);
			individual = (FolksIndividual*) _tmp39_;
			trust_level = NULL;
			_tmp40_ = individual;
			_tmp41_ = folks_individual_get_trust_level (_tmp40_);
			_tmp42_ = _tmp41_;
			switch (_tmp42_) {
				case FOLKS_TRUST_LEVEL_NONE:
				{
					gchar* _tmp43_;
					_tmp43_ = g_strdup ("none");
					_g_free0 (trust_level);
					trust_level = _tmp43_;
					break;
				}
				case FOLKS_TRUST_LEVEL_PERSONAS:
				{
					gchar* _tmp44_;
					_tmp44_ = g_strdup ("personas");
					_g_free0 (trust_level);
					trust_level = _tmp44_;
					break;
				}
				default:
				{
					g_assert_not_reached ();
				}
			}
			_tmp45_ = debug;
			_tmp46_ = individual;
			folks_debug_print_heading (_tmp45_, domain, level, "Individual (%p)", _tmp46_);
			_tmp48_ = individual;
			_tmp49_ = folks_individual_get_is_user (_tmp48_);
			_tmp50_ = _tmp49_;
			if (_tmp50_) {
				_tmp47_ = "yes";
			} else {
				_tmp47_ = "no";
			}
			_tmp51_ = debug;
			_tmp52_ = individual;
			_tmp53_ = ((GObject*) _tmp52_)->ref_count;
			_tmp54_ = g_strdup_printf ("%u", _tmp53_);
			_tmp55_ = _tmp54_;
			_tmp56_ = individual;
			_tmp57_ = folks_individual_get_id (_tmp56_);
			_tmp58_ = _tmp57_;
			_tmp59_ = _tmp47_;
			_tmp60_ = trust_level;
			folks_debug_print_key_value_pairs (_tmp51_, domain, level, "Ref. count", _tmp55_, "ID", _tmp58_, "User?", _tmp59_, "Trust level", _tmp60_, NULL);
			_g_free0 (_tmp55_);
			_tmp61_ = debug;
			_tmp62_ = individual;
			_tmp63_ = folks_individual_get_personas (_tmp62_);
			_tmp64_ = _tmp63_;
			_tmp65_ = gee_collection_get_size ((GeeCollection*) _tmp64_);
			_tmp66_ = _tmp65_;
			folks_debug_print_line (_tmp61_, domain, level, "%u Personas:", (guint) _tmp66_);
			_tmp67_ = debug;
			folks_debug_indent (_tmp67_);
			{
				GeeIterator* _persona_it = NULL;
				FolksIndividual* _tmp68_;
				GeeSet* _tmp69_;
				GeeSet* _tmp70_;
				GeeIterator* _tmp71_ = NULL;
				_tmp68_ = individual;
				_tmp69_ = folks_individual_get_personas (_tmp68_);
				_tmp70_ = _tmp69_;
				_tmp71_ = gee_iterable_iterator ((GeeIterable*) _tmp70_);
				_persona_it = _tmp71_;
				while (TRUE) {
					GeeIterator* _tmp72_;
					gboolean _tmp73_ = FALSE;
					FolksPersona* persona = NULL;
					GeeIterator* _tmp74_;
					gpointer _tmp75_ = NULL;
					FolksDebug* _tmp76_;
					FolksPersona* _tmp77_;
					const gchar* _tmp78_ = NULL;
					FolksPersona* _tmp79_;
					gboolean _tmp80_;
					gboolean _tmp81_;
					FolksDebug* _tmp82_;
					FolksPersona* _tmp83_;
					guint _tmp84_;
					gchar* _tmp85_ = NULL;
					gchar* _tmp86_;
					FolksPersona* _tmp87_;
					const gchar* _tmp88_;
					const gchar* _tmp89_;
					FolksPersona* _tmp90_;
					const gchar* _tmp91_;
					const gchar* _tmp92_;
					FolksPersona* _tmp93_;
					const gchar* _tmp94_;
					const gchar* _tmp95_;
					const gchar* _tmp96_;
					_tmp72_ = _persona_it;
					_tmp73_ = gee_iterator_next (_tmp72_);
					if (!_tmp73_) {
						break;
					}
					_tmp74_ = _persona_it;
					_tmp75_ = gee_iterator_get (_tmp74_);
					persona = (FolksPersona*) _tmp75_;
					_tmp76_ = debug;
					_tmp77_ = persona;
					folks_debug_print_heading (_tmp76_, domain, level, "Persona (%p)", _tmp77_);
					_tmp79_ = persona;
					_tmp80_ = folks_persona_get_is_user (_tmp79_);
					_tmp81_ = _tmp80_;
					if (_tmp81_) {
						_tmp78_ = "yes";
					} else {
						_tmp78_ = "no";
					}
					_tmp82_ = debug;
					_tmp83_ = persona;
					_tmp84_ = ((GObject*) _tmp83_)->ref_count;
					_tmp85_ = g_strdup_printf ("%u", _tmp84_);
					_tmp86_ = _tmp85_;
					_tmp87_ = persona;
					_tmp88_ = folks_persona_get_uid (_tmp87_);
					_tmp89_ = _tmp88_;
					_tmp90_ = persona;
					_tmp91_ = folks_persona_get_iid (_tmp90_);
					_tmp92_ = _tmp91_;
					_tmp93_ = persona;
					_tmp94_ = folks_persona_get_display_id (_tmp93_);
					_tmp95_ = _tmp94_;
					_tmp96_ = _tmp78_;
					folks_debug_print_key_value_pairs (_tmp82_, domain, level, "Ref. count", _tmp86_, "UID", _tmp89_, "IID", _tmp92_, "Display ID", _tmp95_, "User?", _tmp96_, NULL);
					_g_free0 (_tmp86_);
					_g_object_unref0 (persona);
				}
				_g_object_unref0 (_persona_it);
			}
			_tmp97_ = debug;
			folks_debug_unindent (_tmp97_);
			_g_free0 (trust_level);
			_g_object_unref0 (individual);
		}
		_g_object_unref0 (_individual_it);
	}
	_tmp98_ = debug;
	folks_debug_unindent (_tmp98_);
	_tmp99_ = debug;
	_tmp100_ = self->priv->_link_map;
	_tmp101_ = g_hash_table_size (_tmp100_);
	folks_debug_print_line (_tmp99_, domain, level, "%u keys in the link map:", _tmp101_);
	_tmp102_ = debug;
	folks_debug_indent (_tmp102_);
	_tmp103_ = self->priv->_link_map;
	g_hash_table_iter_init (&iter, _tmp103_);
	while (TRUE) {
		gconstpointer _tmp104_ = NULL;
		gconstpointer _tmp105_ = NULL;
		gboolean _tmp106_ = FALSE;
		FolksDebug* _tmp107_;
		const gchar* _tmp108_;
		FolksDebug* _tmp109_;
		FolksDebug* _tmp122_;
		FolksDebug* _tmp123_;
		_tmp106_ = g_hash_table_iter_next (&iter, &_tmp104_, &_tmp105_);
		link_key = _tmp104_;
		individuals = _tmp105_;
		if (!_tmp106_) {
			break;
		}
		_tmp107_ = debug;
		_tmp108_ = link_key;
		folks_debug_print_line (_tmp107_, domain, level, "%s  {", _tmp108_);
		_tmp109_ = debug;
		folks_debug_indent (_tmp109_);
		{
			guint i = 0U;
			i = (guint) 0;
			{
				gboolean _tmp110_ = FALSE;
				_tmp110_ = TRUE;
				while (TRUE) {
					gboolean _tmp111_;
					guint _tmp113_;
					GPtrArray* _tmp114_;
					gint _tmp115_;
					gint _tmp116_;
					FolksIndividual* ind = NULL;
					GPtrArray* _tmp117_;
					guint _tmp118_;
					gconstpointer _tmp119_ = NULL;
					FolksDebug* _tmp120_;
					FolksIndividual* _tmp121_;
					_tmp111_ = _tmp110_;
					if (!_tmp111_) {
						guint _tmp112_;
						_tmp112_ = i;
						i = _tmp112_ + 1;
					}
					_tmp110_ = FALSE;
					_tmp113_ = i;
					_tmp114_ = individuals;
					_tmp115_ = g_ptr_array_get_length (_tmp114_);
					_tmp116_ = _tmp115_;
					if (!(_tmp113_ < ((guint) _tmp116_))) {
						break;
					}
					_tmp117_ = individuals;
					_tmp118_ = i;
					_tmp119_ = g_ptr_array_index (_tmp117_, _tmp118_);
					ind = (FolksIndividual*) _tmp119_;
					_tmp120_ = debug;
					_tmp121_ = ind;
					folks_debug_print_line (_tmp120_, domain, level, "%p", _tmp121_);
				}
			}
		}
		_tmp122_ = debug;
		folks_debug_unindent (_tmp122_);
		_tmp123_ = debug;
		folks_debug_print_line (_tmp123_, domain, level, "}");
	}
	_tmp124_ = debug;
	folks_debug_unindent (_tmp124_);
	_tmp125_ = debug;
	folks_debug_print_line (_tmp125_, domain, level, "");
	_g_free0 (_tmp5_);
}


static void folks_individual_aggregator_prepare_data_free (gpointer _data) {
	FolksIndividualAggregatorPrepareData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (FolksIndividualAggregatorPrepareData, _data_);
}


void folks_individual_aggregator_prepare (FolksIndividualAggregator* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	FolksIndividualAggregatorPrepareData* _data_;
	FolksIndividualAggregator* _tmp0_;
	_data_ = g_slice_new0 (FolksIndividualAggregatorPrepareData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, folks_individual_aggregator_prepare);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, folks_individual_aggregator_prepare_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	folks_individual_aggregator_prepare_co (_data_);
}


void folks_individual_aggregator_prepare_finish (FolksIndividualAggregator* self, GAsyncResult* _res_, GError** error) {
	FolksIndividualAggregatorPrepareData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


/**
   * Prepare the IndividualAggregator for use.
   *
   * This loads all the available backends and prepares them for use by the
   * IndividualAggregator. This should be called //after// connecting to the
   * {@link IndividualAggregator.individuals_changed} signal (or
   * {@link IndividualAggregator.individuals_changed_detailed} signal), or a
   * race condition could occur, with the signal being emitted before your code
   * has connected to them, and {@link Individual}s getting "lost" as a result.
   *
   * This function is guaranteed to be idempotent (since version 0.3.0).
   *
   * Concurrent calls to this function from different threads will block until
   * preparation has completed. However, concurrent calls to this function from
   * a single thread might not, i.e. the first call will block but subsequent
   * calls might return before the first one. (Though they will be safe in every
   * other respect.)
   *
   * @throws GLib.Error if preparing any of the backends failed  this error
   * will be passed through from {@link BackendStore.load_backends}
   *
   * @since 0.1.11
   */
static void folks_individual_aggregator_prepare_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	FolksIndividualAggregatorPrepareData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	folks_individual_aggregator_prepare_co (_data_);
}


static gboolean folks_individual_aggregator_prepare_co (FolksIndividualAggregatorPrepareData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	folks_internal_profiling_start ("preparing IndividualAggregator", NULL);
	_data_->_tmp1_ = _data_->self->priv->_is_prepared;
	if (_data_->_tmp1_) {
		_data_->_tmp0_ = TRUE;
	} else {
		_data_->_tmp2_ = _data_->self->priv->_prepare_pending;
		_data_->_tmp0_ = _data_->_tmp2_;
	}
	_data_->_tmp3_ = _data_->_tmp0_;
	if (_data_->_tmp3_) {
		if (_data_->_state_ == 0) {
			g_simple_async_result_complete_in_idle (_data_->_async_result);
		} else {
			g_simple_async_result_complete (_data_->_async_result);
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	{
		_data_->self->priv->_prepare_pending = TRUE;
		_data_->_tmp4_ = _data_->self->priv->_non_quiescent_backend_count;
		_data_->self->priv->_non_quiescent_backend_count = _data_->_tmp4_ + 1;
		_data_->_tmp5_ = _data_->self->priv->_backend_store;
		g_signal_connect_object (_data_->_tmp5_, "backend-available", (GCallback) __folks_individual_aggregator_backend_available_cb_folks_backend_store_backend_available, _data_->self, 0);
		_data_->_tmp6_ = _data_->self->priv->_backend_store;
		_data_->_tmp7_ = folks_backend_store_get_enabled_backends (_data_->_tmp6_);
		_data_->_tmp8_ = _data_->_tmp7_;
		_data_->_tmp9_ = gee_map_get_values (_data_->_tmp8_);
		_data_->_tmp10_ = _data_->_tmp9_;
		_data_->backends = _data_->_tmp10_;
		{
			_data_->_tmp11_ = _data_->backends;
			_data_->_tmp12_ = NULL;
			_data_->_tmp12_ = gee_iterable_iterator ((GeeIterable*) _data_->_tmp11_);
			_data_->_backend_it = _data_->_tmp12_;
			while (TRUE) {
				_data_->_tmp13_ = _data_->_backend_it;
				_data_->_tmp14_ = FALSE;
				_data_->_tmp14_ = gee_iterator_next (_data_->_tmp13_);
				if (!_data_->_tmp14_) {
					break;
				}
				_data_->_tmp15_ = _data_->_backend_it;
				_data_->_tmp16_ = NULL;
				_data_->_tmp16_ = gee_iterator_get (_data_->_tmp15_);
				_data_->backend = (FolksBackend*) _data_->_tmp16_;
				_data_->_tmp17_ = _data_->self->priv->_backend_store;
				_data_->_tmp18_ = _data_->backend;
				_folks_individual_aggregator_backend_available_cb (_data_->self, _data_->_tmp17_, _data_->_tmp18_);
				_g_object_unref0 (_data_->backend);
			}
			_g_object_unref0 (_data_->_backend_it);
		}
		_data_->_tmp19_ = _data_->self->priv->_backend_store;
		_data_->_state_ = 1;
		folks_backend_store_load_backends (_data_->_tmp19_, folks_individual_aggregator_prepare_ready, _data_);
		return FALSE;
		_state_1:
		folks_backend_store_load_backends_finish (_data_->_tmp19_, _data_->_res_, &_data_->_inner_error_);
		if (_data_->_inner_error_ != NULL) {
			_g_object_unref0 (_data_->backends);
			goto __finally14;
		}
		_data_->_tmp20_ = _data_->self->priv->_non_quiescent_backend_count;
		_data_->self->priv->_non_quiescent_backend_count = _data_->_tmp20_ - 1;
		_data_->self->priv->_is_prepared = TRUE;
		_data_->self->priv->_prepare_pending = FALSE;
		g_object_notify ((GObject*) _data_->self, "is-prepared");
		_data_->_tmp21_ = _data_->self->priv->_is_quiescent;
		if (_data_->_tmp21_ == FALSE) {
			_folks_individual_aggregator_notify_if_is_quiescent (_data_->self);
		}
		_g_object_unref0 (_data_->backends);
	}
	__finally14:
	{
		_data_->self->priv->_prepare_pending = FALSE;
	}
	if (_data_->_inner_error_ != NULL) {
		g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
		g_error_free (_data_->_inner_error_);
		if (_data_->_state_ == 0) {
			g_simple_async_result_complete_in_idle (_data_->_async_result);
		} else {
			g_simple_async_result_complete (_data_->_async_result);
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	folks_internal_profiling_end ("preparing IndividualAggregator", NULL);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void folks_individual_aggregator_unprepare_data_free (gpointer _data) {
	FolksIndividualAggregatorUnprepareData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (FolksIndividualAggregatorUnprepareData, _data_);
}


void folks_individual_aggregator_unprepare (FolksIndividualAggregator* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	FolksIndividualAggregatorUnprepareData* _data_;
	FolksIndividualAggregator* _tmp0_;
	_data_ = g_slice_new0 (FolksIndividualAggregatorUnprepareData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, folks_individual_aggregator_unprepare);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, folks_individual_aggregator_unprepare_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	folks_individual_aggregator_unprepare_co (_data_);
}


void folks_individual_aggregator_unprepare_finish (FolksIndividualAggregator* self, GAsyncResult* _res_, GError** error) {
	FolksIndividualAggregatorUnprepareData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


/**
   * Clean up and release resources used by the aggregator.
   *
   * This will disconnect the aggregator cleanly from any resources it or its
   * persona stores are using. It is recommended to call this method before
   * finalising the individual aggregator, but calling it is not required. If
   * this method is not called then, for example, unsaved changes in backends
   * may not be flushed.
   *
   * Concurrent calls to this function from different threads will block until
   * preparation has completed. However, concurrent calls to this function from
   * a single thread might not, i.e. the first call will block but subsequent
   * calls might return before the first one. (Though they will be safe in every
   * other respect.)
   *
   * @since 0.7.3
   * @throws GLib.Error if unpreparing the backend-specific services failed 
   * this will be a backend-specific error
   */
static void folks_individual_aggregator_unprepare_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	FolksIndividualAggregatorUnprepareData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	folks_individual_aggregator_unprepare_co (_data_);
}


static gboolean folks_individual_aggregator_unprepare_co (FolksIndividualAggregatorUnprepareData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	{
		_data_->_tmp0_ = _data_->self->priv->_is_prepared;
		g_static_rec_mutex_lock (&_data_->self->priv->__lock__is_prepared);
		{
			_data_->_tmp2_ = _data_->self->priv->_is_prepared;
			if (!_data_->_tmp2_) {
				_data_->_tmp1_ = TRUE;
			} else {
				_data_->_tmp3_ = _data_->self->priv->_prepare_pending;
				_data_->_tmp1_ = _data_->_tmp3_;
			}
			_data_->_tmp4_ = _data_->_tmp1_;
			if (_data_->_tmp4_) {
				{
					_data_->_tmp5_ = _data_->self->priv->_is_prepared;
					g_static_rec_mutex_unlock (&_data_->self->priv->__lock__is_prepared);
				}
				if (_data_->_state_ == 0) {
					g_simple_async_result_complete_in_idle (_data_->_async_result);
				} else {
					g_simple_async_result_complete (_data_->_async_result);
				}
				g_object_unref (_data_->_async_result);
				return FALSE;
			}
			{
				{
					_data_->_tmp6_ = _data_->self->priv->_stores;
					_data_->_tmp7_ = gee_abstract_map_get_values ((GeeMap*) _data_->_tmp6_);
					_data_->_tmp8_ = _data_->_tmp7_;
					_data_->_tmp9_ = _data_->_tmp8_;
					_data_->_tmp10_ = NULL;
					_data_->_tmp10_ = gee_iterable_iterator ((GeeIterable*) _data_->_tmp9_);
					_data_->_tmp11_ = _data_->_tmp10_;
					_g_object_unref0 (_data_->_tmp9_);
					_data_->_p_it = _data_->_tmp11_;
					while (TRUE) {
						_data_->_tmp12_ = _data_->_p_it;
						_data_->_tmp13_ = FALSE;
						_data_->_tmp13_ = gee_iterator_next (_data_->_tmp12_);
						if (!_data_->_tmp13_) {
							break;
						}
						_data_->_tmp14_ = _data_->_p_it;
						_data_->_tmp15_ = NULL;
						_data_->_tmp15_ = gee_iterator_get (_data_->_tmp14_);
						_data_->p = (FolksPersonaStore*) _data_->_tmp15_;
						_data_->_tmp16_ = _data_->p;
						_data_->_state_ = 1;
						folks_persona_store_flush (_data_->_tmp16_, folks_individual_aggregator_unprepare_ready, _data_);
						return FALSE;
						_state_1:
						folks_persona_store_flush_finish (_data_->_tmp16_, _data_->_res_);
						_g_object_unref0 (_data_->p);
					}
					_g_object_unref0 (_data_->_p_it);
				}
			}
			__finally16:
			{
				_data_->self->priv->_prepare_pending = FALSE;
			}
			if (_data_->_inner_error_ != NULL) {
				{
					_data_->_tmp17_ = _data_->self->priv->_is_prepared;
					g_static_rec_mutex_unlock (&_data_->self->priv->__lock__is_prepared);
				}
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
				g_clear_error (&_data_->_inner_error_);
				return FALSE;
			}
		}
		__finally15:
		{
			_data_->_tmp18_ = _data_->self->priv->_is_prepared;
			g_static_rec_mutex_unlock (&_data_->self->priv->__lock__is_prepared);
		}
		if (_data_->_inner_error_ != NULL) {
			g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
			g_error_free (_data_->_inner_error_);
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		}
	}
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


/**
   * Get all matches for a given {@link Individual}.
   *
   * @param matchee the individual to find matches for
   * @param min_threshold the threshold for accepting a match
   * @return a map from matched individuals to the degree with which they match
   * ``matchee`` (which is guaranteed to at least equal ``min_threshold``);
   * if no matches could be found, an empty map is returned
   *
   * @since 0.5.1
   */
GeeMap* folks_individual_aggregator_get_potential_matches (FolksIndividualAggregator* self, FolksIndividual* matchee, FolksMatchResult min_threshold) {
	GeeMap* result = NULL;
	GeeHashMap* matches = NULL;
	GeeHashMap* _tmp0_;
	FolksPotentialMatch* matchObj = NULL;
	FolksPotentialMatch* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (matchee != NULL, NULL);
	_tmp0_ = gee_hash_map_new (FOLKS_TYPE_INDIVIDUAL, (GBoxedCopyFunc) g_object_ref, g_object_unref, FOLKS_TYPE_MATCH_RESULT, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	matches = _tmp0_;
	_tmp1_ = folks_potential_match_new ();
	matchObj = _tmp1_;
	{
		GeeIterator* _i_it = NULL;
		GeeMap* _tmp2_;
		GeeCollection* _tmp3_;
		GeeCollection* _tmp4_;
		GeeCollection* _tmp5_;
		GeeIterator* _tmp6_ = NULL;
		GeeIterator* _tmp7_;
		_tmp2_ = self->priv->_individuals;
		_tmp3_ = gee_map_get_values (_tmp2_);
		_tmp4_ = _tmp3_;
		_tmp5_ = _tmp4_;
		_tmp6_ = gee_iterable_iterator ((GeeIterable*) _tmp5_);
		_tmp7_ = _tmp6_;
		_g_object_unref0 (_tmp5_);
		_i_it = _tmp7_;
		while (TRUE) {
			GeeIterator* _tmp8_;
			gboolean _tmp9_ = FALSE;
			FolksIndividual* i = NULL;
			GeeIterator* _tmp10_;
			gpointer _tmp11_ = NULL;
			FolksIndividual* _tmp12_;
			const gchar* _tmp13_;
			const gchar* _tmp14_;
			FolksIndividual* _tmp15_;
			const gchar* _tmp16_;
			const gchar* _tmp17_;
			FolksMatchResult _result_ = 0;
			FolksPotentialMatch* _tmp18_;
			FolksIndividual* _tmp19_;
			FolksIndividual* _tmp20_;
			FolksMatchResult _tmp21_ = 0;
			FolksMatchResult _tmp22_;
			FolksMatchResult _tmp23_;
			_tmp8_ = _i_it;
			_tmp9_ = gee_iterator_next (_tmp8_);
			if (!_tmp9_) {
				break;
			}
			_tmp10_ = _i_it;
			_tmp11_ = gee_iterator_get (_tmp10_);
			i = (FolksIndividual*) _tmp11_;
			_tmp12_ = i;
			_tmp13_ = folks_individual_get_id (_tmp12_);
			_tmp14_ = _tmp13_;
			_tmp15_ = matchee;
			_tmp16_ = folks_individual_get_id (_tmp15_);
			_tmp17_ = _tmp16_;
			if (g_strcmp0 (_tmp14_, _tmp17_) == 0) {
				_g_object_unref0 (i);
				continue;
			}
			_tmp18_ = matchObj;
			_tmp19_ = i;
			_tmp20_ = matchee;
			_tmp21_ = folks_potential_match_potential_match (_tmp18_, _tmp19_, _tmp20_);
			_result_ = _tmp21_;
			_tmp22_ = _result_;
			_tmp23_ = min_threshold;
			if (_tmp22_ >= _tmp23_) {
				GeeHashMap* _tmp24_;
				FolksIndividual* _tmp25_;
				FolksMatchResult _tmp26_;
				_tmp24_ = matches;
				_tmp25_ = i;
				_tmp26_ = _result_;
				gee_abstract_map_set ((GeeAbstractMap*) _tmp24_, _tmp25_, (gpointer) ((gintptr) _tmp26_));
			}
			_g_object_unref0 (i);
		}
		_g_object_unref0 (_i_it);
	}
	result = (GeeMap*) matches;
	_g_object_unref0 (matchObj);
	return result;
}


/**
   * Get all combinations between all {@link Individual}s.
   *
   * @param min_threshold the threshold for accepting a match
   * @return a map from each individual in the aggregator to a map of the
   * other individuals in the aggregator which can be matched with that
   * individual, mapped to the degree with which they match the original
   * individual (which is guaranteed to at least equal ``min_threshold``)
   *
   * @since 0.5.1
   */
GeeMap* folks_individual_aggregator_get_all_potential_matches (FolksIndividualAggregator* self, FolksMatchResult min_threshold) {
	GeeMap* result = NULL;
	GeeHashMap* matches = NULL;
	GeeHashMap* _tmp0_;
	FolksIndividual** individuals = NULL;
	GeeMap* _tmp1_;
	GeeCollection* _tmp2_;
	GeeCollection* _tmp3_;
	GeeCollection* _tmp4_;
	gint _tmp5_ = 0;
	gpointer* _tmp6_ = NULL;
	FolksIndividual** _tmp7_;
	gint _tmp7__length1;
	gint individuals_length1;
	gint _individuals_size_;
	FolksPotentialMatch* matchObj = NULL;
	FolksPotentialMatch* _tmp8_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = gee_hash_map_new (FOLKS_TYPE_INDIVIDUAL, (GBoxedCopyFunc) g_object_ref, g_object_unref, GEE_TYPE_HASH_MAP, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	matches = _tmp0_;
	_tmp1_ = self->priv->_individuals;
	_tmp2_ = gee_map_get_values (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = _tmp3_;
	_tmp6_ = gee_collection_to_array (_tmp4_, &_tmp5_);
	_tmp7_ = _tmp6_;
	_tmp7__length1 = _tmp5_;
	_g_object_unref0 (_tmp4_);
	individuals = _tmp7_;
	individuals_length1 = _tmp7__length1;
	_individuals_size_ = individuals_length1;
	_tmp8_ = folks_potential_match_new ();
	matchObj = _tmp8_;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp9_ = FALSE;
			_tmp9_ = TRUE;
			while (TRUE) {
				gboolean _tmp10_;
				gint _tmp12_;
				FolksIndividual** _tmp13_;
				gint _tmp13__length1;
				FolksIndividual* a = NULL;
				FolksIndividual** _tmp14_;
				gint _tmp14__length1;
				gint _tmp15_;
				FolksIndividual* _tmp16_;
				FolksIndividual* _tmp17_;
				GeeHashMap* _matches_a = NULL;
				GeeHashMap* _tmp18_;
				FolksIndividual* _tmp19_;
				gpointer _tmp20_ = NULL;
				GeeHashMap* matches_a = NULL;
				GeeHashMap* _tmp21_;
				_tmp10_ = _tmp9_;
				if (!_tmp10_) {
					gint _tmp11_;
					_tmp11_ = i;
					i = _tmp11_ + 1;
				}
				_tmp9_ = FALSE;
				_tmp12_ = i;
				_tmp13_ = individuals;
				_tmp13__length1 = individuals_length1;
				if (!(_tmp12_ < _tmp13__length1)) {
					break;
				}
				_tmp14_ = individuals;
				_tmp14__length1 = individuals_length1;
				_tmp15_ = i;
				_tmp16_ = _tmp14_[_tmp15_];
				_tmp17_ = _g_object_ref0 (_tmp16_);
				a = _tmp17_;
				_tmp18_ = matches;
				_tmp19_ = a;
				_tmp20_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp18_, _tmp19_);
				_matches_a = (GeeHashMap*) _tmp20_;
				_tmp21_ = _matches_a;
				if (_tmp21_ == NULL) {
					GeeHashMap* _tmp22_;
					GeeHashMap* _tmp23_;
					FolksIndividual* _tmp24_;
					GeeHashMap* _tmp25_;
					_tmp22_ = gee_hash_map_new (FOLKS_TYPE_INDIVIDUAL, (GBoxedCopyFunc) g_object_ref, g_object_unref, FOLKS_TYPE_MATCH_RESULT, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
					_g_object_unref0 (matches_a);
					matches_a = _tmp22_;
					_tmp23_ = matches;
					_tmp24_ = a;
					_tmp25_ = matches_a;
					gee_abstract_map_set ((GeeAbstractMap*) _tmp23_, _tmp24_, _tmp25_);
				} else {
					GeeHashMap* _tmp26_;
					GeeHashMap* _tmp27_;
					_tmp26_ = _matches_a;
					_tmp27_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp26_, GEE_TYPE_HASH_MAP, GeeHashMap));
					_g_object_unref0 (matches_a);
					matches_a = _tmp27_;
				}
				{
					gint f = 0;
					gint _tmp28_;
					_tmp28_ = i;
					f = _tmp28_ + 1;
					{
						gboolean _tmp29_ = FALSE;
						_tmp29_ = TRUE;
						while (TRUE) {
							gboolean _tmp30_;
							gint _tmp32_;
							FolksIndividual** _tmp33_;
							gint _tmp33__length1;
							FolksIndividual* b = NULL;
							FolksIndividual** _tmp34_;
							gint _tmp34__length1;
							gint _tmp35_;
							FolksIndividual* _tmp36_;
							FolksIndividual* _tmp37_;
							GeeHashMap* _matches_b = NULL;
							GeeHashMap* _tmp38_;
							FolksIndividual* _tmp39_;
							gpointer _tmp40_ = NULL;
							GeeHashMap* matches_b = NULL;
							GeeHashMap* _tmp41_;
							FolksMatchResult _result_ = 0;
							FolksPotentialMatch* _tmp48_;
							FolksIndividual* _tmp49_;
							FolksIndividual* _tmp50_;
							FolksMatchResult _tmp51_ = 0;
							FolksMatchResult _tmp52_;
							FolksMatchResult _tmp53_;
							_tmp30_ = _tmp29_;
							if (!_tmp30_) {
								gint _tmp31_;
								_tmp31_ = f;
								f = _tmp31_ + 1;
							}
							_tmp29_ = FALSE;
							_tmp32_ = f;
							_tmp33_ = individuals;
							_tmp33__length1 = individuals_length1;
							if (!(_tmp32_ < _tmp33__length1)) {
								break;
							}
							_tmp34_ = individuals;
							_tmp34__length1 = individuals_length1;
							_tmp35_ = f;
							_tmp36_ = _tmp34_[_tmp35_];
							_tmp37_ = _g_object_ref0 (_tmp36_);
							b = _tmp37_;
							_tmp38_ = matches;
							_tmp39_ = b;
							_tmp40_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp38_, _tmp39_);
							_matches_b = (GeeHashMap*) _tmp40_;
							_tmp41_ = _matches_b;
							if (_tmp41_ == NULL) {
								GeeHashMap* _tmp42_;
								GeeHashMap* _tmp43_;
								FolksIndividual* _tmp44_;
								GeeHashMap* _tmp45_;
								_tmp42_ = gee_hash_map_new (FOLKS_TYPE_INDIVIDUAL, (GBoxedCopyFunc) g_object_ref, g_object_unref, FOLKS_TYPE_MATCH_RESULT, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
								_g_object_unref0 (matches_b);
								matches_b = _tmp42_;
								_tmp43_ = matches;
								_tmp44_ = b;
								_tmp45_ = matches_b;
								gee_abstract_map_set ((GeeAbstractMap*) _tmp43_, _tmp44_, _tmp45_);
							} else {
								GeeHashMap* _tmp46_;
								GeeHashMap* _tmp47_;
								_tmp46_ = _matches_b;
								_tmp47_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp46_, GEE_TYPE_HASH_MAP, GeeHashMap));
								_g_object_unref0 (matches_b);
								matches_b = _tmp47_;
							}
							_tmp48_ = matchObj;
							_tmp49_ = a;
							_tmp50_ = b;
							_tmp51_ = folks_potential_match_potential_match (_tmp48_, _tmp49_, _tmp50_);
							_result_ = _tmp51_;
							_tmp52_ = _result_;
							_tmp53_ = min_threshold;
							if (_tmp52_ >= _tmp53_) {
								GeeHashMap* _tmp54_;
								FolksIndividual* _tmp55_;
								FolksMatchResult _tmp56_;
								GeeHashMap* _tmp57_;
								FolksIndividual* _tmp58_;
								FolksMatchResult _tmp59_;
								_tmp54_ = matches_a;
								_tmp55_ = b;
								_tmp56_ = _result_;
								gee_abstract_map_set ((GeeAbstractMap*) _tmp54_, _tmp55_, (gpointer) ((gintptr) _tmp56_));
								_tmp57_ = matches_b;
								_tmp58_ = a;
								_tmp59_ = _result_;
								gee_abstract_map_set ((GeeAbstractMap*) _tmp57_, _tmp58_, (gpointer) ((gintptr) _tmp59_));
							}
							_g_object_unref0 (matches_b);
							_g_object_unref0 (_matches_b);
							_g_object_unref0 (b);
						}
					}
				}
				_g_object_unref0 (matches_a);
				_g_object_unref0 (_matches_a);
				_g_object_unref0 (a);
			}
		}
	}
	result = (GeeMap*) matches;
	_g_object_unref0 (matchObj);
	individuals = (_vala_array_free (individuals, individuals_length1, (GDestroyNotify) g_object_unref), NULL);
	return result;
}


static void _folks_individual_aggregator_add_backend_data_free (gpointer _data) {
	FolksIndividualAggregatorAddBackendData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->backend);
	_g_object_unref0 (_data_->self);
	g_slice_free (FolksIndividualAggregatorAddBackendData, _data_);
}


static void _folks_individual_aggregator_add_backend (FolksIndividualAggregator* self, FolksBackend* backend, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	FolksIndividualAggregatorAddBackendData* _data_;
	FolksIndividualAggregator* _tmp0_;
	FolksBackend* _tmp1_;
	FolksBackend* _tmp2_;
	_data_ = g_slice_new0 (FolksIndividualAggregatorAddBackendData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, _folks_individual_aggregator_add_backend);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, _folks_individual_aggregator_add_backend_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = backend;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	_g_object_unref0 (_data_->backend);
	_data_->backend = _tmp2_;
	_folks_individual_aggregator_add_backend_co (_data_);
}


static void _folks_individual_aggregator_add_backend_finish (FolksIndividualAggregator* self, GAsyncResult* _res_) {
	FolksIndividualAggregatorAddBackendData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void __folks_individual_aggregator_backend_persona_store_added_cb_folks_backend_persona_store_added (FolksBackend* _sender, FolksPersonaStore* store, gpointer self) {
	_folks_individual_aggregator_backend_persona_store_added_cb (self, _sender, store);
}


static void __folks_individual_aggregator_backend_persona_store_removed_cb_folks_backend_persona_store_removed (FolksBackend* _sender, FolksPersonaStore* store, gpointer self) {
	_folks_individual_aggregator_backend_persona_store_removed_cb (self, _sender, store);
}


static void __folks_individual_aggregator_backend_is_quiescent_changed_cb_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	_folks_individual_aggregator_backend_is_quiescent_changed_cb (self, _sender, pspec);
}


static gboolean _folks_individual_aggregator_add_backend_co (FolksIndividualAggregatorAddBackendData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = _data_->self->priv->_backends;
	_data_->_tmp1_ = _data_->backend;
	_data_->_tmp2_ = FALSE;
	_data_->_tmp2_ = gee_abstract_collection_contains ((GeeAbstractCollection*) _data_->_tmp0_, _data_->_tmp1_);
	if (!_data_->_tmp2_) {
		_data_->_tmp3_ = _data_->self->priv->_backends;
		_data_->_tmp4_ = _data_->backend;
		gee_abstract_collection_add ((GeeAbstractCollection*) _data_->_tmp3_, _data_->_tmp4_);
		_data_->_tmp5_ = _data_->backend;
		g_signal_connect_object (_data_->_tmp5_, "persona-store-added", (GCallback) __folks_individual_aggregator_backend_persona_store_added_cb_folks_backend_persona_store_added, _data_->self, 0);
		_data_->_tmp6_ = _data_->backend;
		g_signal_connect_object (_data_->_tmp6_, "persona-store-removed", (GCallback) __folks_individual_aggregator_backend_persona_store_removed_cb_folks_backend_persona_store_removed, _data_->self, 0);
		_data_->_tmp7_ = _data_->backend;
		g_signal_connect_object ((GObject*) _data_->_tmp7_, "notify::is-quiescent", (GCallback) __folks_individual_aggregator_backend_is_quiescent_changed_cb_g_object_notify, _data_->self, 0);
		_data_->_tmp8_ = _data_->backend;
		_data_->_tmp9_ = folks_backend_get_persona_stores (_data_->_tmp8_);
		_data_->_tmp10_ = _data_->_tmp9_;
		_data_->_tmp11_ = gee_map_get_values (_data_->_tmp10_);
		_data_->_tmp12_ = _data_->_tmp11_;
		_data_->_tmp13_ = _data_->_tmp12_;
		_data_->_tmp14_ = 0;
		_data_->_tmp15_ = NULL;
		_data_->_tmp15_ = gee_collection_to_array (_data_->_tmp13_, &_data_->_tmp14_);
		_data_->_tmp16_ = _data_->_tmp15_;
		_data_->_tmp16__length1 = _data_->_tmp14_;
		_g_object_unref0 (_data_->_tmp13_);
		_data_->stores = _data_->_tmp16_;
		_data_->stores_length1 = _data_->_tmp16__length1;
		_data_->_stores_size_ = _data_->stores_length1;
		_data_->_tmp17_ = _data_->stores;
		_data_->_tmp17__length1 = _data_->stores_length1;
		{
			_data_->persona_store_collection_length1 = 0;
			_data_->_persona_store_collection_size_ = 0;
			_data_->persona_store_collection = _data_->_tmp17_;
			_data_->persona_store_collection_length1 = _data_->_tmp17__length1;
			for (_data_->persona_store_it = 0; _data_->persona_store_it < _data_->_tmp17__length1; _data_->persona_store_it = _data_->persona_store_it + 1) {
				_data_->_tmp18_ = _g_object_ref0 (_data_->persona_store_collection[_data_->persona_store_it]);
				_data_->persona_store = _data_->_tmp18_;
				{
					_data_->_tmp19_ = _data_->backend;
					_data_->_tmp20_ = _data_->persona_store;
					_folks_individual_aggregator_backend_persona_store_added_cb (_data_->self, _data_->_tmp19_, _data_->_tmp20_);
					_g_object_unref0 (_data_->persona_store);
				}
			}
		}
		_data_->stores = (_vala_array_free (_data_->stores, _data_->stores_length1, (GDestroyNotify) g_object_unref), NULL);
	}
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static gboolean __folks_individual_aggregator_quiescent_timeout_cb_gsource_func (gpointer self) {
	gboolean result;
	result = _folks_individual_aggregator_quiescent_timeout_cb (self);
	return result;
}


static void _folks_individual_aggregator_backend_available_cb (FolksIndividualAggregator* self, FolksBackendStore* backend_store, FolksBackend* backend) {
	FolksBackend* _tmp0_;
	gboolean _tmp1_;
	gboolean _tmp2_;
	FolksBackend* _tmp6_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (backend_store != NULL);
	g_return_if_fail (backend != NULL);
	_tmp0_ = backend;
	_tmp1_ = folks_backend_get_is_quiescent (_tmp0_);
	_tmp2_ = _tmp1_;
	if (_tmp2_ == FALSE) {
		guint _tmp3_;
		guint _tmp4_;
		_tmp3_ = self->priv->_non_quiescent_backend_count;
		self->priv->_non_quiescent_backend_count = _tmp3_ + 1;
		_tmp4_ = self->priv->_quiescent_timeout_id;
		if (_tmp4_ == ((guint) 0)) {
			guint _tmp5_ = 0U;
			_tmp5_ = g_timeout_add_seconds_full (G_PRIORITY_DEFAULT, FOLKS_INDIVIDUAL_AGGREGATOR__QUIESCENT_TIMEOUT, __folks_individual_aggregator_quiescent_timeout_cb_gsource_func, g_object_ref (self), g_object_unref);
			self->priv->_quiescent_timeout_id = _tmp5_;
		}
	}
	_tmp6_ = backend;
	_folks_individual_aggregator_add_backend (self, _tmp6_, NULL, NULL);
}


static void _folks_individual_aggregator_set_primary_store (FolksIndividualAggregator* self, FolksPersonaStore* store) {
	FolksPersonaStore* _tmp0_;
	FolksPersonaStore* _tmp1_;
	FolksPersonaStore* _tmp2_;
	const gchar* _tmp3_;
	const gchar* _tmp4_;
	const gchar* _tmp5_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (store != NULL);
	g_debug ("individual-aggregator.vala:832: _set_primary_store()");
	_tmp0_ = self->priv->_primary_store;
	_tmp1_ = store;
	if (_tmp0_ == _tmp1_) {
		return;
	}
	_tmp2_ = store;
	_tmp3_ = folks_persona_store_get_type_id (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = self->priv->_configured_primary_store_type_id;
	if (g_strcmp0 (_tmp4_, _tmp5_) == 0) {
		gboolean _tmp6_ = FALSE;
		gboolean _tmp7_ = FALSE;
		FolksPersonaStore* _tmp8_;
		const gchar* _tmp9_;
		const gchar* _tmp10_;
		gboolean _tmp12_;
		gboolean _tmp17_;
		_tmp8_ = store;
		_tmp9_ = folks_persona_store_get_type_id (_tmp8_);
		_tmp10_ = _tmp9_;
		if (g_strcmp0 (_tmp10_, "eds") != 0) {
			const gchar* _tmp11_;
			_tmp11_ = self->priv->_configured_primary_store_id;
			_tmp7_ = g_strcmp0 (_tmp11_, "") == 0;
		} else {
			_tmp7_ = FALSE;
		}
		_tmp12_ = _tmp7_;
		if (_tmp12_) {
			_tmp6_ = TRUE;
		} else {
			const gchar* _tmp13_;
			FolksPersonaStore* _tmp14_;
			const gchar* _tmp15_;
			const gchar* _tmp16_;
			_tmp13_ = self->priv->_configured_primary_store_id;
			_tmp14_ = store;
			_tmp15_ = folks_persona_store_get_id (_tmp14_);
			_tmp16_ = _tmp15_;
			_tmp6_ = g_strcmp0 (_tmp13_, _tmp16_) == 0;
		}
		_tmp17_ = _tmp6_;
		if (_tmp17_) {
			FolksPersonaStore* _tmp18_;
			FolksPersonaStore* _tmp19_;
			const gchar* _tmp20_;
			const gchar* _tmp21_;
			FolksPersonaStore* _tmp22_;
			const gchar* _tmp23_;
			const gchar* _tmp24_;
			FolksPersonaStore* previous_store = NULL;
			FolksPersonaStore* _tmp25_;
			FolksPersonaStore* _tmp26_;
			FolksPersonaStore* _tmp27_;
			FolksPersonaStore* _tmp28_;
			FolksPersonaStore* _tmp29_;
			FolksPersonaStore* _tmp32_;
			FolksPersonaStore* _tmp33_;
			FolksPersonaStore* _tmp35_;
			_tmp18_ = store;
			_tmp19_ = store;
			_tmp20_ = folks_persona_store_get_type_id (_tmp19_);
			_tmp21_ = _tmp20_;
			_tmp22_ = store;
			_tmp23_ = folks_persona_store_get_id (_tmp22_);
			_tmp24_ = _tmp23_;
			g_debug ("individual-aggregator.vala:849: Setting primary store to %p (type ID: " \
"%s, ID: %s)", _tmp18_, _tmp21_, _tmp24_);
			_tmp25_ = self->priv->_primary_store;
			_tmp26_ = _g_object_ref0 (_tmp25_);
			previous_store = _tmp26_;
			_tmp27_ = store;
			self->priv->_primary_store = _tmp27_;
			_tmp28_ = store;
			g_object_freeze_notify ((GObject*) _tmp28_);
			_tmp29_ = previous_store;
			if (_tmp29_ != NULL) {
				FolksPersonaStore* _tmp30_;
				FolksPersonaStore* _tmp31_;
				_tmp30_ = previous_store;
				g_object_freeze_notify ((GObject*) G_TYPE_CHECK_INSTANCE_CAST (_tmp30_, FOLKS_TYPE_PERSONA_STORE, FolksPersonaStore));
				_tmp31_ = previous_store;
				folks_persona_store_set_is_primary_store (G_TYPE_CHECK_INSTANCE_CAST (_tmp31_, FOLKS_TYPE_PERSONA_STORE, FolksPersonaStore), FALSE);
			}
			_tmp32_ = store;
			folks_persona_store_set_is_primary_store (_tmp32_, TRUE);
			_tmp33_ = previous_store;
			if (_tmp33_ != NULL) {
				FolksPersonaStore* _tmp34_;
				_tmp34_ = previous_store;
				g_object_thaw_notify ((GObject*) G_TYPE_CHECK_INSTANCE_CAST (_tmp34_, FOLKS_TYPE_PERSONA_STORE, FolksPersonaStore));
			}
			_tmp35_ = store;
			g_object_thaw_notify ((GObject*) _tmp35_);
			g_object_notify ((GObject*) self, "primary-store");
			_g_object_unref0 (previous_store);
		}
	}
}


static Block4Data* block4_data_ref (Block4Data* _data4_) {
	g_atomic_int_inc (&_data4_->_ref_count_);
	return _data4_;
}


static void block4_data_unref (void * _userdata_) {
	Block4Data* _data4_;
	_data4_ = (Block4Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data4_->_ref_count_)) {
		FolksIndividualAggregator * self;
		self = _data4_->self;
		_g_free0 (_data4_->store_id);
		_g_object_unref0 (_data4_->store);
		_g_object_unref0 (self);
		g_slice_free (Block4Data, _data4_);
	}
}


static void __folks_individual_aggregator_personas_changed_cb_folks_persona_store_personas_changed (FolksPersonaStore* _sender, GeeSet* added, GeeSet* removed, const gchar* message, FolksPersona* actor, FolksGroupDetailsChangeReason reason, gpointer self) {
	_folks_individual_aggregator_personas_changed_cb (self, _sender, added, removed, message, actor, reason);
}


static void __folks_individual_aggregator_is_primary_store_changed_cb_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	_folks_individual_aggregator_is_primary_store_changed_cb (self, _sender, pspec);
}


static void __folks_individual_aggregator_persona_store_is_quiescent_changed_cb_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	_folks_individual_aggregator_persona_store_is_quiescent_changed_cb (self, _sender, pspec);
}


static void __folks_individual_aggregator_persona_store_is_user_set_default_changed_cb_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	_folks_individual_aggregator_persona_store_is_user_set_default_changed_cb (self, _sender, pspec);
}


static void __lambda67_ (Block4Data* _data4_, GObject* obj, GAsyncResult* _result_) {
	FolksIndividualAggregator * self;
	GError * _inner_error_ = NULL;
	self = _data4_->self;
	g_return_if_fail (_result_ != NULL);
	{
		FolksPersonaStore* _tmp0_;
		GAsyncResult* _tmp1_;
		_tmp0_ = _data4_->store;
		_tmp1_ = _result_;
		folks_persona_store_prepare_finish (_tmp0_, _tmp1_, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch17_g_error;
		}
	}
	goto __finally17;
	__catch17_g_error:
	{
		GError* e = NULL;
		const gchar* _tmp2_ = NULL;
		const gchar* _tmp3_;
		GError* _tmp4_;
		const gchar* _tmp5_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp2_ = _ ("Error preparing persona store '%s': %s");
		_tmp3_ = _data4_->store_id;
		_tmp4_ = e;
		_tmp5_ = _tmp4_->message;
		g_warning (_tmp2_, _tmp3_, _tmp5_);
		_g_error_free0 (e);
	}
	__finally17:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void ___lambda67__gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self) {
	__lambda67_ (self, source_object, res);
	block4_data_unref (self);
}


static void _folks_individual_aggregator_backend_persona_store_added_cb (FolksIndividualAggregator* self, FolksBackend* backend, FolksPersonaStore* store) {
	Block4Data* _data4_;
	FolksPersonaStore* _tmp0_;
	FolksPersonaStore* _tmp1_;
	FolksBackend* _tmp2_;
	const gchar* _tmp3_;
	const gchar* _tmp4_;
	FolksPersonaStore* _tmp5_;
	const gchar* _tmp6_;
	const gchar* _tmp7_;
	FolksPersonaStore* _tmp8_;
	FolksPersonaStore* _tmp9_;
	const gchar* _tmp10_;
	const gchar* _tmp11_;
	FolksPersonaStore* _tmp12_;
	const gchar* _tmp13_;
	const gchar* _tmp14_;
	gchar* _tmp15_ = NULL;
	FolksPersonaStore* _tmp16_;
	FolksPersonaStore* _tmp17_;
	GeeHashMap* _tmp18_;
	const gchar* _tmp19_;
	FolksPersonaStore* _tmp20_;
	FolksPersonaStore* _tmp21_;
	FolksPersonaStore* _tmp22_;
	FolksPersonaStore* _tmp23_;
	FolksPersonaStore* _tmp24_;
	FolksPersonaStore* _tmp25_;
	gboolean _tmp26_;
	gboolean _tmp27_;
	FolksPersonaStore* _tmp31_;
	GeeMap* _tmp32_;
	GeeMap* _tmp33_;
	gint _tmp34_;
	gint _tmp35_;
	FolksPersonaStore* _tmp55_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (backend != NULL);
	g_return_if_fail (store != NULL);
	_data4_ = g_slice_new0 (Block4Data);
	_data4_->_ref_count_ = 1;
	_data4_->self = g_object_ref (self);
	_tmp0_ = store;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (_data4_->store);
	_data4_->store = _tmp1_;
	_tmp2_ = backend;
	_tmp3_ = folks_backend_get_name (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = _data4_->store;
	_tmp6_ = folks_persona_store_get_id (_tmp5_);
	_tmp7_ = _tmp6_;
	_tmp8_ = _data4_->store;
	g_debug ("individual-aggregator.vala:874: _backend_persona_store_added_cb(): bac" \
"kend: %s, store: %s (%p)", _tmp4_, _tmp7_, _tmp8_);
	_tmp9_ = _data4_->store;
	_tmp10_ = folks_persona_store_get_type_id (_tmp9_);
	_tmp11_ = _tmp10_;
	_tmp12_ = _data4_->store;
	_tmp13_ = folks_persona_store_get_id (_tmp12_);
	_tmp14_ = _tmp13_;
	_tmp15_ = _folks_individual_aggregator_get_store_full_id (self, _tmp11_, _tmp14_);
	_data4_->store_id = _tmp15_;
	_tmp16_ = _data4_->store;
	_folks_individual_aggregator_maybe_configure_as_primary (self, _tmp16_);
	_tmp17_ = _data4_->store;
	_folks_individual_aggregator_set_primary_store (self, _tmp17_);
	_tmp18_ = self->priv->_stores;
	_tmp19_ = _data4_->store_id;
	_tmp20_ = _data4_->store;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp18_, _tmp19_, _tmp20_);
	_tmp21_ = _data4_->store;
	g_signal_connect_object (_tmp21_, "personas-changed", (GCallback) __folks_individual_aggregator_personas_changed_cb_folks_persona_store_personas_changed, self, 0);
	_tmp22_ = _data4_->store;
	g_signal_connect_object ((GObject*) _tmp22_, "notify::is-primary-store", (GCallback) __folks_individual_aggregator_is_primary_store_changed_cb_g_object_notify, self, 0);
	_tmp23_ = _data4_->store;
	g_signal_connect_object ((GObject*) _tmp23_, "notify::is-quiescent", (GCallback) __folks_individual_aggregator_persona_store_is_quiescent_changed_cb_g_object_notify, self, 0);
	_tmp24_ = _data4_->store;
	g_signal_connect_object ((GObject*) _tmp24_, "notify::is-user-set-default", (GCallback) __folks_individual_aggregator_persona_store_is_user_set_default_changed_cb_g_object_notify, self, 0);
	_tmp25_ = _data4_->store;
	_tmp26_ = folks_persona_store_get_is_quiescent (_tmp25_);
	_tmp27_ = _tmp26_;
	if (_tmp27_ == FALSE) {
		guint _tmp28_;
		guint _tmp29_;
		_tmp28_ = self->priv->_non_quiescent_persona_store_count;
		self->priv->_non_quiescent_persona_store_count = _tmp28_ + 1;
		_tmp29_ = self->priv->_quiescent_timeout_id;
		if (_tmp29_ == ((guint) 0)) {
			guint _tmp30_ = 0U;
			_tmp30_ = g_timeout_add_seconds_full (G_PRIORITY_DEFAULT, FOLKS_INDIVIDUAL_AGGREGATOR__QUIESCENT_TIMEOUT, __folks_individual_aggregator_quiescent_timeout_cb_gsource_func, g_object_ref (self), g_object_unref);
			self->priv->_quiescent_timeout_id = _tmp30_;
		}
	}
	_tmp31_ = _data4_->store;
	_tmp32_ = folks_persona_store_get_personas (_tmp31_);
	_tmp33_ = _tmp32_;
	_tmp34_ = gee_map_get_size (_tmp33_);
	_tmp35_ = _tmp34_;
	if (_tmp35_ > 0) {
		GeeHashSet* persona_set = NULL;
		GeeHashSet* _tmp36_;
		FolksPersonaStore* _tmp51_;
		GeeHashSet* _tmp52_;
		FolksSmallSet* _tmp53_ = NULL;
		FolksSmallSet* _tmp54_;
		_tmp36_ = gee_hash_set_new (FOLKS_TYPE_PERSONA, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL);
		persona_set = _tmp36_;
		{
			GeeIterator* _p_it = NULL;
			FolksPersonaStore* _tmp37_;
			GeeMap* _tmp38_;
			GeeMap* _tmp39_;
			GeeCollection* _tmp40_;
			GeeCollection* _tmp41_;
			GeeCollection* _tmp42_;
			GeeIterator* _tmp43_ = NULL;
			GeeIterator* _tmp44_;
			_tmp37_ = _data4_->store;
			_tmp38_ = folks_persona_store_get_personas (_tmp37_);
			_tmp39_ = _tmp38_;
			_tmp40_ = gee_map_get_values (_tmp39_);
			_tmp41_ = _tmp40_;
			_tmp42_ = _tmp41_;
			_tmp43_ = gee_iterable_iterator ((GeeIterable*) _tmp42_);
			_tmp44_ = _tmp43_;
			_g_object_unref0 (_tmp42_);
			_p_it = _tmp44_;
			while (TRUE) {
				GeeIterator* _tmp45_;
				gboolean _tmp46_ = FALSE;
				FolksPersona* p = NULL;
				GeeIterator* _tmp47_;
				gpointer _tmp48_ = NULL;
				GeeHashSet* _tmp49_;
				FolksPersona* _tmp50_;
				_tmp45_ = _p_it;
				_tmp46_ = gee_iterator_next (_tmp45_);
				if (!_tmp46_) {
					break;
				}
				_tmp47_ = _p_it;
				_tmp48_ = gee_iterator_get (_tmp47_);
				p = (FolksPersona*) _tmp48_;
				_tmp49_ = persona_set;
				_tmp50_ = p;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp49_, _tmp50_);
				_g_object_unref0 (p);
			}
			_g_object_unref0 (_p_it);
		}
		_tmp51_ = _data4_->store;
		_tmp52_ = persona_set;
		_tmp53_ = folks_small_set_empty (FOLKS_TYPE_PERSONA, (GBoxedCopyFunc) g_object_ref, g_object_unref);
		_tmp54_ = _tmp53_;
		_folks_individual_aggregator_personas_changed_cb (self, _tmp51_, (GeeSet*) _tmp52_, (GeeSet*) _tmp54_, NULL, NULL, FOLKS_GROUP_DETAILS_CHANGE_REASON_NONE);
		_g_object_unref0 (_tmp54_);
		_g_object_unref0 (persona_set);
	}
	_tmp55_ = _data4_->store;
	folks_persona_store_prepare (_tmp55_, ___lambda67__gasync_ready_callback, block4_data_ref (_data4_));
	block4_data_unref (_data4_);
	_data4_ = NULL;
}


static void _folks_individual_aggregator_backend_persona_store_removed_cb (FolksIndividualAggregator* self, FolksBackend* backend, FolksPersonaStore* store) {
	FolksPersonaStore* _tmp0_;
	guint _tmp1_ = 0U;
	FolksPersonaStore* _tmp2_;
	guint _tmp3_ = 0U;
	GQuark _tmp4_ = 0U;
	FolksPersonaStore* _tmp5_;
	guint _tmp6_ = 0U;
	GQuark _tmp7_ = 0U;
	FolksPersonaStore* _tmp8_;
	guint _tmp9_ = 0U;
	GQuark _tmp10_ = 0U;
	gboolean _tmp11_ = FALSE;
	gboolean _tmp12_;
	gboolean _tmp16_;
	GeeHashSet* removed_personas = NULL;
	GeeHashSet* _tmp18_;
	GeeMapIterator* iter = NULL;
	FolksPersonaStore* _tmp19_;
	GeeMap* _tmp20_;
	GeeMap* _tmp21_;
	GeeMapIterator* _tmp22_ = NULL;
	FolksPersonaStore* _tmp29_;
	FolksSmallSet* _tmp30_ = NULL;
	FolksSmallSet* _tmp31_;
	GeeHashSet* _tmp32_;
	FolksPersonaStore* _tmp33_;
	FolksPersonaStore* _tmp34_;
	GeeHashMap* _tmp42_;
	FolksPersonaStore* _tmp43_;
	const gchar* _tmp44_;
	const gchar* _tmp45_;
	FolksPersonaStore* _tmp46_;
	const gchar* _tmp47_;
	const gchar* _tmp48_;
	gchar* _tmp49_ = NULL;
	gchar* _tmp50_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (backend != NULL);
	g_return_if_fail (store != NULL);
	_tmp0_ = store;
	g_signal_parse_name ("personas-changed", FOLKS_TYPE_PERSONA_STORE, &_tmp1_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (_tmp0_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp1_, 0, NULL, (GCallback) __folks_individual_aggregator_personas_changed_cb_folks_persona_store_personas_changed, self);
	_tmp2_ = store;
	g_signal_parse_name ("notify::is-quiescent", G_TYPE_OBJECT, &_tmp3_, &_tmp4_, TRUE);
	g_signal_handlers_disconnect_matched ((GObject*) _tmp2_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_DETAIL | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp3_, _tmp4_, NULL, (GCallback) __folks_individual_aggregator_persona_store_is_quiescent_changed_cb_g_object_notify, self);
	_tmp5_ = store;
	g_signal_parse_name ("notify::is-primary-store", G_TYPE_OBJECT, &_tmp6_, &_tmp7_, TRUE);
	g_signal_handlers_disconnect_matched ((GObject*) _tmp5_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_DETAIL | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp6_, _tmp7_, NULL, (GCallback) __folks_individual_aggregator_is_primary_store_changed_cb_g_object_notify, self);
	_tmp8_ = store;
	g_signal_parse_name ("notify::is-user-set-default", G_TYPE_OBJECT, &_tmp9_, &_tmp10_, TRUE);
	g_signal_handlers_disconnect_matched ((GObject*) _tmp8_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_DETAIL | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp9_, _tmp10_, NULL, (GCallback) __folks_individual_aggregator_persona_store_is_user_set_default_changed_cb_g_object_notify, self);
	_tmp12_ = self->priv->_is_quiescent;
	if (_tmp12_ == FALSE) {
		FolksPersonaStore* _tmp13_;
		gboolean _tmp14_;
		gboolean _tmp15_;
		_tmp13_ = store;
		_tmp14_ = folks_persona_store_get_is_quiescent (_tmp13_);
		_tmp15_ = _tmp14_;
		_tmp11_ = _tmp15_ == FALSE;
	} else {
		_tmp11_ = FALSE;
	}
	_tmp16_ = _tmp11_;
	if (_tmp16_) {
		guint _tmp17_;
		_tmp17_ = self->priv->_non_quiescent_persona_store_count;
		self->priv->_non_quiescent_persona_store_count = _tmp17_ - 1;
		_folks_individual_aggregator_notify_if_is_quiescent (self);
	}
	_tmp18_ = gee_hash_set_new (FOLKS_TYPE_PERSONA, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL);
	removed_personas = _tmp18_;
	_tmp19_ = store;
	_tmp20_ = folks_persona_store_get_personas (_tmp19_);
	_tmp21_ = _tmp20_;
	_tmp22_ = gee_map_map_iterator (_tmp21_);
	iter = _tmp22_;
	while (TRUE) {
		GeeMapIterator* _tmp23_;
		gboolean _tmp24_ = FALSE;
		GeeHashSet* _tmp25_;
		GeeMapIterator* _tmp26_;
		gpointer _tmp27_ = NULL;
		FolksPersona* _tmp28_;
		_tmp23_ = iter;
		_tmp24_ = gee_map_iterator_next (_tmp23_);
		if (!(_tmp24_ == TRUE)) {
			break;
		}
		_tmp25_ = removed_personas;
		_tmp26_ = iter;
		_tmp27_ = gee_map_iterator_get_value (_tmp26_);
		_tmp28_ = (FolksPersona*) _tmp27_;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp25_, _tmp28_);
		_g_object_unref0 (_tmp28_);
	}
	_tmp29_ = store;
	_tmp30_ = folks_small_set_empty (FOLKS_TYPE_PERSONA, (GBoxedCopyFunc) g_object_ref, g_object_unref);
	_tmp31_ = _tmp30_;
	_tmp32_ = removed_personas;
	_folks_individual_aggregator_personas_changed_cb (self, _tmp29_, (GeeSet*) _tmp31_, (GeeSet*) _tmp32_, NULL, NULL, FOLKS_GROUP_DETAILS_CHANGE_REASON_NONE);
	_g_object_unref0 (_tmp31_);
	_tmp33_ = self->priv->_primary_store;
	_tmp34_ = store;
	if (_tmp33_ == _tmp34_) {
		FolksPersonaStore* _tmp35_;
		FolksPersonaStore* _tmp36_;
		const gchar* _tmp37_;
		const gchar* _tmp38_;
		FolksPersonaStore* _tmp39_;
		const gchar* _tmp40_;
		const gchar* _tmp41_;
		_tmp35_ = store;
		_tmp36_ = store;
		_tmp37_ = folks_persona_store_get_type_id (_tmp36_);
		_tmp38_ = _tmp37_;
		_tmp39_ = store;
		_tmp40_ = folks_persona_store_get_id (_tmp39_);
		_tmp41_ = _tmp40_;
		g_debug ("Unsetting primary store as store %p (type ID: %s, ID: %s) " "has been removed", _tmp35_, _tmp38_, _tmp41_);
		self->priv->_primary_store = NULL;
		g_object_notify ((GObject*) self, "primary-store");
	}
	_tmp42_ = self->priv->_stores;
	_tmp43_ = store;
	_tmp44_ = folks_persona_store_get_type_id (_tmp43_);
	_tmp45_ = _tmp44_;
	_tmp46_ = store;
	_tmp47_ = folks_persona_store_get_id (_tmp46_);
	_tmp48_ = _tmp47_;
	_tmp49_ = _folks_individual_aggregator_get_store_full_id (self, _tmp45_, _tmp48_);
	_tmp50_ = _tmp49_;
	gee_abstract_map_unset ((GeeAbstractMap*) _tmp42_, _tmp50_, NULL);
	_g_free0 (_tmp50_);
	_g_object_unref0 (iter);
	_g_object_unref0 (removed_personas);
}


static gchar* _folks_individual_aggregator_get_store_full_id (FolksIndividualAggregator* self, const gchar* type_id, const gchar* id) {
	gchar* result = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	const gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (type_id != NULL, NULL);
	g_return_val_if_fail (id != NULL, NULL);
	_tmp0_ = type_id;
	_tmp1_ = g_strconcat (_tmp0_, ":", NULL);
	_tmp2_ = _tmp1_;
	_tmp3_ = id;
	_tmp4_ = g_strconcat (_tmp2_, _tmp3_, NULL);
	_tmp5_ = _tmp4_;
	_g_free0 (_tmp2_);
	result = _tmp5_;
	return result;
}


static void _folks_individual_aggregator_emit_individuals_changed (FolksIndividualAggregator* self, GeeSet* added, GeeSet* removed, GeeMultiMap* changes, const gchar* message, FolksPersona* actor, FolksGroupDetailsChangeReason reason) {
	GeeSet* _added = NULL;
	GeeSet* _removed = NULL;
	GeeMultiMap* _changes = NULL;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	GeeSet* _tmp3_;
	gboolean _tmp7_;
	gboolean _tmp14_;
	gboolean _tmp21_;
	GeeSet* _tmp22_ = NULL;
	GeeSet* _tmp23_;
	GeeSet* _tmp27_;
	GeeSet* _tmp28_;
	GeeSet* _tmp29_ = NULL;
	GeeSet* _tmp30_;
	GeeSet* _tmp34_;
	GeeSet* _tmp35_;
	GeeMultiMap* _tmp36_;
	FolksDebug* _tmp40_;
	gboolean _tmp41_;
	gboolean _tmp42_;
	GeeSet* _tmp94_;
	GeeSet* _tmp95_;
	GeeSet* _tmp96_;
	GeeSet* _tmp97_;
	GeeSet* _tmp98_;
	GeeSet* _tmp99_;
	GeeSet* _tmp100_;
	GeeSet* _tmp101_;
	const gchar* _tmp102_;
	FolksPersona* _tmp103_;
	FolksGroupDetailsChangeReason _tmp104_;
	GeeMultiMap* _tmp105_;
	g_return_if_fail (self != NULL);
	_tmp3_ = added;
	if (_tmp3_ == NULL) {
		_tmp2_ = TRUE;
	} else {
		GeeSet* _tmp4_;
		gint _tmp5_;
		gint _tmp6_;
		_tmp4_ = added;
		_tmp5_ = gee_collection_get_size ((GeeCollection*) G_TYPE_CHECK_INSTANCE_CAST (_tmp4_, GEE_TYPE_SET, GeeSet));
		_tmp6_ = _tmp5_;
		_tmp2_ = _tmp6_ == 0;
	}
	_tmp7_ = _tmp2_;
	if (_tmp7_) {
		gboolean _tmp8_ = FALSE;
		GeeSet* _tmp9_;
		gboolean _tmp13_;
		_tmp9_ = removed;
		if (_tmp9_ == NULL) {
			_tmp8_ = TRUE;
		} else {
			GeeSet* _tmp10_;
			gint _tmp11_;
			gint _tmp12_;
			_tmp10_ = removed;
			_tmp11_ = gee_collection_get_size ((GeeCollection*) G_TYPE_CHECK_INSTANCE_CAST (_tmp10_, GEE_TYPE_SET, GeeSet));
			_tmp12_ = _tmp11_;
			_tmp8_ = _tmp12_ == 0;
		}
		_tmp13_ = _tmp8_;
		_tmp1_ = _tmp13_;
	} else {
		_tmp1_ = FALSE;
	}
	_tmp14_ = _tmp1_;
	if (_tmp14_) {
		gboolean _tmp15_ = FALSE;
		GeeMultiMap* _tmp16_;
		gboolean _tmp20_;
		_tmp16_ = changes;
		if (_tmp16_ == NULL) {
			_tmp15_ = TRUE;
		} else {
			GeeMultiMap* _tmp17_;
			gint _tmp18_;
			gint _tmp19_;
			_tmp17_ = changes;
			_tmp18_ = gee_multi_map_get_size (G_TYPE_CHECK_INSTANCE_CAST (_tmp17_, GEE_TYPE_MULTI_MAP, GeeMultiMap));
			_tmp19_ = _tmp18_;
			_tmp15_ = _tmp19_ == 0;
		}
		_tmp20_ = _tmp15_;
		_tmp0_ = _tmp20_;
	} else {
		_tmp0_ = FALSE;
	}
	_tmp21_ = _tmp0_;
	if (_tmp21_) {
		_g_object_unref0 (_changes);
		_g_object_unref0 (_removed);
		_g_object_unref0 (_added);
		return;
	}
	folks_internal_profiling_point ("emitting " "IndividualAggregator::individuals-changed", NULL);
	_tmp23_ = added;
	if (_tmp23_ != NULL) {
		GeeSet* _tmp24_;
		GeeSet* _tmp25_;
		_tmp24_ = added;
		_tmp25_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp24_, GEE_TYPE_SET, GeeSet));
		_g_object_unref0 (_tmp22_);
		_tmp22_ = _tmp25_;
	} else {
		FolksSmallSet* _tmp26_ = NULL;
		_tmp26_ = folks_small_set_empty (FOLKS_TYPE_INDIVIDUAL, (GBoxedCopyFunc) g_object_ref, g_object_unref);
		_g_object_unref0 (_tmp22_);
		_tmp22_ = (GeeSet*) _tmp26_;
	}
	_tmp27_ = _tmp22_;
	_tmp28_ = _g_object_ref0 (_tmp27_);
	_g_object_unref0 (_added);
	_added = _tmp28_;
	_tmp30_ = removed;
	if (_tmp30_ != NULL) {
		GeeSet* _tmp31_;
		GeeSet* _tmp32_;
		_tmp31_ = removed;
		_tmp32_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp31_, GEE_TYPE_SET, GeeSet));
		_g_object_unref0 (_tmp29_);
		_tmp29_ = _tmp32_;
	} else {
		FolksSmallSet* _tmp33_ = NULL;
		_tmp33_ = folks_small_set_empty (FOLKS_TYPE_INDIVIDUAL, (GBoxedCopyFunc) g_object_ref, g_object_unref);
		_g_object_unref0 (_tmp29_);
		_tmp29_ = (GeeSet*) _tmp33_;
	}
	_tmp34_ = _tmp29_;
	_tmp35_ = _g_object_ref0 (_tmp34_);
	_g_object_unref0 (_removed);
	_removed = _tmp35_;
	_tmp36_ = changes;
	if (_tmp36_ != NULL) {
		GeeMultiMap* _tmp37_;
		GeeMultiMap* _tmp38_;
		_tmp37_ = changes;
		_tmp38_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp37_, GEE_TYPE_MULTI_MAP, GeeMultiMap));
		_g_object_unref0 (_changes);
		_changes = _tmp38_;
	} else {
		GeeHashMultiMap* _tmp39_;
		_tmp39_ = gee_hash_multi_map_new (FOLKS_TYPE_INDIVIDUAL, (GBoxedCopyFunc) g_object_ref, g_object_unref, FOLKS_TYPE_INDIVIDUAL, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
		_g_object_unref0 (_changes);
		_changes = (GeeMultiMap*) _tmp39_;
	}
	_tmp40_ = self->priv->_debug;
	_tmp41_ = folks_debug_get_debug_output_enabled (_tmp40_);
	_tmp42_ = _tmp41_;
	if (_tmp42_ == TRUE) {
		GeeMultiMap* _tmp43_;
		gint _tmp44_;
		gint _tmp45_;
		GeeMapIterator* iter = NULL;
		GeeMultiMap* _tmp46_;
		GeeMapIterator* _tmp47_ = NULL;
		_tmp43_ = _changes;
		_tmp44_ = gee_multi_map_get_size (_tmp43_);
		_tmp45_ = _tmp44_;
		g_debug ("individual-aggregator.vala:1037: Emitting individuals-changed-detailed" \
" with %u mappings:", (guint) _tmp45_);
		_tmp46_ = _changes;
		_tmp47_ = gee_multi_map_map_iterator (_tmp46_);
		iter = _tmp47_;
		while (TRUE) {
			GeeMapIterator* _tmp48_;
			gboolean _tmp49_ = FALSE;
			FolksIndividual* removed_ind = NULL;
			GeeMapIterator* _tmp50_;
			gpointer _tmp51_ = NULL;
			FolksIndividual* added_ind = NULL;
			GeeMapIterator* _tmp52_;
			gpointer _tmp53_ = NULL;
			const gchar* _tmp54_ = NULL;
			FolksIndividual* _tmp55_;
			const gchar* _tmp59_ = NULL;
			FolksIndividual* _tmp60_;
			const gchar* _tmp64_;
			FolksIndividual* _tmp65_;
			const gchar* _tmp66_;
			FolksIndividual* _tmp67_;
			FolksIndividual* _tmp68_;
			FolksIndividual* _tmp81_;
			_tmp48_ = iter;
			_tmp49_ = gee_map_iterator_next (_tmp48_);
			if (!_tmp49_) {
				break;
			}
			_tmp50_ = iter;
			_tmp51_ = gee_map_iterator_get_key (_tmp50_);
			removed_ind = (FolksIndividual*) _tmp51_;
			_tmp52_ = iter;
			_tmp53_ = gee_map_iterator_get_value (_tmp52_);
			added_ind = (FolksIndividual*) _tmp53_;
			_tmp55_ = removed_ind;
			if (_tmp55_ != NULL) {
				FolksIndividual* _tmp56_;
				const gchar* _tmp57_;
				const gchar* _tmp58_;
				_tmp56_ = removed_ind;
				_tmp57_ = folks_individual_get_id (G_TYPE_CHECK_INSTANCE_CAST (_tmp56_, FOLKS_TYPE_INDIVIDUAL, FolksIndividual));
				_tmp58_ = _tmp57_;
				_tmp54_ = _tmp58_;
			} else {
				_tmp54_ = "";
			}
			_tmp60_ = added_ind;
			if (_tmp60_ != NULL) {
				FolksIndividual* _tmp61_;
				const gchar* _tmp62_;
				const gchar* _tmp63_;
				_tmp61_ = added_ind;
				_tmp62_ = folks_individual_get_id (G_TYPE_CHECK_INSTANCE_CAST (_tmp61_, FOLKS_TYPE_INDIVIDUAL, FolksIndividual));
				_tmp63_ = _tmp62_;
				_tmp59_ = _tmp63_;
			} else {
				_tmp59_ = "";
			}
			_tmp64_ = _tmp54_;
			_tmp65_ = removed_ind;
			_tmp66_ = _tmp59_;
			_tmp67_ = added_ind;
			g_debug ("individual-aggregator.vala:1047:     %s (%p)  %s (%p)", _tmp64_, _tmp65_, _tmp66_, _tmp67_);
			_tmp68_ = removed_ind;
			if (_tmp68_ != NULL) {
				g_debug ("individual-aggregator.vala:1054:       Removed individual's personas:");
				{
					GeeIterator* _p_it = NULL;
					FolksIndividual* _tmp69_;
					GeeSet* _tmp70_;
					GeeSet* _tmp71_;
					GeeIterator* _tmp72_ = NULL;
					_tmp69_ = removed_ind;
					_tmp70_ = folks_individual_get_personas (G_TYPE_CHECK_INSTANCE_CAST (_tmp69_, FOLKS_TYPE_INDIVIDUAL, FolksIndividual));
					_tmp71_ = _tmp70_;
					_tmp72_ = gee_iterable_iterator ((GeeIterable*) _tmp71_);
					_p_it = _tmp72_;
					while (TRUE) {
						GeeIterator* _tmp73_;
						gboolean _tmp74_ = FALSE;
						FolksPersona* p = NULL;
						GeeIterator* _tmp75_;
						gpointer _tmp76_ = NULL;
						FolksPersona* _tmp77_;
						const gchar* _tmp78_;
						const gchar* _tmp79_;
						FolksPersona* _tmp80_;
						_tmp73_ = _p_it;
						_tmp74_ = gee_iterator_next (_tmp73_);
						if (!_tmp74_) {
							break;
						}
						_tmp75_ = _p_it;
						_tmp76_ = gee_iterator_get (_tmp75_);
						p = (FolksPersona*) _tmp76_;
						_tmp77_ = p;
						_tmp78_ = folks_persona_get_uid (_tmp77_);
						_tmp79_ = _tmp78_;
						_tmp80_ = p;
						g_debug ("individual-aggregator.vala:1058:         %s (%p)", _tmp79_, _tmp80_);
						_g_object_unref0 (p);
					}
					_g_object_unref0 (_p_it);
				}
			}
			_tmp81_ = added_ind;
			if (_tmp81_ != NULL) {
				g_debug ("individual-aggregator.vala:1064:       Added individual's personas:");
				{
					GeeIterator* _p_it = NULL;
					FolksIndividual* _tmp82_;
					GeeSet* _tmp83_;
					GeeSet* _tmp84_;
					GeeIterator* _tmp85_ = NULL;
					_tmp82_ = added_ind;
					_tmp83_ = folks_individual_get_personas (G_TYPE_CHECK_INSTANCE_CAST (_tmp82_, FOLKS_TYPE_INDIVIDUAL, FolksIndividual));
					_tmp84_ = _tmp83_;
					_tmp85_ = gee_iterable_iterator ((GeeIterable*) _tmp84_);
					_p_it = _tmp85_;
					while (TRUE) {
						GeeIterator* _tmp86_;
						gboolean _tmp87_ = FALSE;
						FolksPersona* p = NULL;
						GeeIterator* _tmp88_;
						gpointer _tmp89_ = NULL;
						FolksPersona* _tmp90_;
						const gchar* _tmp91_;
						const gchar* _tmp92_;
						FolksPersona* _tmp93_;
						_tmp86_ = _p_it;
						_tmp87_ = gee_iterator_next (_tmp86_);
						if (!_tmp87_) {
							break;
						}
						_tmp88_ = _p_it;
						_tmp89_ = gee_iterator_get (_tmp88_);
						p = (FolksPersona*) _tmp89_;
						_tmp90_ = p;
						_tmp91_ = folks_persona_get_uid (_tmp90_);
						_tmp92_ = _tmp91_;
						_tmp93_ = p;
						g_debug ("individual-aggregator.vala:1068:         %s (%p)", _tmp92_, _tmp93_);
						_g_object_unref0 (p);
					}
					_g_object_unref0 (_p_it);
				}
			}
			_g_object_unref0 (added_ind);
			_g_object_unref0 (removed_ind);
		}
		_g_object_unref0 (iter);
	}
	_tmp94_ = _added;
	_tmp95_ = gee_set_get_read_only_view (_tmp94_);
	_tmp96_ = _tmp95_;
	_tmp97_ = _tmp96_;
	_tmp98_ = _removed;
	_tmp99_ = gee_set_get_read_only_view (_tmp98_);
	_tmp100_ = _tmp99_;
	_tmp101_ = _tmp100_;
	_tmp102_ = message;
	_tmp103_ = actor;
	_tmp104_ = reason;
	g_signal_emit_by_name (self, "individuals-changed", _tmp97_, _tmp101_, _tmp102_, _tmp103_, _tmp104_);
	_g_object_unref0 (_tmp101_);
	_g_object_unref0 (_tmp97_);
	_tmp105_ = _changes;
	g_signal_emit_by_name (self, "individuals-changed-detailed", _tmp105_);
	_g_object_unref0 (_tmp29_);
	_g_object_unref0 (_tmp22_);
	_g_object_unref0 (_changes);
	_g_object_unref0 (_removed);
	_g_object_unref0 (_added);
}


static void __folks_individual_aggregator_individual_removed_cb_folks_individual_removed (FolksIndividual* _sender, FolksIndividual* replacement_individual, gpointer self) {
	_folks_individual_aggregator_individual_removed_cb (self, _sender, replacement_individual);
}


static void _folks_individual_aggregator_connect_to_individual (FolksIndividualAggregator* self, FolksIndividual* individual) {
	FolksIndividual* _tmp0_;
	GeeMap* _tmp1_;
	FolksIndividual* _tmp2_;
	const gchar* _tmp3_;
	const gchar* _tmp4_;
	FolksIndividual* _tmp5_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (individual != NULL);
	_tmp0_ = individual;
	g_signal_connect_object (_tmp0_, "removed", (GCallback) __folks_individual_aggregator_individual_removed_cb_folks_individual_removed, self, 0);
	_tmp1_ = self->priv->_individuals;
	_tmp2_ = individual;
	_tmp3_ = folks_individual_get_id (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = individual;
	gee_map_set (_tmp1_, _tmp4_, _tmp5_);
}


static void _folks_individual_aggregator_disconnect_from_individual (FolksIndividualAggregator* self, FolksIndividual* individual) {
	GeeMap* _tmp0_;
	FolksIndividual* _tmp1_;
	const gchar* _tmp2_;
	const gchar* _tmp3_;
	FolksIndividual* _tmp4_;
	guint _tmp5_ = 0U;
	g_return_if_fail (self != NULL);
	g_return_if_fail (individual != NULL);
	_tmp0_ = self->priv->_individuals;
	_tmp1_ = individual;
	_tmp2_ = folks_individual_get_id (_tmp1_);
	_tmp3_ = _tmp2_;
	gee_map_unset (_tmp0_, _tmp3_, NULL);
	_tmp4_ = individual;
	g_signal_parse_name ("removed", FOLKS_TYPE_INDIVIDUAL, &_tmp5_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (_tmp4_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp5_, 0, NULL, (GCallback) __folks_individual_aggregator_individual_removed_cb_folks_individual_removed, self);
}


static Block5Data* block5_data_ref (Block5Data* _data5_) {
	g_atomic_int_inc (&_data5_->_ref_count_);
	return _data5_;
}


static void block5_data_unref (void * _userdata_) {
	Block5Data* _data5_;
	_data5_ = (Block5Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data5_->_ref_count_)) {
		FolksIndividualAggregator * self;
		self = _data5_->self;
		_g_object_unref0 (_data5_->candidate_inds);
		_g_object_unref0 (_data5_->persona);
		_g_object_unref0 (self);
		g_slice_free (Block5Data, _data5_);
	}
}


static Block6Data* block6_data_ref (Block6Data* _data6_) {
	g_atomic_int_inc (&_data6_->_ref_count_);
	return _data6_;
}


static void block6_data_unref (void * _userdata_) {
	Block6Data* _data6_;
	_data6_ = (Block6Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data6_->_ref_count_)) {
		FolksIndividualAggregator * self;
		self = _data6_->_data5_->self;
		block5_data_unref (_data6_->_data5_);
		_data6_->_data5_ = NULL;
		g_slice_free (Block6Data, _data6_);
	}
}


static void _______lambda65_ (Block6Data* _data6_, const gchar* l) {
	Block5Data* _data5_;
	FolksIndividualAggregator * self;
	const gchar* prop_linking_value = NULL;
	const gchar* _tmp0_;
	GPtrArray* candidates = NULL;
	GHashTable* _tmp1_;
	const gchar* _tmp2_;
	gconstpointer _tmp3_ = NULL;
	GPtrArray* _tmp4_;
	_data5_ = _data6_->_data5_;
	self = _data5_->self;
	g_return_if_fail (l != NULL);
	_tmp0_ = l;
	prop_linking_value = _tmp0_;
	_tmp1_ = self->priv->_link_map;
	_tmp2_ = prop_linking_value;
	_tmp3_ = g_hash_table_lookup (_tmp1_, _tmp2_);
	candidates = (GPtrArray*) _tmp3_;
	_tmp4_ = candidates;
	if (_tmp4_ != NULL) {
		{
			guint i = 0U;
			i = (guint) 0;
			{
				gboolean _tmp5_ = FALSE;
				_tmp5_ = TRUE;
				while (TRUE) {
					gboolean _tmp6_;
					guint _tmp8_;
					GPtrArray* _tmp9_;
					gint _tmp10_;
					gint _tmp11_;
					FolksIndividual* candidate_ind = NULL;
					GPtrArray* _tmp12_;
					guint _tmp13_;
					gconstpointer _tmp14_ = NULL;
					FolksIndividual* _tmp15_;
					gboolean _tmp16_ = FALSE;
					gboolean _tmp17_ = FALSE;
					FolksIndividual* _tmp18_;
					FolksTrustLevel _tmp19_;
					FolksTrustLevel _tmp20_;
					gboolean _tmp24_;
					gboolean _tmp28_;
					_tmp6_ = _tmp5_;
					if (!_tmp6_) {
						guint _tmp7_;
						_tmp7_ = i;
						i = _tmp7_ + 1;
					}
					_tmp5_ = FALSE;
					_tmp8_ = i;
					_tmp9_ = candidates;
					_tmp10_ = g_ptr_array_get_length ((GPtrArray*) _tmp9_);
					_tmp11_ = _tmp10_;
					if (!(_tmp8_ < ((guint) _tmp11_))) {
						break;
					}
					_tmp12_ = candidates;
					_tmp13_ = i;
					_tmp14_ = g_ptr_array_index ((GPtrArray*) _tmp12_, _tmp13_);
					_tmp15_ = _g_object_ref0 ((FolksIndividual*) _tmp14_);
					candidate_ind = _tmp15_;
					_tmp18_ = candidate_ind;
					_tmp19_ = folks_individual_get_trust_level (_tmp18_);
					_tmp20_ = _tmp19_;
					if (_tmp20_ != FOLKS_TRUST_LEVEL_NONE) {
						FolksIndividual* _tmp21_;
						FolksPersona* _tmp22_;
						gboolean _tmp23_ = FALSE;
						_tmp21_ = candidate_ind;
						_tmp22_ = _data5_->persona;
						_tmp23_ = folks_individual_has_anti_link_with_persona (_tmp21_, _tmp22_);
						_tmp17_ = _tmp23_ == FALSE;
					} else {
						_tmp17_ = FALSE;
					}
					_tmp24_ = _tmp17_;
					if (_tmp24_) {
						GeeHashSet* _tmp25_;
						FolksIndividual* _tmp26_;
						gboolean _tmp27_ = FALSE;
						_tmp25_ = _data5_->candidate_inds;
						_tmp26_ = candidate_ind;
						_tmp27_ = gee_abstract_collection_add ((GeeAbstractCollection*) _tmp25_, _tmp26_);
						_tmp16_ = _tmp27_;
					} else {
						_tmp16_ = FALSE;
					}
					_tmp28_ = _tmp16_;
					if (_tmp28_) {
						FolksIndividual* _tmp29_;
						const gchar* _tmp30_;
						const gchar* _tmp31_;
						const gchar* _tmp32_;
						const gchar* _tmp33_;
						_tmp29_ = candidate_ind;
						_tmp30_ = folks_individual_get_id (_tmp29_);
						_tmp31_ = _tmp30_;
						_tmp32_ = _data6_->prop_name;
						_tmp33_ = prop_linking_value;
						g_debug ("    Found candidate individual '%s'" " by linkable property '%s' = '%s'.", _tmp31_, _tmp32_, _tmp33_);
					}
					_g_object_unref0 (candidate_ind);
				}
			}
		}
	}
}


static void ________lambda65__folks_persona_linkable_property_callback (const gchar* link, gpointer self) {
	_______lambda65_ (self, link);
}


static void _folks_individual_aggregator_add_personas (FolksIndividualAggregator* self, GeeSet* added, FolksIndividual** user, GeeHashMultiMap** individuals_changes) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (added != NULL);
	g_return_if_fail (*individuals_changes != NULL);
	{
		GeeIterator* _persona_it = NULL;
		GeeSet* _tmp0_;
		GeeIterator* _tmp1_ = NULL;
		_tmp0_ = added;
		_tmp1_ = gee_iterable_iterator ((GeeIterable*) _tmp0_);
		_persona_it = _tmp1_;
		while (TRUE) {
			Block5Data* _data5_;
			GeeIterator* _tmp2_;
			gboolean _tmp3_ = FALSE;
			GeeIterator* _tmp4_;
			gpointer _tmp5_ = NULL;
			FolksPersonaStoreTrust trust_level = 0;
			FolksPersona* _tmp6_;
			FolksPersonaStore* _tmp7_;
			FolksPersonaStore* _tmp8_;
			FolksPersonaStoreTrust _tmp9_;
			FolksPersonaStoreTrust _tmp10_;
			GeeHashSet* _tmp11_;
			GeeHashSet* final_personas = NULL;
			GeeHashSet* _tmp12_;
			FolksPersona* _tmp13_;
			const gchar* _tmp14_;
			const gchar* _tmp15_;
			FolksPersona* _tmp16_;
			const gchar* _tmp17_;
			const gchar* _tmp18_;
			gboolean _tmp19_ = FALSE;
			gboolean _tmp20_ = FALSE;
			FolksPersona* _tmp21_;
			gboolean _tmp22_;
			gboolean _tmp23_;
			gboolean _tmp25_;
			gboolean _tmp29_;
			FolksPersonaStoreTrust _tmp35_;
			FolksPersona* _tmp72_;
			FolksPersonaStore* _tmp73_;
			FolksPersonaStore* _tmp74_;
			FolksPersonaStoreTrust _tmp75_;
			FolksPersonaStoreTrust _tmp76_;
			GeeHashSet* _tmp90_;
			FolksPersona* _tmp91_;
			gboolean _tmp92_ = FALSE;
			GeeHashSet* _tmp93_;
			gint _tmp94_;
			gint _tmp95_;
			gboolean _tmp97_;
			FolksIndividual* final_individual = NULL;
			GeeHashSet* _tmp111_;
			FolksIndividual* _tmp112_;
			FolksIndividual* _tmp113_;
			const gchar* _tmp114_;
			const gchar* _tmp115_;
			FolksIndividual* _tmp116_;
			guint num_mappings_added = 0U;
			guint _tmp172_;
			FolksIndividual* _tmp175_;
			gboolean _tmp176_;
			gboolean _tmp177_;
			_data5_ = g_slice_new0 (Block5Data);
			_data5_->_ref_count_ = 1;
			_data5_->self = g_object_ref (self);
			_tmp2_ = _persona_it;
			_tmp3_ = gee_iterator_next (_tmp2_);
			if (!_tmp3_) {
				block5_data_unref (_data5_);
				_data5_ = NULL;
				break;
			}
			_tmp4_ = _persona_it;
			_tmp5_ = gee_iterator_get (_tmp4_);
			_data5_->persona = (FolksPersona*) _tmp5_;
			_tmp6_ = _data5_->persona;
			_tmp7_ = folks_persona_get_store (_tmp6_);
			_tmp8_ = _tmp7_;
			_tmp9_ = folks_persona_store_get_trust_level (_tmp8_);
			_tmp10_ = _tmp9_;
			trust_level = _tmp10_;
			_tmp11_ = gee_hash_set_new (FOLKS_TYPE_INDIVIDUAL, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL);
			_data5_->candidate_inds = _tmp11_;
			_tmp12_ = gee_hash_set_new (FOLKS_TYPE_PERSONA, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL);
			final_personas = _tmp12_;
			_tmp13_ = _data5_->persona;
			_tmp14_ = folks_persona_get_uid (_tmp13_);
			_tmp15_ = _tmp14_;
			_tmp16_ = _data5_->persona;
			_tmp17_ = folks_persona_get_iid (_tmp16_);
			_tmp18_ = _tmp17_;
			g_debug ("individual-aggregator.vala:1110: Aggregating persona '%s' on '%s'.", _tmp15_, _tmp18_);
			_tmp21_ = _data5_->persona;
			_tmp22_ = folks_persona_get_is_user (_tmp21_);
			_tmp23_ = _tmp22_;
			if (_tmp23_ == TRUE) {
				FolksIndividual* _tmp24_;
				_tmp24_ = *user;
				_tmp20_ = _tmp24_ != NULL;
			} else {
				_tmp20_ = FALSE;
			}
			_tmp25_ = _tmp20_;
			if (_tmp25_) {
				FolksIndividual* _tmp26_;
				FolksPersona* _tmp27_;
				gboolean _tmp28_ = FALSE;
				_tmp26_ = *user;
				_tmp27_ = _data5_->persona;
				_tmp28_ = folks_individual_has_anti_link_with_persona (G_TYPE_CHECK_INSTANCE_CAST (_tmp26_, FOLKS_TYPE_INDIVIDUAL, FolksIndividual), _tmp27_);
				_tmp19_ = _tmp28_ == FALSE;
			} else {
				_tmp19_ = FALSE;
			}
			_tmp29_ = _tmp19_;
			if (_tmp29_) {
				FolksIndividual* _tmp30_;
				const gchar* _tmp31_;
				const gchar* _tmp32_;
				GeeHashSet* _tmp33_;
				FolksIndividual* _tmp34_;
				_tmp30_ = *user;
				_tmp31_ = folks_individual_get_id (G_TYPE_CHECK_INSTANCE_CAST (_tmp30_, FOLKS_TYPE_INDIVIDUAL, FolksIndividual));
				_tmp32_ = _tmp31_;
				g_debug ("individual-aggregator.vala:1117:     Found candidate individual '%s' a" \
"s user.", _tmp32_);
				_tmp33_ = _data5_->candidate_inds;
				_tmp34_ = *user;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp33_, G_TYPE_CHECK_INSTANCE_CAST (_tmp34_, FOLKS_TYPE_INDIVIDUAL, FolksIndividual));
			}
			_tmp35_ = trust_level;
			if (_tmp35_ != FOLKS_PERSONA_STORE_TRUST_NONE) {
				GPtrArray* candidates = NULL;
				GHashTable* _tmp36_;
				FolksPersona* _tmp37_;
				const gchar* _tmp38_;
				const gchar* _tmp39_;
				gconstpointer _tmp40_ = NULL;
				GPtrArray* _tmp41_;
				_tmp36_ = self->priv->_link_map;
				_tmp37_ = _data5_->persona;
				_tmp38_ = folks_persona_get_iid (_tmp37_);
				_tmp39_ = _tmp38_;
				_tmp40_ = g_hash_table_lookup (_tmp36_, _tmp39_);
				candidates = (GPtrArray*) _tmp40_;
				_tmp41_ = candidates;
				if (_tmp41_ != NULL) {
					{
						guint i = 0U;
						i = (guint) 0;
						{
							gboolean _tmp42_ = FALSE;
							_tmp42_ = TRUE;
							while (TRUE) {
								gboolean _tmp43_;
								guint _tmp45_;
								GPtrArray* _tmp46_;
								gint _tmp47_;
								gint _tmp48_;
								FolksIndividual* candidate_ind = NULL;
								GPtrArray* _tmp49_;
								guint _tmp50_;
								gconstpointer _tmp51_ = NULL;
								FolksIndividual* _tmp52_;
								gboolean _tmp53_ = FALSE;
								gboolean _tmp54_ = FALSE;
								FolksIndividual* _tmp55_;
								FolksTrustLevel _tmp56_;
								FolksTrustLevel _tmp57_;
								gboolean _tmp61_;
								gboolean _tmp65_;
								_tmp43_ = _tmp42_;
								if (!_tmp43_) {
									guint _tmp44_;
									_tmp44_ = i;
									i = _tmp44_ + 1;
								}
								_tmp42_ = FALSE;
								_tmp45_ = i;
								_tmp46_ = candidates;
								_tmp47_ = g_ptr_array_get_length ((GPtrArray*) _tmp46_);
								_tmp48_ = _tmp47_;
								if (!(_tmp45_ < ((guint) _tmp48_))) {
									break;
								}
								_tmp49_ = candidates;
								_tmp50_ = i;
								_tmp51_ = g_ptr_array_index ((GPtrArray*) _tmp49_, _tmp50_);
								_tmp52_ = _g_object_ref0 ((FolksIndividual*) _tmp51_);
								candidate_ind = _tmp52_;
								_tmp55_ = candidate_ind;
								_tmp56_ = folks_individual_get_trust_level (_tmp55_);
								_tmp57_ = _tmp56_;
								if (_tmp57_ != FOLKS_TRUST_LEVEL_NONE) {
									FolksIndividual* _tmp58_;
									FolksPersona* _tmp59_;
									gboolean _tmp60_ = FALSE;
									_tmp58_ = candidate_ind;
									_tmp59_ = _data5_->persona;
									_tmp60_ = folks_individual_has_anti_link_with_persona (_tmp58_, _tmp59_);
									_tmp54_ = _tmp60_ == FALSE;
								} else {
									_tmp54_ = FALSE;
								}
								_tmp61_ = _tmp54_;
								if (_tmp61_) {
									GeeHashSet* _tmp62_;
									FolksIndividual* _tmp63_;
									gboolean _tmp64_ = FALSE;
									_tmp62_ = _data5_->candidate_inds;
									_tmp63_ = candidate_ind;
									_tmp64_ = gee_abstract_collection_add ((GeeAbstractCollection*) _tmp62_, _tmp63_);
									_tmp53_ = _tmp64_;
								} else {
									_tmp53_ = FALSE;
								}
								_tmp65_ = _tmp53_;
								if (_tmp65_) {
									FolksIndividual* _tmp66_;
									const gchar* _tmp67_;
									const gchar* _tmp68_;
									FolksPersona* _tmp69_;
									const gchar* _tmp70_;
									const gchar* _tmp71_;
									_tmp66_ = candidate_ind;
									_tmp67_ = folks_individual_get_id (_tmp66_);
									_tmp68_ = _tmp67_;
									_tmp69_ = _data5_->persona;
									_tmp70_ = folks_persona_get_iid (_tmp69_);
									_tmp71_ = _tmp70_;
									g_debug ("    Found candidate individual '%s' by " "IID '%s'.", _tmp68_, _tmp71_);
								}
								_g_object_unref0 (candidate_ind);
							}
						}
					}
				}
			}
			_tmp72_ = _data5_->persona;
			_tmp73_ = folks_persona_get_store (_tmp72_);
			_tmp74_ = _tmp73_;
			_tmp75_ = folks_persona_store_get_trust_level (_tmp74_);
			_tmp76_ = _tmp75_;
			if (_tmp76_ == FOLKS_PERSONA_STORE_TRUST_FULL) {
				FolksPersona* _tmp77_;
				gchar** _tmp78_;
				gint _tmp78__length1;
				gchar** _tmp79_;
				gint _tmp79__length1;
				_tmp77_ = _data5_->persona;
				_tmp78_ = folks_persona_get_linkable_properties (_tmp77_, &_tmp78__length1);
				_tmp79_ = _tmp78_;
				_tmp79__length1 = _tmp78__length1;
				{
					gchar** foo_collection = NULL;
					gint foo_collection_length1 = 0;
					gint _foo_collection_size_ = 0;
					gint foo_it = 0;
					foo_collection = _tmp79_;
					foo_collection_length1 = _tmp79__length1;
					for (foo_it = 0; foo_it < _tmp79__length1; foo_it = foo_it + 1) {
						const gchar* foo = NULL;
						foo = foo_collection[foo_it];
						{
							Block6Data* _data6_;
							const gchar* _tmp80_;
							GObjectClass* pclass = NULL;
							FolksPersona* _tmp81_;
							GObjectClass* _tmp82_ = NULL;
							GObjectClass* _tmp83_;
							const gchar* _tmp84_;
							GParamSpec* _tmp85_ = NULL;
							FolksPersona* _tmp88_;
							const gchar* _tmp89_;
							_data6_ = g_slice_new0 (Block6Data);
							_data6_->_ref_count_ = 1;
							_data6_->_data5_ = block5_data_ref (_data5_);
							_tmp80_ = foo;
							_data6_->prop_name = _tmp80_;
							_tmp81_ = _data5_->persona;
							_tmp82_ = G_OBJECT_GET_CLASS ((GObject*) _tmp81_);
							pclass = _tmp82_;
							_tmp83_ = pclass;
							_tmp84_ = _data6_->prop_name;
							_tmp85_ = g_object_class_find_property (_tmp83_, _tmp84_);
							if (_tmp85_ == NULL) {
								const gchar* _tmp86_ = NULL;
								const gchar* _tmp87_;
								_tmp86_ = _ ("Unknown property '%s' in linkable property list.");
								_tmp87_ = _data6_->prop_name;
								g_warning (_tmp86_, _tmp87_);
								block6_data_unref (_data6_);
								_data6_ = NULL;
								continue;
							}
							_tmp88_ = _data5_->persona;
							_tmp89_ = _data6_->prop_name;
							folks_persona_linkable_property_to_links (_tmp88_, _tmp89_, ________lambda65__folks_persona_linkable_property_callback, _data6_);
							block6_data_unref (_data6_);
							_data6_ = NULL;
						}
					}
				}
			}
			_tmp90_ = final_personas;
			_tmp91_ = _data5_->persona;
			gee_abstract_collection_add ((GeeAbstractCollection*) _tmp90_, _tmp91_);
			_tmp93_ = _data5_->candidate_inds;
			_tmp94_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp93_);
			_tmp95_ = _tmp94_;
			if (_tmp95_ > 0) {
				gboolean _tmp96_;
				_tmp96_ = self->priv->_linking_enabled;
				_tmp92_ = _tmp96_ == TRUE;
			} else {
				_tmp92_ = FALSE;
			}
			_tmp97_ = _tmp92_;
			if (_tmp97_) {
				{
					GeeIterator* _individual_it = NULL;
					GeeHashSet* _tmp98_;
					GeeIterator* _tmp99_ = NULL;
					_tmp98_ = _data5_->candidate_inds;
					_tmp99_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) _tmp98_);
					_individual_it = _tmp99_;
					while (TRUE) {
						GeeIterator* _tmp100_;
						gboolean _tmp101_ = FALSE;
						FolksIndividual* individual = NULL;
						GeeIterator* _tmp102_;
						gpointer _tmp103_ = NULL;
						GeeHashSet* _tmp104_;
						FolksIndividual* _tmp105_;
						GeeSet* _tmp106_;
						GeeSet* _tmp107_;
						_tmp100_ = _individual_it;
						_tmp101_ = gee_iterator_next (_tmp100_);
						if (!_tmp101_) {
							break;
						}
						_tmp102_ = _individual_it;
						_tmp103_ = gee_iterator_get (_tmp102_);
						individual = (FolksIndividual*) _tmp103_;
						_tmp104_ = final_personas;
						_tmp105_ = individual;
						_tmp106_ = folks_individual_get_personas (_tmp105_);
						_tmp107_ = _tmp106_;
						gee_collection_add_all ((GeeCollection*) _tmp104_, (GeeCollection*) _tmp107_);
						_g_object_unref0 (individual);
					}
					_g_object_unref0 (_individual_it);
				}
			} else {
				GeeHashSet* _tmp108_;
				gint _tmp109_;
				gint _tmp110_;
				_tmp108_ = _data5_->candidate_inds;
				_tmp109_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp108_);
				_tmp110_ = _tmp109_;
				if (_tmp110_ > 0) {
					g_debug ("individual-aggregator.vala:1215:     Linking disabled.");
				} else {
					g_debug ("individual-aggregator.vala:1219:     Did not find any candidate indivi" \
"duals.");
				}
			}
			_tmp111_ = final_personas;
			_tmp112_ = folks_individual_new ((GeeSet*) _tmp111_);
			final_individual = _tmp112_;
			_tmp113_ = final_individual;
			_tmp114_ = folks_individual_get_id (_tmp113_);
			_tmp115_ = _tmp114_;
			_tmp116_ = final_individual;
			g_debug ("individual-aggregator.vala:1224:     Created new individual '%s' (%p) " \
"with personas:", _tmp115_, _tmp116_);
			{
				GeeIterator* _p_it = NULL;
				GeeHashSet* _tmp117_;
				GeeIterator* _tmp118_ = NULL;
				_tmp117_ = final_personas;
				_tmp118_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) _tmp117_);
				_p_it = _tmp118_;
				while (TRUE) {
					GeeIterator* _tmp119_;
					gboolean _tmp120_ = FALSE;
					FolksPersona* p = NULL;
					GeeIterator* _tmp121_;
					gpointer _tmp122_ = NULL;
					FolksPersona* _tmp123_;
					const gchar* _tmp124_;
					const gchar* _tmp125_;
					FolksPersona* _tmp126_;
					FolksPersona* _tmp127_;
					FolksIndividual* _tmp128_;
					_tmp119_ = _p_it;
					_tmp120_ = gee_iterator_next (_tmp119_);
					if (!_tmp120_) {
						break;
					}
					_tmp121_ = _p_it;
					_tmp122_ = gee_iterator_get (_tmp121_);
					p = (FolksPersona*) _tmp122_;
					_tmp123_ = p;
					_tmp124_ = folks_persona_get_uid (_tmp123_);
					_tmp125_ = _tmp124_;
					_tmp126_ = p;
					g_debug ("individual-aggregator.vala:1228:         %s (%p)", _tmp125_, _tmp126_);
					_tmp127_ = p;
					_tmp128_ = final_individual;
					_folks_individual_aggregator_add_persona_to_link_map (self, _tmp127_, _tmp128_);
					_g_object_unref0 (p);
				}
				_g_object_unref0 (_p_it);
			}
			num_mappings_added = (guint) 0;
			{
				GeeIterator* _i_it = NULL;
				GeeHashSet* _tmp129_;
				GeeIterator* _tmp130_ = NULL;
				_tmp129_ = _data5_->candidate_inds;
				_tmp130_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) _tmp129_);
				_i_it = _tmp130_;
				while (TRUE) {
					GeeIterator* _tmp131_;
					gboolean _tmp132_ = FALSE;
					FolksIndividual* i = NULL;
					GeeIterator* _tmp133_;
					gpointer _tmp134_ = NULL;
					FolksIndividual* _tmp135_;
					GeeHashSet* transitive_updates = NULL;
					GeeHashSet* _tmp136_;
					GeeMapIterator* iter = NULL;
					GeeHashMultiMap* _tmp137_;
					GeeMapIterator* _tmp138_ = NULL;
					GeeHashSet* _tmp165_;
					gint _tmp166_;
					gint _tmp167_;
					_tmp131_ = _i_it;
					_tmp132_ = gee_iterator_next (_tmp131_);
					if (!_tmp132_) {
						break;
					}
					_tmp133_ = _i_it;
					_tmp134_ = gee_iterator_get (_tmp133_);
					i = (FolksIndividual*) _tmp134_;
					_tmp135_ = i;
					_folks_individual_aggregator_remove_individual_from_link_map (self, _tmp135_);
					_tmp136_ = gee_hash_set_new (FOLKS_TYPE_INDIVIDUAL, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL);
					transitive_updates = _tmp136_;
					_tmp137_ = *individuals_changes;
					_tmp138_ = gee_multi_map_map_iterator ((GeeMultiMap*) _tmp137_);
					iter = _tmp138_;
					while (TRUE) {
						GeeMapIterator* _tmp139_;
						gboolean _tmp140_ = FALSE;
						FolksIndividual* _tmp141_;
						GeeMapIterator* _tmp142_;
						gpointer _tmp143_ = NULL;
						FolksIndividual* _tmp144_;
						gboolean _tmp145_;
						_tmp139_ = iter;
						_tmp140_ = gee_map_iterator_next (_tmp139_);
						if (!_tmp140_) {
							break;
						}
						_tmp141_ = i;
						_tmp142_ = iter;
						_tmp143_ = gee_map_iterator_get_value (_tmp142_);
						_tmp144_ = (FolksIndividual*) _tmp143_;
						_tmp145_ = _tmp141_ == _tmp144_;
						_g_object_unref0 (_tmp144_);
						if (_tmp145_) {
							GeeHashSet* _tmp146_;
							GeeMapIterator* _tmp147_;
							gpointer _tmp148_ = NULL;
							FolksIndividual* _tmp149_;
							_tmp146_ = transitive_updates;
							_tmp147_ = iter;
							_tmp148_ = gee_map_iterator_get_key (_tmp147_);
							_tmp149_ = (FolksIndividual*) _tmp148_;
							gee_abstract_collection_add ((GeeAbstractCollection*) _tmp146_, _tmp149_);
							_g_object_unref0 (_tmp149_);
						}
					}
					{
						GeeIterator* _k_it = NULL;
						GeeHashSet* _tmp150_;
						GeeIterator* _tmp151_ = NULL;
						_tmp150_ = transitive_updates;
						_tmp151_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) _tmp150_);
						_k_it = _tmp151_;
						while (TRUE) {
							GeeIterator* _tmp152_;
							gboolean _tmp153_ = FALSE;
							FolksIndividual* k = NULL;
							GeeIterator* _tmp154_;
							gpointer _tmp155_ = NULL;
							GeeHashMultiMap* _tmp156_;
							FolksIndividual* _tmp157_;
							FolksIndividual* _tmp158_;
							gboolean _tmp159_ = FALSE;
							FolksIndividual* _tmp160_;
							_tmp152_ = _k_it;
							_tmp153_ = gee_iterator_next (_tmp152_);
							if (!_tmp153_) {
								break;
							}
							_tmp154_ = _k_it;
							_tmp155_ = gee_iterator_get (_tmp154_);
							k = (FolksIndividual*) _tmp155_;
							_tmp156_ = *individuals_changes;
							_tmp157_ = k;
							_tmp158_ = i;
							_tmp159_ = gee_multi_map_remove ((GeeMultiMap*) _tmp156_, _tmp157_, _tmp158_);
							_vala_assert (_tmp159_ == TRUE, "individuals_changes.remove (k, i) == true");
							_tmp160_ = k;
							if (_tmp160_ != NULL) {
								GeeHashMultiMap* _tmp161_;
								FolksIndividual* _tmp162_;
								FolksIndividual* _tmp163_;
								guint _tmp164_;
								_tmp161_ = *individuals_changes;
								_tmp162_ = k;
								_tmp163_ = final_individual;
								gee_multi_map_set ((GeeMultiMap*) _tmp161_, _tmp162_, _tmp163_);
								_tmp164_ = num_mappings_added;
								num_mappings_added = _tmp164_ + 1;
							}
							_g_object_unref0 (k);
						}
						_g_object_unref0 (_k_it);
					}
					_tmp165_ = transitive_updates;
					_tmp166_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp165_);
					_tmp167_ = _tmp166_;
					if (_tmp167_ == 0) {
						GeeHashMultiMap* _tmp168_;
						FolksIndividual* _tmp169_;
						FolksIndividual* _tmp170_;
						guint _tmp171_;
						_tmp168_ = *individuals_changes;
						_tmp169_ = i;
						_tmp170_ = final_individual;
						gee_multi_map_set ((GeeMultiMap*) _tmp168_, _tmp169_, _tmp170_);
						_tmp171_ = num_mappings_added;
						num_mappings_added = _tmp171_ + 1;
					}
					_g_object_unref0 (iter);
					_g_object_unref0 (transitive_updates);
					_g_object_unref0 (i);
				}
				_g_object_unref0 (_i_it);
			}
			_tmp172_ = num_mappings_added;
			if (_tmp172_ == ((guint) 0)) {
				GeeHashMultiMap* _tmp173_;
				FolksIndividual* _tmp174_;
				_tmp173_ = *individuals_changes;
				_tmp174_ = final_individual;
				gee_multi_map_set ((GeeMultiMap*) _tmp173_, NULL, _tmp174_);
			}
			_tmp175_ = final_individual;
			_tmp176_ = folks_individual_get_is_user (_tmp175_);
			_tmp177_ = _tmp176_;
			if (_tmp177_ == TRUE) {
				FolksIndividual* _tmp178_;
				FolksIndividual* _tmp179_;
				_tmp178_ = final_individual;
				_tmp179_ = _g_object_ref0 (_tmp178_);
				_g_object_unref0 (*user);
				*user = _tmp179_;
			}
			_g_object_unref0 (final_individual);
			_g_object_unref0 (final_personas);
			block5_data_unref (_data5_);
			_data5_ = NULL;
		}
		_g_object_unref0 (_persona_it);
	}
}


static void _folks_individual_aggregator_persona_linkable_property_changed_cb (FolksIndividualAggregator* self, GObject* obj, GParamSpec* pspec) {
	FolksPersona* persona = NULL;
	GObject* _tmp0_;
	FolksPersona* _tmp1_;
	const gchar* _tmp2_ = NULL;
	FolksPersona* _tmp3_;
	gboolean _tmp4_;
	gboolean _tmp5_;
	GParamSpec* _tmp6_;
	const gchar* _tmp7_;
	FolksPersona* _tmp8_;
	const gchar* _tmp9_;
	const gchar* _tmp10_;
	const gchar* _tmp11_;
	FolksPersona* _tmp12_;
	const gchar* _tmp13_;
	const gchar* _tmp14_;
	FolksSmallSet* persona_set = NULL;
	FolksSmallSet* _tmp15_;
	FolksPersona* _tmp16_;
	FolksPersona* _tmp17_;
	FolksPersonaStore* _tmp18_;
	FolksPersonaStore* _tmp19_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (obj != NULL);
	g_return_if_fail (pspec != NULL);
	_tmp0_ = obj;
	_tmp1_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (G_TYPE_CHECK_INSTANCE_TYPE (_tmp0_, FOLKS_TYPE_PERSONA) ? ((FolksPersona*) _tmp0_) : NULL, FOLKS_TYPE_PERSONA, FolksPersona));
	persona = _tmp1_;
	_tmp3_ = persona;
	_tmp4_ = folks_persona_get_is_user (_tmp3_);
	_tmp5_ = _tmp4_;
	if (_tmp5_) {
		_tmp2_ = "yes";
	} else {
		_tmp2_ = "no";
	}
	_tmp6_ = pspec;
	_tmp7_ = _tmp6_->name;
	_tmp8_ = persona;
	_tmp9_ = folks_persona_get_uid (_tmp8_);
	_tmp10_ = _tmp9_;
	_tmp11_ = _tmp2_;
	_tmp12_ = persona;
	_tmp13_ = folks_persona_get_iid (_tmp12_);
	_tmp14_ = _tmp13_;
	g_debug ("Linkable property '%s' changed for persona '%s' " "(is user: %s, IID: %s).", _tmp7_, _tmp10_, _tmp11_, _tmp14_);
	_tmp15_ = folks_small_set_new (FOLKS_TYPE_PERSONA, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL);
	persona_set = _tmp15_;
	_tmp16_ = persona;
	gee_abstract_collection_add ((GeeAbstractCollection*) persona_set, _tmp16_);
	_tmp17_ = persona;
	_tmp18_ = folks_persona_get_store (_tmp17_);
	_tmp19_ = _tmp18_;
	_folks_individual_aggregator_personas_changed_cb (self, _tmp19_, (GeeSet*) persona_set, (GeeSet*) persona_set, NULL, NULL, FOLKS_GROUP_DETAILS_CHANGE_REASON_NONE);
	_g_object_unref0 (persona_set);
	_g_object_unref0 (persona);
}


static void _folks_individual_aggregator_persona_anti_links_changed_cb (FolksIndividualAggregator* self, GObject* obj, GParamSpec* pspec) {
	FolksPersona* persona = NULL;
	GObject* _tmp0_;
	FolksPersona* _tmp1_;
	const gchar* _tmp2_ = NULL;
	FolksPersona* _tmp3_;
	gboolean _tmp4_;
	gboolean _tmp5_;
	FolksPersona* _tmp6_;
	const gchar* _tmp7_;
	const gchar* _tmp8_;
	const gchar* _tmp9_;
	FolksPersona* _tmp10_;
	const gchar* _tmp11_;
	const gchar* _tmp12_;
	FolksSmallSet* persona_set = NULL;
	FolksSmallSet* _tmp13_;
	FolksPersona* _tmp14_;
	FolksPersona* _tmp15_;
	FolksPersonaStore* _tmp16_;
	FolksPersonaStore* _tmp17_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (obj != NULL);
	g_return_if_fail (pspec != NULL);
	_tmp0_ = obj;
	_tmp1_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp0_, FOLKS_TYPE_PERSONA) ? ((FolksPersona*) _tmp0_) : NULL);
	persona = _tmp1_;
	_tmp3_ = persona;
	_tmp4_ = folks_persona_get_is_user (_tmp3_);
	_tmp5_ = _tmp4_;
	if (_tmp5_) {
		_tmp2_ = "yes";
	} else {
		_tmp2_ = "no";
	}
	_tmp6_ = persona;
	_tmp7_ = folks_persona_get_uid (_tmp6_);
	_tmp8_ = _tmp7_;
	_tmp9_ = _tmp2_;
	_tmp10_ = persona;
	_tmp11_ = folks_persona_get_iid (_tmp10_);
	_tmp12_ = _tmp11_;
	g_debug ("individual-aggregator.vala:1322: Anti-links changed for persona '%s' (" \
"is user: %s, IID: %s).", _tmp8_, _tmp9_, _tmp12_);
	_tmp13_ = folks_small_set_new (FOLKS_TYPE_PERSONA, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL);
	persona_set = _tmp13_;
	_tmp14_ = persona;
	gee_abstract_collection_add ((GeeAbstractCollection*) persona_set, _tmp14_);
	_tmp15_ = persona;
	_tmp16_ = folks_persona_get_store (_tmp15_);
	_tmp17_ = _tmp16_;
	_folks_individual_aggregator_personas_changed_cb (self, _tmp17_, (GeeSet*) persona_set, (GeeSet*) persona_set, NULL, NULL, FOLKS_GROUP_DETAILS_CHANGE_REASON_NONE);
	_g_object_unref0 (persona_set);
	_g_object_unref0 (persona);
}


static void __folks_individual_aggregator_persona_linkable_property_changed_cb_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	_folks_individual_aggregator_persona_linkable_property_changed_cb (self, _sender, pspec);
}


static void __folks_individual_aggregator_persona_anti_links_changed_cb_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	_folks_individual_aggregator_persona_anti_links_changed_cb (self, _sender, pspec);
}


static void _folks_individual_aggregator_connect_to_persona (FolksIndividualAggregator* self, FolksPersona* persona) {
	FolksPersona* _tmp0_;
	gchar** _tmp1_;
	gint _tmp1__length1;
	gchar** _tmp2_;
	gint _tmp2__length1;
	FolksAntiLinkable* al = NULL;
	FolksPersona* _tmp7_;
	FolksAntiLinkable* _tmp8_;
	FolksAntiLinkable* _tmp9_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (persona != NULL);
	_tmp0_ = persona;
	_tmp1_ = folks_persona_get_linkable_properties (_tmp0_, &_tmp1__length1);
	_tmp2_ = _tmp1_;
	_tmp2__length1 = _tmp1__length1;
	{
		gchar** prop_name_collection = NULL;
		gint prop_name_collection_length1 = 0;
		gint _prop_name_collection_size_ = 0;
		gint prop_name_it = 0;
		prop_name_collection = _tmp2_;
		prop_name_collection_length1 = _tmp2__length1;
		for (prop_name_it = 0; prop_name_it < _tmp2__length1; prop_name_it = prop_name_it + 1) {
			gchar* _tmp3_;
			gchar* prop_name = NULL;
			_tmp3_ = g_strdup (prop_name_collection[prop_name_it]);
			prop_name = _tmp3_;
			{
				FolksPersona* _tmp4_;
				const gchar* _tmp5_;
				gchar* _tmp6_;
				_tmp4_ = persona;
				_tmp5_ = prop_name;
				_tmp6_ = g_strconcat ("notify::", _tmp5_, NULL);
				g_signal_connect_object ((GObject*) _tmp4_, _tmp6_, (GCallback) __folks_individual_aggregator_persona_linkable_property_changed_cb_g_object_notify, self, 0);
				_g_free0 (_tmp6_);
				_g_free0 (prop_name);
			}
		}
	}
	_tmp7_ = persona;
	_tmp8_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp7_, FOLKS_TYPE_ANTI_LINKABLE) ? ((FolksAntiLinkable*) _tmp7_) : NULL);
	al = _tmp8_;
	_tmp9_ = al;
	if (_tmp9_ != NULL) {
		FolksAntiLinkable* _tmp10_;
		_tmp10_ = al;
		g_signal_connect_object ((GObject*) _tmp10_, "notify::anti-links", (GCallback) __folks_individual_aggregator_persona_anti_links_changed_cb_g_object_notify, self, 0);
	}
	_g_object_unref0 (al);
}


static void _folks_individual_aggregator_disconnect_from_persona (FolksIndividualAggregator* self, FolksPersona* persona) {
	FolksAntiLinkable* al = NULL;
	FolksPersona* _tmp0_;
	FolksAntiLinkable* _tmp1_;
	FolksAntiLinkable* _tmp2_;
	FolksPersona* _tmp6_;
	gchar** _tmp7_;
	gint _tmp7__length1;
	gchar** _tmp8_;
	gint _tmp8__length1;
	g_return_if_fail (self != NULL);
	g_return_if_fail (persona != NULL);
	_tmp0_ = persona;
	_tmp1_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp0_, FOLKS_TYPE_ANTI_LINKABLE) ? ((FolksAntiLinkable*) _tmp0_) : NULL);
	al = _tmp1_;
	_tmp2_ = al;
	if (_tmp2_ != NULL) {
		FolksAntiLinkable* _tmp3_;
		guint _tmp4_ = 0U;
		GQuark _tmp5_ = 0U;
		_tmp3_ = al;
		g_signal_parse_name ("notify::anti-links", G_TYPE_OBJECT, &_tmp4_, &_tmp5_, TRUE);
		g_signal_handlers_disconnect_matched ((GObject*) _tmp3_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_DETAIL | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp4_, _tmp5_, NULL, (GCallback) __folks_individual_aggregator_persona_anti_links_changed_cb_g_object_notify, self);
	}
	_tmp6_ = persona;
	_tmp7_ = folks_persona_get_linkable_properties (_tmp6_, &_tmp7__length1);
	_tmp8_ = _tmp7_;
	_tmp8__length1 = _tmp7__length1;
	{
		gchar** prop_name_collection = NULL;
		gint prop_name_collection_length1 = 0;
		gint _prop_name_collection_size_ = 0;
		gint prop_name_it = 0;
		prop_name_collection = _tmp8_;
		prop_name_collection_length1 = _tmp8__length1;
		for (prop_name_it = 0; prop_name_it < _tmp8__length1; prop_name_it = prop_name_it + 1) {
			gchar* _tmp9_;
			gchar* prop_name = NULL;
			_tmp9_ = g_strdup (prop_name_collection[prop_name_it]);
			prop_name = _tmp9_;
			{
				FolksPersona* _tmp10_;
				const gchar* _tmp11_;
				gchar* _tmp12_;
				guint _tmp13_ = 0U;
				GQuark _tmp14_ = 0U;
				_tmp10_ = persona;
				_tmp11_ = prop_name;
				_tmp12_ = g_strconcat ("notify::", _tmp11_, NULL);
				g_signal_parse_name (_tmp12_, G_TYPE_OBJECT, &_tmp13_, &_tmp14_, TRUE);
				g_signal_handlers_disconnect_matched ((GObject*) _tmp10_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_DETAIL | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp13_, _tmp14_, NULL, (GCallback) __folks_individual_aggregator_persona_linkable_property_changed_cb_g_object_notify, self);
				_g_free0 (_tmp12_);
				_g_free0 (prop_name);
			}
		}
	}
	_g_object_unref0 (al);
}


static gpointer _g_ptr_array_ref0 (gpointer self) {
	return self ? g_ptr_array_ref (self) : NULL;
}


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void _folks_individual_aggregator_link_map_set (FolksIndividualAggregator* self, const gchar* key, FolksIndividual* individual) {
	GPtrArray* inds = NULL;
	GHashTable* _tmp0_;
	const gchar* _tmp1_;
	gconstpointer _tmp2_ = NULL;
	GPtrArray* _tmp3_;
	GPtrArray* _tmp4_;
	GPtrArray* _tmp22_;
	FolksIndividual* _tmp23_;
	FolksIndividual* _tmp24_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (key != NULL);
	g_return_if_fail (individual != NULL);
	_tmp0_ = self->priv->_link_map;
	_tmp1_ = key;
	_tmp2_ = g_hash_table_lookup (_tmp0_, _tmp1_);
	_tmp3_ = _g_ptr_array_ref0 ((GPtrArray*) _tmp2_);
	inds = _tmp3_;
	_tmp4_ = inds;
	if (_tmp4_ == NULL) {
		GPtrArray* _tmp5_;
		GHashTable* _tmp6_;
		const gchar* _tmp7_;
		gchar* _tmp8_;
		GPtrArray* _tmp9_;
		GPtrArray* _tmp10_;
		_tmp5_ = g_ptr_array_new_with_free_func (_g_object_unref0_);
		_g_ptr_array_unref0 (inds);
		inds = _tmp5_;
		_tmp6_ = self->priv->_link_map;
		_tmp7_ = key;
		_tmp8_ = g_strdup (_tmp7_);
		_tmp9_ = inds;
		_tmp10_ = _g_ptr_array_ref0 ((GPtrArray*) _tmp9_);
		g_hash_table_insert (_tmp6_, _tmp8_, _tmp10_);
	} else {
		{
			guint i = 0U;
			i = (guint) 0;
			{
				gboolean _tmp11_ = FALSE;
				_tmp11_ = TRUE;
				while (TRUE) {
					gboolean _tmp12_;
					guint _tmp14_;
					GPtrArray* _tmp15_;
					gint _tmp16_;
					gint _tmp17_;
					GPtrArray* _tmp18_;
					guint _tmp19_;
					gconstpointer _tmp20_ = NULL;
					FolksIndividual* _tmp21_;
					_tmp12_ = _tmp11_;
					if (!_tmp12_) {
						guint _tmp13_;
						_tmp13_ = i;
						i = _tmp13_ + 1;
					}
					_tmp11_ = FALSE;
					_tmp14_ = i;
					_tmp15_ = inds;
					_tmp16_ = g_ptr_array_get_length ((GPtrArray*) _tmp15_);
					_tmp17_ = _tmp16_;
					if (!(_tmp14_ < ((guint) _tmp17_))) {
						break;
					}
					_tmp18_ = inds;
					_tmp19_ = i;
					_tmp20_ = g_ptr_array_index ((GPtrArray*) _tmp18_, _tmp19_);
					_tmp21_ = individual;
					if (((FolksIndividual*) _tmp20_) == _tmp21_) {
						_g_ptr_array_unref0 (inds);
						return;
					}
				}
			}
		}
	}
	_tmp22_ = inds;
	_tmp23_ = individual;
	_tmp24_ = _g_object_ref0 (_tmp23_);
	g_ptr_array_add ((GPtrArray*) _tmp22_, _tmp24_);
	_g_ptr_array_unref0 (inds);
}


static Block7Data* block7_data_ref (Block7Data* _data7_) {
	g_atomic_int_inc (&_data7_->_ref_count_);
	return _data7_;
}


static void block7_data_unref (void * _userdata_) {
	Block7Data* _data7_;
	_data7_ = (Block7Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data7_->_ref_count_)) {
		FolksIndividualAggregator * self;
		self = _data7_->self;
		_g_object_unref0 (_data7_->individual);
		_g_object_unref0 (self);
		g_slice_free (Block7Data, _data7_);
	}
}


static void _____lambda66_ (Block7Data* _data7_, const gchar* l) {
	FolksIndividualAggregator * self;
	const gchar* prop_linking_value = NULL;
	const gchar* _tmp0_;
	FolksIndividual* _tmp1_;
	self = _data7_->self;
	g_return_if_fail (l != NULL);
	_tmp0_ = l;
	prop_linking_value = _tmp0_;
	g_debug ("individual-aggregator.vala:1427:             %s", prop_linking_value);
	_tmp1_ = _data7_->individual;
	_folks_individual_aggregator_link_map_set (self, prop_linking_value, _tmp1_);
}


static void ______lambda66__folks_persona_linkable_property_callback (const gchar* link, gpointer self) {
	_____lambda66_ (self, link);
}


static void _folks_individual_aggregator_add_persona_to_link_map (FolksIndividualAggregator* self, FolksPersona* persona, FolksIndividual* individual) {
	Block7Data* _data7_;
	FolksIndividual* _tmp0_;
	FolksIndividual* _tmp1_;
	const gchar* _tmp2_ = NULL;
	FolksPersona* _tmp3_;
	gboolean _tmp4_;
	gboolean _tmp5_;
	FolksPersona* _tmp6_;
	const gchar* _tmp7_;
	const gchar* _tmp8_;
	const gchar* _tmp9_;
	FolksPersona* _tmp10_;
	const gchar* _tmp11_;
	const gchar* _tmp12_;
	FolksIndividual* _tmp13_;
	const gchar* _tmp14_;
	const gchar* _tmp15_;
	FolksPersona* _tmp16_;
	const gchar* _tmp17_;
	const gchar* _tmp18_;
	FolksIndividual* _tmp19_;
	FolksPersona* _tmp20_;
	FolksPersonaStore* _tmp21_;
	FolksPersonaStore* _tmp22_;
	FolksPersonaStoreTrust _tmp23_;
	FolksPersonaStoreTrust _tmp24_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (persona != NULL);
	g_return_if_fail (individual != NULL);
	_data7_ = g_slice_new0 (Block7Data);
	_data7_->_ref_count_ = 1;
	_data7_->self = g_object_ref (self);
	_tmp0_ = individual;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (_data7_->individual);
	_data7_->individual = _tmp1_;
	_tmp3_ = persona;
	_tmp4_ = folks_persona_get_is_user (_tmp3_);
	_tmp5_ = _tmp4_;
	if (_tmp5_) {
		_tmp2_ = "yes";
	} else {
		_tmp2_ = "no";
	}
	_tmp6_ = persona;
	_tmp7_ = folks_persona_get_uid (_tmp6_);
	_tmp8_ = _tmp7_;
	_tmp9_ = _tmp2_;
	_tmp10_ = persona;
	_tmp11_ = folks_persona_get_iid (_tmp10_);
	_tmp12_ = _tmp11_;
	g_debug ("individual-aggregator.vala:1391: Connecting to Persona: %s (is user: %" \
"s, IID: %s)", _tmp8_, _tmp9_, _tmp12_);
	_tmp13_ = _data7_->individual;
	_tmp14_ = folks_individual_get_id (_tmp13_);
	_tmp15_ = _tmp14_;
	g_debug ("individual-aggregator.vala:1393:     Mapping to Individual: %s", _tmp15_);
	_tmp16_ = persona;
	_tmp17_ = folks_persona_get_iid (_tmp16_);
	_tmp18_ = _tmp17_;
	_tmp19_ = _data7_->individual;
	_folks_individual_aggregator_link_map_set (self, _tmp18_, _tmp19_);
	_tmp20_ = persona;
	_tmp21_ = folks_persona_get_store (_tmp20_);
	_tmp22_ = _tmp21_;
	_tmp23_ = folks_persona_store_get_trust_level (_tmp22_);
	_tmp24_ = _tmp23_;
	if (_tmp24_ == FOLKS_PERSONA_STORE_TRUST_FULL) {
		FolksPersona* _tmp25_;
		gchar** _tmp26_;
		gint _tmp26__length1;
		gchar** _tmp27_;
		gint _tmp27__length1;
		g_debug ("individual-aggregator.vala:1404:     Inserting links:");
		_tmp25_ = persona;
		_tmp26_ = folks_persona_get_linkable_properties (_tmp25_, &_tmp26__length1);
		_tmp27_ = _tmp26_;
		_tmp27__length1 = _tmp26__length1;
		{
			gchar** prop_name_collection = NULL;
			gint prop_name_collection_length1 = 0;
			gint _prop_name_collection_size_ = 0;
			gint prop_name_it = 0;
			prop_name_collection = _tmp27_;
			prop_name_collection_length1 = _tmp27__length1;
			for (prop_name_it = 0; prop_name_it < _tmp27__length1; prop_name_it = prop_name_it + 1) {
				const gchar* prop_name = NULL;
				prop_name = prop_name_collection[prop_name_it];
				{
					const gchar* _tmp28_;
					GObjectClass* pclass = NULL;
					FolksPersona* _tmp29_;
					GObjectClass* _tmp30_ = NULL;
					GObjectClass* _tmp31_;
					const gchar* _tmp32_;
					GParamSpec* _tmp33_ = NULL;
					FolksPersona* _tmp36_;
					const gchar* _tmp37_;
					_tmp28_ = prop_name;
					g_debug ("individual-aggregator.vala:1410:         %s", _tmp28_);
					_tmp29_ = persona;
					_tmp30_ = G_OBJECT_GET_CLASS ((GObject*) _tmp29_);
					pclass = _tmp30_;
					_tmp31_ = pclass;
					_tmp32_ = prop_name;
					_tmp33_ = g_object_class_find_property (_tmp31_, _tmp32_);
					if (_tmp33_ == NULL) {
						const gchar* _tmp34_ = NULL;
						const gchar* _tmp35_;
						_tmp34_ = _ ("Unknown property '%s' in linkable property list.");
						_tmp35_ = prop_name;
						g_warning (_tmp34_, _tmp35_);
						continue;
					}
					_tmp36_ = persona;
					_tmp37_ = prop_name;
					folks_persona_linkable_property_to_links (_tmp36_, _tmp37_, ______lambda66__folks_persona_linkable_property_callback, _data7_);
				}
			}
		}
	}
	block7_data_unref (_data7_);
	_data7_ = NULL;
}


static void _folks_individual_aggregator_remove_individual_from_link_map (FolksIndividualAggregator* self, FolksIndividual* individual) {
	FolksIndividual* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	GHashTableIter iter = {0};
	GHashTable* _tmp3_;
	const gchar* link_key = NULL;
	GPtrArray* inds = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (individual != NULL);
	_tmp0_ = individual;
	_tmp1_ = folks_individual_get_id (_tmp0_);
	_tmp2_ = _tmp1_;
	g_debug ("individual-aggregator.vala:1442: Removing Individual '%s' from the lin" \
"k map.", _tmp2_);
	_tmp3_ = self->priv->_link_map;
	g_hash_table_iter_init (&iter, _tmp3_);
	while (TRUE) {
		gconstpointer _tmp4_ = NULL;
		gconstpointer _tmp5_ = NULL;
		gboolean _tmp6_ = FALSE;
		_tmp6_ = g_hash_table_iter_next (&iter, &_tmp4_, &_tmp5_);
		link_key = _tmp4_;
		inds = _tmp5_;
		if (!_tmp6_) {
			break;
		}
		{
			guint i = 0U;
			i = (guint) 0;
			{
				gboolean _tmp7_ = FALSE;
				_tmp7_ = TRUE;
				while (TRUE) {
					gboolean _tmp8_;
					guint _tmp10_;
					GPtrArray* _tmp11_;
					gint _tmp12_;
					gint _tmp13_;
					GPtrArray* _tmp14_;
					guint _tmp15_;
					gconstpointer _tmp16_ = NULL;
					FolksIndividual* _tmp17_;
					_tmp8_ = _tmp7_;
					if (!_tmp8_) {
						guint _tmp9_;
						_tmp9_ = i;
						i = _tmp9_ + 1;
					}
					_tmp7_ = FALSE;
					_tmp10_ = i;
					_tmp11_ = inds;
					_tmp12_ = g_ptr_array_get_length (_tmp11_);
					_tmp13_ = _tmp12_;
					if (!(_tmp10_ < ((guint) _tmp13_))) {
						break;
					}
					_tmp14_ = inds;
					_tmp15_ = i;
					_tmp16_ = g_ptr_array_index (_tmp14_, _tmp15_);
					_tmp17_ = individual;
					if (((FolksIndividual*) _tmp16_) == _tmp17_) {
						const gchar* _tmp18_;
						FolksIndividual* _tmp19_;
						const gchar* _tmp20_;
						const gchar* _tmp21_;
						FolksIndividual* _tmp22_;
						GPtrArray* _tmp23_;
						guint _tmp24_;
						GPtrArray* _tmp25_;
						gint _tmp26_;
						gint _tmp27_;
						_tmp18_ = link_key;
						_tmp19_ = individual;
						_tmp20_ = folks_individual_get_id (_tmp19_);
						_tmp21_ = _tmp20_;
						_tmp22_ = individual;
						g_debug ("individual-aggregator.vala:1455:     %s  %s (%p)", _tmp18_, _tmp21_, _tmp22_);
						_tmp23_ = inds;
						_tmp24_ = i;
						g_ptr_array_remove_index_fast (_tmp23_, _tmp24_);
						_tmp25_ = inds;
						_tmp26_ = g_ptr_array_get_length (_tmp25_);
						_tmp27_ = _tmp26_;
						if (_tmp27_ == 0) {
							g_hash_table_iter_remove (&iter);
						}
						break;
					}
				}
			}
		}
	}
}


static void _folks_individual_aggregator_personas_changed_cb (FolksIndividualAggregator* self, FolksPersonaStore* store, GeeSet* added, GeeSet* removed, const gchar* message, FolksPersona* actor, FolksGroupDetailsChangeReason reason) {
	GeeHashSet* removed_individuals = NULL;
	GeeHashSet* _tmp0_;
	GeeHashMultiMap* individuals_changes = NULL;
	GeeHashMultiMap* _tmp1_;
	GeeHashSet* relinked_personas = NULL;
	GeeHashSet* _tmp2_;
	GeeHashMap* replaced_individuals = NULL;
	GeeHashMap* _tmp3_;
	FolksIndividual* user = NULL;
	FolksIndividual* _tmp4_;
	FolksIndividual* _tmp5_;
	GeeSet* _tmp85_;
	gint _tmp86_;
	gint _tmp87_;
	GeeHashSet* _tmp106_;
	FolksIndividual* _tmp142_;
	GeeHashMultiMap* _tmp143_;
	gint _tmp144_;
	gint _tmp145_;
	GeeMapIterator* iter = NULL;
	GeeHashMap* _tmp176_;
	GeeMapIterator* _tmp177_ = NULL;
	FolksDebug* _tmp194_;
	gboolean _tmp195_;
	gboolean _tmp196_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (store != NULL);
	g_return_if_fail (added != NULL);
	g_return_if_fail (removed != NULL);
	_tmp0_ = gee_hash_set_new (FOLKS_TYPE_INDIVIDUAL, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL);
	removed_individuals = _tmp0_;
	_tmp1_ = gee_hash_multi_map_new (FOLKS_TYPE_INDIVIDUAL, (GBoxedCopyFunc) g_object_ref, g_object_unref, FOLKS_TYPE_INDIVIDUAL, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	individuals_changes = _tmp1_;
	_tmp2_ = gee_hash_set_new (FOLKS_TYPE_PERSONA, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL);
	relinked_personas = _tmp2_;
	_tmp3_ = gee_hash_map_new (FOLKS_TYPE_INDIVIDUAL, (GBoxedCopyFunc) g_object_ref, g_object_unref, FOLKS_TYPE_INDIVIDUAL, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	replaced_individuals = _tmp3_;
	_tmp4_ = self->priv->_user;
	_tmp5_ = _g_object_ref0 (_tmp4_);
	user = _tmp5_;
	g_debug ("individual-aggregator.vala:1488: Removing Personas:");
	{
		GeeIterator* _persona_it = NULL;
		GeeSet* _tmp6_;
		GeeIterator* _tmp7_ = NULL;
		_tmp6_ = removed;
		_tmp7_ = gee_iterable_iterator ((GeeIterable*) _tmp6_);
		_persona_it = _tmp7_;
		while (TRUE) {
			GeeIterator* _tmp8_;
			gboolean _tmp9_ = FALSE;
			FolksPersona* persona = NULL;
			GeeIterator* _tmp10_;
			gpointer _tmp11_ = NULL;
			const gchar* _tmp12_ = NULL;
			FolksPersona* _tmp13_;
			gboolean _tmp14_;
			gboolean _tmp15_;
			FolksPersona* _tmp16_;
			const gchar* _tmp17_;
			const gchar* _tmp18_;
			const gchar* _tmp19_;
			FolksPersona* _tmp20_;
			const gchar* _tmp21_;
			const gchar* _tmp22_;
			FolksIndividual* ind = NULL;
			FolksPersona* _tmp23_;
			FolksIndividual* _tmp24_;
			FolksIndividual* _tmp25_;
			FolksIndividual* _tmp26_;
			FolksIndividual* _tmp27_;
			FolksPersona* _tmp30_;
			_tmp8_ = _persona_it;
			_tmp9_ = gee_iterator_next (_tmp8_);
			if (!_tmp9_) {
				break;
			}
			_tmp10_ = _persona_it;
			_tmp11_ = gee_iterator_get (_tmp10_);
			persona = (FolksPersona*) _tmp11_;
			_tmp13_ = persona;
			_tmp14_ = folks_persona_get_is_user (_tmp13_);
			_tmp15_ = _tmp14_;
			if (_tmp15_) {
				_tmp12_ = "yes";
			} else {
				_tmp12_ = "no";
			}
			_tmp16_ = persona;
			_tmp17_ = folks_persona_get_uid (_tmp16_);
			_tmp18_ = _tmp17_;
			_tmp19_ = _tmp12_;
			_tmp20_ = persona;
			_tmp21_ = folks_persona_get_iid (_tmp20_);
			_tmp22_ = _tmp21_;
			g_debug ("individual-aggregator.vala:1492:     %s (is user: %s, IID: %s)", _tmp18_, _tmp19_, _tmp22_);
			_tmp23_ = persona;
			_tmp24_ = folks_persona_get_individual (_tmp23_);
			_tmp25_ = _tmp24_;
			_tmp26_ = _g_object_ref0 (_tmp25_);
			ind = _tmp26_;
			_tmp27_ = ind;
			if (_tmp27_ != NULL) {
				GeeHashSet* _tmp28_;
				FolksIndividual* _tmp29_;
				_tmp28_ = removed_individuals;
				_tmp29_ = ind;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp28_, G_TYPE_CHECK_INSTANCE_CAST (_tmp29_, FOLKS_TYPE_INDIVIDUAL, FolksIndividual));
			}
			_tmp30_ = persona;
			_folks_individual_aggregator_disconnect_from_persona (self, _tmp30_);
			_g_object_unref0 (ind);
			_g_object_unref0 (persona);
		}
		_g_object_unref0 (_persona_it);
	}
	g_debug ("individual-aggregator.vala:1516: Removing Individuals due to removed l" \
"inks:");
	{
		GeeIterator* _individual_it = NULL;
		GeeHashSet* _tmp31_;
		GeeIterator* _tmp32_ = NULL;
		_tmp31_ = removed_individuals;
		_tmp32_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) _tmp31_);
		_individual_it = _tmp32_;
		while (TRUE) {
			GeeIterator* _tmp33_;
			gboolean _tmp34_ = FALSE;
			FolksIndividual* individual = NULL;
			GeeIterator* _tmp35_;
			gpointer _tmp36_ = NULL;
			GeeMap* _tmp37_;
			FolksIndividual* _tmp38_;
			const gchar* _tmp39_;
			const gchar* _tmp40_;
			gboolean _tmp41_ = FALSE;
			FolksIndividual* _tmp42_;
			const gchar* _tmp43_;
			const gchar* _tmp44_;
			FolksIndividual* _tmp63_;
			FolksIndividual* _tmp64_;
			FolksIndividual* _tmp65_;
			FolksIndividual* _tmp66_;
			_tmp33_ = _individual_it;
			_tmp34_ = gee_iterator_next (_tmp33_);
			if (!_tmp34_) {
				break;
			}
			_tmp35_ = _individual_it;
			_tmp36_ = gee_iterator_get (_tmp35_);
			individual = (FolksIndividual*) _tmp36_;
			_tmp37_ = self->priv->_individuals;
			_tmp38_ = individual;
			_tmp39_ = folks_individual_get_id (_tmp38_);
			_tmp40_ = _tmp39_;
			_tmp41_ = gee_map_has_key (_tmp37_, _tmp40_);
			if (_tmp41_ == FALSE) {
				_g_object_unref0 (individual);
				continue;
			}
			_tmp42_ = individual;
			_tmp43_ = folks_individual_get_id (_tmp42_);
			_tmp44_ = _tmp43_;
			g_debug ("individual-aggregator.vala:1523:     %s", _tmp44_);
			{
				GeeIterator* _persona_it = NULL;
				FolksIndividual* _tmp45_;
				GeeSet* _tmp46_;
				GeeSet* _tmp47_;
				GeeIterator* _tmp48_ = NULL;
				_tmp45_ = individual;
				_tmp46_ = folks_individual_get_personas (_tmp45_);
				_tmp47_ = _tmp46_;
				_tmp48_ = gee_iterable_iterator ((GeeIterable*) _tmp47_);
				_persona_it = _tmp48_;
				while (TRUE) {
					GeeIterator* _tmp49_;
					gboolean _tmp50_ = FALSE;
					FolksPersona* persona = NULL;
					GeeIterator* _tmp51_;
					gpointer _tmp52_ = NULL;
					gboolean _tmp53_ = FALSE;
					GeeSet* _tmp54_;
					FolksPersona* _tmp55_;
					gboolean _tmp56_ = FALSE;
					gboolean _tmp60_;
					GeeHashSet* _tmp61_;
					FolksPersona* _tmp62_;
					_tmp49_ = _persona_it;
					_tmp50_ = gee_iterator_next (_tmp49_);
					if (!_tmp50_) {
						break;
					}
					_tmp51_ = _persona_it;
					_tmp52_ = gee_iterator_get (_tmp51_);
					persona = (FolksPersona*) _tmp52_;
					_tmp54_ = removed;
					_tmp55_ = persona;
					_tmp56_ = gee_collection_contains ((GeeCollection*) _tmp54_, _tmp55_);
					if (_tmp56_ == TRUE) {
						_tmp53_ = TRUE;
					} else {
						GeeHashSet* _tmp57_;
						FolksPersona* _tmp58_;
						gboolean _tmp59_ = FALSE;
						_tmp57_ = relinked_personas;
						_tmp58_ = persona;
						_tmp59_ = gee_abstract_collection_contains ((GeeAbstractCollection*) _tmp57_, _tmp58_);
						_tmp53_ = _tmp59_ == TRUE;
					}
					_tmp60_ = _tmp53_;
					if (_tmp60_) {
						_g_object_unref0 (persona);
						continue;
					}
					_tmp61_ = relinked_personas;
					_tmp62_ = persona;
					gee_abstract_collection_add ((GeeAbstractCollection*) _tmp61_, _tmp62_);
					_g_object_unref0 (persona);
				}
				_g_object_unref0 (_persona_it);
			}
			_tmp63_ = user;
			_tmp64_ = individual;
			if (_tmp63_ == _tmp64_) {
				_g_object_unref0 (user);
				user = NULL;
			}
			_tmp65_ = individual;
			_folks_individual_aggregator_disconnect_from_individual (self, _tmp65_);
			_tmp66_ = individual;
			_folks_individual_aggregator_remove_individual_from_link_map (self, _tmp66_);
			_g_object_unref0 (individual);
		}
		_g_object_unref0 (_individual_it);
	}
	g_debug ("individual-aggregator.vala:1545: Adding Personas:");
	{
		GeeIterator* _persona_it = NULL;
		GeeSet* _tmp67_;
		GeeIterator* _tmp68_ = NULL;
		_tmp67_ = added;
		_tmp68_ = gee_iterable_iterator ((GeeIterable*) _tmp67_);
		_persona_it = _tmp68_;
		while (TRUE) {
			GeeIterator* _tmp69_;
			gboolean _tmp70_ = FALSE;
			FolksPersona* persona = NULL;
			GeeIterator* _tmp71_;
			gpointer _tmp72_ = NULL;
			const gchar* _tmp73_ = NULL;
			FolksPersona* _tmp74_;
			gboolean _tmp75_;
			gboolean _tmp76_;
			FolksPersona* _tmp77_;
			const gchar* _tmp78_;
			const gchar* _tmp79_;
			const gchar* _tmp80_;
			FolksPersona* _tmp81_;
			const gchar* _tmp82_;
			const gchar* _tmp83_;
			FolksPersona* _tmp84_;
			_tmp69_ = _persona_it;
			_tmp70_ = gee_iterator_next (_tmp69_);
			if (!_tmp70_) {
				break;
			}
			_tmp71_ = _persona_it;
			_tmp72_ = gee_iterator_get (_tmp71_);
			persona = (FolksPersona*) _tmp72_;
			_tmp74_ = persona;
			_tmp75_ = folks_persona_get_is_user (_tmp74_);
			_tmp76_ = _tmp75_;
			if (_tmp76_) {
				_tmp73_ = "yes";
			} else {
				_tmp73_ = "no";
			}
			_tmp77_ = persona;
			_tmp78_ = folks_persona_get_uid (_tmp77_);
			_tmp79_ = _tmp78_;
			_tmp80_ = _tmp73_;
			_tmp81_ = persona;
			_tmp82_ = folks_persona_get_iid (_tmp81_);
			_tmp83_ = _tmp82_;
			g_debug ("individual-aggregator.vala:1548:     %s (is user: %s, IID: %s)", _tmp79_, _tmp80_, _tmp83_);
			_tmp84_ = persona;
			_folks_individual_aggregator_connect_to_persona (self, _tmp84_);
			_g_object_unref0 (persona);
		}
		_g_object_unref0 (_persona_it);
	}
	_tmp85_ = added;
	_tmp86_ = gee_collection_get_size ((GeeCollection*) _tmp85_);
	_tmp87_ = _tmp86_;
	if (_tmp87_ > 0) {
		GeeSet* _tmp88_;
		_tmp88_ = added;
		_folks_individual_aggregator_add_personas (self, _tmp88_, &user, &individuals_changes);
	}
	g_debug ("individual-aggregator.vala:1561: Relinking Personas:");
	{
		GeeIterator* _persona_it = NULL;
		GeeHashSet* _tmp89_;
		GeeIterator* _tmp90_ = NULL;
		_tmp89_ = relinked_personas;
		_tmp90_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) _tmp89_);
		_persona_it = _tmp90_;
		while (TRUE) {
			GeeIterator* _tmp91_;
			gboolean _tmp92_ = FALSE;
			FolksPersona* persona = NULL;
			GeeIterator* _tmp93_;
			gpointer _tmp94_ = NULL;
			const gchar* _tmp95_ = NULL;
			FolksPersona* _tmp96_;
			gboolean _tmp97_;
			gboolean _tmp98_;
			FolksPersona* _tmp99_;
			const gchar* _tmp100_;
			const gchar* _tmp101_;
			const gchar* _tmp102_;
			FolksPersona* _tmp103_;
			const gchar* _tmp104_;
			const gchar* _tmp105_;
			_tmp91_ = _persona_it;
			_tmp92_ = gee_iterator_next (_tmp91_);
			if (!_tmp92_) {
				break;
			}
			_tmp93_ = _persona_it;
			_tmp94_ = gee_iterator_get (_tmp93_);
			persona = (FolksPersona*) _tmp94_;
			_tmp96_ = persona;
			_tmp97_ = folks_persona_get_is_user (_tmp96_);
			_tmp98_ = _tmp97_;
			if (_tmp98_) {
				_tmp95_ = "yes";
			} else {
				_tmp95_ = "no";
			}
			_tmp99_ = persona;
			_tmp100_ = folks_persona_get_uid (_tmp99_);
			_tmp101_ = _tmp100_;
			_tmp102_ = _tmp95_;
			_tmp103_ = persona;
			_tmp104_ = folks_persona_get_iid (_tmp103_);
			_tmp105_ = _tmp104_;
			g_debug ("individual-aggregator.vala:1564:     %s (is user: %s, IID: %s)", _tmp101_, _tmp102_, _tmp105_);
			_g_object_unref0 (persona);
		}
		_g_object_unref0 (_persona_it);
	}
	_tmp106_ = relinked_personas;
	_folks_individual_aggregator_add_personas (self, (GeeSet*) _tmp106_, &user, &individuals_changes);
	{
		GeeIterator* _individual_it = NULL;
		GeeHashSet* _tmp107_;
		GeeIterator* _tmp108_ = NULL;
		_tmp107_ = removed_individuals;
		_tmp108_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) _tmp107_);
		_individual_it = _tmp108_;
		while (TRUE) {
			GeeIterator* _tmp109_;
			gboolean _tmp110_ = FALSE;
			FolksIndividual* individual = NULL;
			GeeIterator* _tmp111_;
			gpointer _tmp112_ = NULL;
			gboolean added_mapping = FALSE;
			gboolean _tmp138_;
			FolksIndividual* _tmp141_;
			_tmp109_ = _individual_it;
			_tmp110_ = gee_iterator_next (_tmp109_);
			if (!_tmp110_) {
				break;
			}
			_tmp111_ = _individual_it;
			_tmp112_ = gee_iterator_get (_tmp111_);
			individual = (FolksIndividual*) _tmp112_;
			added_mapping = FALSE;
			{
				GeeIterator* _persona_it = NULL;
				FolksIndividual* _tmp113_;
				GeeSet* _tmp114_;
				GeeSet* _tmp115_;
				GeeIterator* _tmp116_ = NULL;
				_tmp113_ = individual;
				_tmp114_ = folks_individual_get_personas (_tmp113_);
				_tmp115_ = _tmp114_;
				_tmp116_ = gee_iterable_iterator ((GeeIterable*) _tmp115_);
				_persona_it = _tmp116_;
				while (TRUE) {
					GeeIterator* _tmp117_;
					gboolean _tmp118_ = FALSE;
					FolksPersona* persona = NULL;
					GeeIterator* _tmp119_;
					gpointer _tmp120_ = NULL;
					gboolean _tmp121_ = FALSE;
					GeeSet* _tmp122_;
					FolksPersona* _tmp123_;
					gboolean _tmp124_ = FALSE;
					gboolean _tmp128_;
					_tmp117_ = _persona_it;
					_tmp118_ = gee_iterator_next (_tmp117_);
					if (!_tmp118_) {
						break;
					}
					_tmp119_ = _persona_it;
					_tmp120_ = gee_iterator_get (_tmp119_);
					persona = (FolksPersona*) _tmp120_;
					_tmp122_ = removed;
					_tmp123_ = persona;
					_tmp124_ = gee_collection_contains ((GeeCollection*) _tmp122_, _tmp123_);
					if (!_tmp124_) {
						_tmp121_ = TRUE;
					} else {
						GeeSet* _tmp125_;
						FolksPersona* _tmp126_;
						gboolean _tmp127_ = FALSE;
						_tmp125_ = added;
						_tmp126_ = persona;
						_tmp127_ = gee_collection_contains ((GeeCollection*) _tmp125_, _tmp126_);
						_tmp121_ = _tmp127_;
					}
					_tmp128_ = _tmp121_;
					if (_tmp128_) {
						GeeHashMultiMap* _tmp129_;
						FolksPersona* _tmp130_;
						FolksIndividual* _tmp131_;
						FolksIndividual* _tmp132_;
						GeeHashMultiMap* _tmp133_;
						FolksIndividual* _tmp134_;
						FolksPersona* _tmp135_;
						FolksIndividual* _tmp136_;
						FolksIndividual* _tmp137_;
						_tmp129_ = individuals_changes;
						_tmp130_ = persona;
						_tmp131_ = folks_persona_get_individual (_tmp130_);
						_tmp132_ = _tmp131_;
						gee_multi_map_remove ((GeeMultiMap*) _tmp129_, NULL, _tmp132_);
						_tmp133_ = individuals_changes;
						_tmp134_ = individual;
						_tmp135_ = persona;
						_tmp136_ = folks_persona_get_individual (_tmp135_);
						_tmp137_ = _tmp136_;
						gee_multi_map_set ((GeeMultiMap*) _tmp133_, _tmp134_, _tmp137_);
						added_mapping = TRUE;
					}
					_g_object_unref0 (persona);
				}
				_g_object_unref0 (_persona_it);
			}
			_tmp138_ = added_mapping;
			if (_tmp138_ == FALSE) {
				GeeHashMultiMap* _tmp139_;
				FolksIndividual* _tmp140_;
				_tmp139_ = individuals_changes;
				_tmp140_ = individual;
				gee_multi_map_set ((GeeMultiMap*) _tmp139_, _tmp140_, NULL);
			}
			_tmp141_ = individual;
			folks_individual_set_personas (_tmp141_, NULL);
			_g_object_unref0 (individual);
		}
		_g_object_unref0 (_individual_it);
	}
	_tmp142_ = user;
	folks_individual_aggregator_set_user (self, _tmp142_);
	_tmp143_ = individuals_changes;
	_tmp144_ = gee_multi_map_get_size ((GeeMultiMap*) _tmp143_);
	_tmp145_ = _tmp144_;
	if (_tmp145_ > 0) {
		GeeHashSet* added_individuals = NULL;
		GeeHashSet* _tmp146_;
		GeeMapIterator* iter = NULL;
		GeeHashMultiMap* _tmp147_;
		GeeMapIterator* _tmp148_ = NULL;
		GeeHashSet* _tmp173_;
		GeeHashSet* _tmp174_;
		GeeHashMultiMap* _tmp175_;
		_tmp146_ = gee_hash_set_new (FOLKS_TYPE_INDIVIDUAL, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL);
		added_individuals = _tmp146_;
		_tmp147_ = individuals_changes;
		_tmp148_ = gee_multi_map_map_iterator ((GeeMultiMap*) _tmp147_);
		iter = _tmp148_;
		while (TRUE) {
			GeeMapIterator* _tmp149_;
			gboolean _tmp150_ = FALSE;
			FolksIndividual* old_ind = NULL;
			GeeMapIterator* _tmp151_;
			gpointer _tmp152_ = NULL;
			FolksIndividual* new_ind = NULL;
			GeeMapIterator* _tmp153_;
			gpointer _tmp154_ = NULL;
			gboolean _tmp155_ = FALSE;
			FolksIndividual* _tmp156_;
			gboolean _tmp158_;
			FolksIndividual* _tmp159_;
			FolksIndividual* _tmp162_;
			gboolean _tmp166_ = FALSE;
			FolksIndividual* _tmp167_;
			gboolean _tmp169_;
			_tmp149_ = iter;
			_tmp150_ = gee_map_iterator_next (_tmp149_);
			if (!_tmp150_) {
				break;
			}
			_tmp151_ = iter;
			_tmp152_ = gee_map_iterator_get_key (_tmp151_);
			old_ind = (FolksIndividual*) _tmp152_;
			_tmp153_ = iter;
			_tmp154_ = gee_map_iterator_get_value (_tmp153_);
			new_ind = (FolksIndividual*) _tmp154_;
			_tmp156_ = old_ind;
			if (_tmp156_ != NULL) {
				_tmp155_ = TRUE;
			} else {
				FolksIndividual* _tmp157_;
				_tmp157_ = new_ind;
				_tmp155_ = _tmp157_ != NULL;
			}
			_tmp158_ = _tmp155_;
			_vala_assert (_tmp158_, "old_ind != null || new_ind != null");
			_tmp159_ = old_ind;
			if (_tmp159_ != NULL) {
				GeeHashSet* _tmp160_;
				FolksIndividual* _tmp161_;
				_tmp160_ = removed_individuals;
				_tmp161_ = old_ind;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp160_, G_TYPE_CHECK_INSTANCE_CAST (_tmp161_, FOLKS_TYPE_INDIVIDUAL, FolksIndividual));
			}
			_tmp162_ = new_ind;
			if (_tmp162_ != NULL) {
				GeeHashSet* _tmp163_;
				FolksIndividual* _tmp164_;
				FolksIndividual* _tmp165_;
				_tmp163_ = added_individuals;
				_tmp164_ = new_ind;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp163_, G_TYPE_CHECK_INSTANCE_CAST (_tmp164_, FOLKS_TYPE_INDIVIDUAL, FolksIndividual));
				_tmp165_ = new_ind;
				_folks_individual_aggregator_connect_to_individual (self, G_TYPE_CHECK_INSTANCE_CAST (_tmp165_, FOLKS_TYPE_INDIVIDUAL, FolksIndividual));
			}
			_tmp167_ = old_ind;
			if (_tmp167_ != NULL) {
				FolksIndividual* _tmp168_;
				_tmp168_ = new_ind;
				_tmp166_ = _tmp168_ != NULL;
			} else {
				_tmp166_ = FALSE;
			}
			_tmp169_ = _tmp166_;
			if (_tmp169_) {
				GeeHashMap* _tmp170_;
				FolksIndividual* _tmp171_;
				FolksIndividual* _tmp172_;
				_tmp170_ = replaced_individuals;
				_tmp171_ = old_ind;
				_tmp172_ = new_ind;
				gee_abstract_map_set ((GeeAbstractMap*) _tmp170_, G_TYPE_CHECK_INSTANCE_CAST (_tmp171_, FOLKS_TYPE_INDIVIDUAL, FolksIndividual), G_TYPE_CHECK_INSTANCE_CAST (_tmp172_, FOLKS_TYPE_INDIVIDUAL, FolksIndividual));
			}
			_g_object_unref0 (new_ind);
			_g_object_unref0 (old_ind);
		}
		_tmp173_ = added_individuals;
		_tmp174_ = removed_individuals;
		_tmp175_ = individuals_changes;
		_folks_individual_aggregator_emit_individuals_changed (self, (GeeSet*) _tmp173_, (GeeSet*) _tmp174_, (GeeMultiMap*) _tmp175_, NULL, NULL, FOLKS_GROUP_DETAILS_CHANGE_REASON_NONE);
		_g_object_unref0 (iter);
		_g_object_unref0 (added_individuals);
	}
	g_debug ("individual-aggregator.vala:1639: Replacing Individuals due to linking:");
	_tmp176_ = replaced_individuals;
	_tmp177_ = gee_abstract_map_map_iterator ((GeeAbstractMap*) _tmp176_);
	iter = _tmp177_;
	while (TRUE) {
		GeeMapIterator* _tmp178_;
		gboolean _tmp179_ = FALSE;
		FolksIndividual* old_ind = NULL;
		GeeMapIterator* _tmp180_;
		gpointer _tmp181_ = NULL;
		FolksIndividual* new_ind = NULL;
		GeeMapIterator* _tmp182_;
		gpointer _tmp183_ = NULL;
		FolksIndividual* _tmp184_;
		const gchar* _tmp185_;
		const gchar* _tmp186_;
		FolksIndividual* _tmp187_;
		FolksIndividual* _tmp188_;
		const gchar* _tmp189_;
		const gchar* _tmp190_;
		FolksIndividual* _tmp191_;
		FolksIndividual* _tmp192_;
		FolksIndividual* _tmp193_;
		_tmp178_ = iter;
		_tmp179_ = gee_map_iterator_next (_tmp178_);
		if (!(_tmp179_ == TRUE)) {
			break;
		}
		_tmp180_ = iter;
		_tmp181_ = gee_map_iterator_get_key (_tmp180_);
		old_ind = (FolksIndividual*) _tmp181_;
		_tmp182_ = iter;
		_tmp183_ = gee_map_iterator_get_value (_tmp182_);
		new_ind = (FolksIndividual*) _tmp183_;
		_tmp184_ = old_ind;
		_tmp185_ = folks_individual_get_id (_tmp184_);
		_tmp186_ = _tmp185_;
		_tmp187_ = old_ind;
		_tmp188_ = new_ind;
		_tmp189_ = folks_individual_get_id (_tmp188_);
		_tmp190_ = _tmp189_;
		_tmp191_ = new_ind;
		g_debug ("individual-aggregator.vala:1646:     %s (%p)  %s (%p)", _tmp186_, _tmp187_, _tmp190_, _tmp191_);
		_tmp192_ = old_ind;
		_tmp193_ = new_ind;
		folks_individual_replace (_tmp192_, _tmp193_);
		_g_object_unref0 (new_ind);
		_g_object_unref0 (old_ind);
	}
	_tmp194_ = self->priv->_debug;
	_tmp195_ = folks_debug_get_debug_output_enabled (_tmp194_);
	_tmp196_ = _tmp195_;
	if (_tmp196_ == TRUE) {
		GHashTableIter link_map_iter = {0};
		GHashTable* _tmp197_;
		const gchar* link_key = NULL;
		GPtrArray* inds = NULL;
		_tmp197_ = self->priv->_link_map;
		g_hash_table_iter_init (&link_map_iter, _tmp197_);
		while (TRUE) {
			gconstpointer _tmp198_ = NULL;
			gconstpointer _tmp199_ = NULL;
			gboolean _tmp200_ = FALSE;
			_tmp200_ = g_hash_table_iter_next (&link_map_iter, &_tmp198_, &_tmp199_);
			link_key = _tmp198_;
			inds = _tmp199_;
			if (!_tmp200_) {
				break;
			}
			{
				guint i = 0U;
				i = (guint) 0;
				{
					gboolean _tmp201_ = FALSE;
					_tmp201_ = TRUE;
					while (TRUE) {
						gboolean _tmp202_;
						guint _tmp204_;
						GPtrArray* _tmp205_;
						gint _tmp206_;
						gint _tmp207_;
						FolksIndividual* individual = NULL;
						GPtrArray* _tmp208_;
						guint _tmp209_;
						gconstpointer _tmp210_ = NULL;
						FolksIndividual* _tmp211_;
						FolksIndividual* _tmp212_;
						GeeMap* _tmp213_;
						FolksIndividual* _tmp214_;
						const gchar* _tmp215_;
						const gchar* _tmp216_;
						gpointer _tmp217_ = NULL;
						FolksIndividual* _tmp218_;
						FolksIndividual* _tmp219_;
						gboolean _tmp220_;
						_tmp202_ = _tmp201_;
						if (!_tmp202_) {
							guint _tmp203_;
							_tmp203_ = i;
							i = _tmp203_ + 1;
						}
						_tmp201_ = FALSE;
						_tmp204_ = i;
						_tmp205_ = inds;
						_tmp206_ = g_ptr_array_get_length (_tmp205_);
						_tmp207_ = _tmp206_;
						if (!(_tmp204_ < ((guint) _tmp207_))) {
							break;
						}
						_tmp208_ = inds;
						_tmp209_ = i;
						_tmp210_ = g_ptr_array_index (_tmp208_, _tmp209_);
						_tmp211_ = _g_object_ref0 ((FolksIndividual*) _tmp210_);
						individual = _tmp211_;
						_tmp212_ = individual;
						_vala_assert (_tmp212_ != NULL, "individual != null");
						_tmp213_ = self->priv->_individuals;
						_tmp214_ = individual;
						_tmp215_ = folks_individual_get_id (_tmp214_);
						_tmp216_ = _tmp215_;
						_tmp217_ = gee_map_get (_tmp213_, _tmp216_);
						_tmp218_ = (FolksIndividual*) _tmp217_;
						_tmp219_ = individual;
						_tmp220_ = _tmp218_ != _tmp219_;
						_g_object_unref0 (_tmp218_);
						if (_tmp220_) {
							const gchar* _tmp221_;
							FolksIndividual* _tmp222_;
							const gchar* _tmp223_;
							const gchar* _tmp224_;
							FolksIndividual* _tmp225_;
							FolksIndividual* _tmp226_;
							const gchar* _tmp227_;
							const gchar* _tmp228_;
							FolksIndividual* _tmp229_;
							_tmp221_ = link_key;
							_tmp222_ = individual;
							_tmp223_ = folks_individual_get_id (_tmp222_);
							_tmp224_ = _tmp223_;
							_tmp225_ = individual;
							g_warning ("Link map contains invalid mapping:\n" "    %s  %s (%p)", _tmp221_, _tmp224_, _tmp225_);
							_tmp226_ = individual;
							_tmp227_ = folks_individual_get_id (_tmp226_);
							_tmp228_ = _tmp227_;
							_tmp229_ = individual;
							g_warning ("individual-aggregator.vala:1672: Individual %s (%p) personas:", _tmp228_, _tmp229_);
							{
								GeeIterator* _p_it = NULL;
								FolksIndividual* _tmp230_;
								GeeSet* _tmp231_;
								GeeSet* _tmp232_;
								GeeIterator* _tmp233_ = NULL;
								_tmp230_ = individual;
								_tmp231_ = folks_individual_get_personas (_tmp230_);
								_tmp232_ = _tmp231_;
								_tmp233_ = gee_iterable_iterator ((GeeIterable*) _tmp232_);
								_p_it = _tmp233_;
								while (TRUE) {
									GeeIterator* _tmp234_;
									gboolean _tmp235_ = FALSE;
									FolksPersona* p = NULL;
									GeeIterator* _tmp236_;
									gpointer _tmp237_ = NULL;
									FolksPersona* _tmp238_;
									const gchar* _tmp239_;
									const gchar* _tmp240_;
									FolksPersona* _tmp241_;
									_tmp234_ = _p_it;
									_tmp235_ = gee_iterator_next (_tmp234_);
									if (!_tmp235_) {
										break;
									}
									_tmp236_ = _p_it;
									_tmp237_ = gee_iterator_get (_tmp236_);
									p = (FolksPersona*) _tmp237_;
									_tmp238_ = p;
									_tmp239_ = folks_persona_get_uid (_tmp238_);
									_tmp240_ = _tmp239_;
									_tmp241_ = p;
									g_warning ("individual-aggregator.vala:1676:     %s (%p)", _tmp240_, _tmp241_);
									_g_object_unref0 (p);
								}
								_g_object_unref0 (_p_it);
							}
						}
						{
							guint j = 0U;
							guint _tmp242_;
							_tmp242_ = i;
							j = _tmp242_ + 1;
							{
								gboolean _tmp243_ = FALSE;
								_tmp243_ = TRUE;
								while (TRUE) {
									gboolean _tmp244_;
									guint _tmp246_;
									GPtrArray* _tmp247_;
									gint _tmp248_;
									gint _tmp249_;
									GPtrArray* _tmp250_;
									guint _tmp251_;
									gconstpointer _tmp252_ = NULL;
									GPtrArray* _tmp253_;
									guint _tmp254_;
									gconstpointer _tmp255_ = NULL;
									_tmp244_ = _tmp243_;
									if (!_tmp244_) {
										guint _tmp245_;
										_tmp245_ = j;
										j = _tmp245_ + 1;
									}
									_tmp243_ = FALSE;
									_tmp246_ = j;
									_tmp247_ = inds;
									_tmp248_ = g_ptr_array_get_length (_tmp247_);
									_tmp249_ = _tmp248_;
									if (!(_tmp246_ < ((guint) _tmp249_))) {
										break;
									}
									_tmp250_ = inds;
									_tmp251_ = i;
									_tmp252_ = g_ptr_array_index (_tmp250_, _tmp251_);
									_tmp253_ = inds;
									_tmp254_ = j;
									_tmp255_ = g_ptr_array_index (_tmp253_, _tmp254_);
									if (((FolksIndividual*) _tmp252_) == ((FolksIndividual*) _tmp255_)) {
										const gchar* _tmp256_;
										FolksIndividual* _tmp257_;
										const gchar* _tmp258_;
										const gchar* _tmp259_;
										FolksIndividual* _tmp260_;
										_tmp256_ = link_key;
										_tmp257_ = individual;
										_tmp258_ = folks_individual_get_id (_tmp257_);
										_tmp259_ = _tmp258_;
										_tmp260_ = individual;
										g_warning ("Link map contains non-unique " "Individual: %s  %s (%p) twice", _tmp256_, _tmp259_, _tmp260_);
									}
								}
							}
						}
						_g_object_unref0 (individual);
					}
				}
			}
		}
	}
	_g_object_unref0 (iter);
	_g_object_unref0 (user);
	_g_object_unref0 (replaced_individuals);
	_g_object_unref0 (relinked_personas);
	_g_object_unref0 (individuals_changes);
	_g_object_unref0 (removed_individuals);
}


static void _folks_individual_aggregator_is_primary_store_changed_cb (FolksIndividualAggregator* self, GObject* object, GParamSpec* pspec) {
	FolksPersonaStore* store = NULL;
	GObject* _tmp0_;
	FolksPersonaStore* _tmp1_;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	FolksPersonaStore* _tmp4_;
	gboolean _tmp5_;
	gboolean _tmp6_;
	gboolean _tmp9_;
	gboolean _tmp17_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (object != NULL);
	g_return_if_fail (pspec != NULL);
	_tmp0_ = object;
	_tmp1_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp0_, FOLKS_TYPE_PERSONA_STORE, FolksPersonaStore));
	store = _tmp1_;
	_tmp4_ = store;
	_tmp5_ = folks_persona_store_get_is_primary_store (_tmp4_);
	_tmp6_ = _tmp5_;
	if (_tmp6_ == TRUE) {
		FolksPersonaStore* _tmp7_;
		FolksPersonaStore* _tmp8_;
		_tmp7_ = store;
		_tmp8_ = self->priv->_primary_store;
		_tmp3_ = _tmp7_ == _tmp8_;
	} else {
		_tmp3_ = FALSE;
	}
	_tmp9_ = _tmp3_;
	if (_tmp9_) {
		_tmp2_ = TRUE;
	} else {
		gboolean _tmp10_ = FALSE;
		FolksPersonaStore* _tmp11_;
		gboolean _tmp12_;
		gboolean _tmp13_;
		gboolean _tmp16_;
		_tmp11_ = store;
		_tmp12_ = folks_persona_store_get_is_primary_store (_tmp11_);
		_tmp13_ = _tmp12_;
		if (_tmp13_ == FALSE) {
			FolksPersonaStore* _tmp14_;
			FolksPersonaStore* _tmp15_;
			_tmp14_ = store;
			_tmp15_ = self->priv->_primary_store;
			_tmp10_ = _tmp14_ != _tmp15_;
		} else {
			_tmp10_ = FALSE;
		}
		_tmp16_ = _tmp10_;
		_tmp2_ = _tmp16_;
	}
	_tmp17_ = _tmp2_;
	_vala_assert (_tmp17_, "(store.is_primary_store == true &&               store == this._primary_store) ||           (store.is_primary_store == false &&               store != this._primary_store)");
	_g_object_unref0 (store);
}


static void _folks_individual_aggregator_persona_store_is_quiescent_changed_cb (FolksIndividualAggregator* self, GObject* obj, GParamSpec* pspec) {
	guint _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (obj != NULL);
	g_return_if_fail (pspec != NULL);
	_tmp0_ = self->priv->_non_quiescent_persona_store_count;
	if (_tmp0_ > ((guint) 0)) {
		guint _tmp1_;
		_tmp1_ = self->priv->_non_quiescent_persona_store_count;
		self->priv->_non_quiescent_persona_store_count = _tmp1_ - 1;
		_folks_individual_aggregator_notify_if_is_quiescent (self);
	}
}


static void _folks_individual_aggregator_backend_is_quiescent_changed_cb (FolksIndividualAggregator* self, GObject* obj, GParamSpec* pspec) {
	guint _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (obj != NULL);
	g_return_if_fail (pspec != NULL);
	_tmp0_ = self->priv->_non_quiescent_backend_count;
	if (_tmp0_ > ((guint) 0)) {
		guint _tmp1_;
		_tmp1_ = self->priv->_non_quiescent_backend_count;
		self->priv->_non_quiescent_backend_count = _tmp1_ - 1;
		_folks_individual_aggregator_notify_if_is_quiescent (self);
	}
}


static void _folks_individual_aggregator_notify_if_is_quiescent (FolksIndividualAggregator* self) {
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	guint _tmp2_;
	gboolean _tmp4_;
	gboolean _tmp6_;
	g_return_if_fail (self != NULL);
	_tmp2_ = self->priv->_non_quiescent_backend_count;
	if (_tmp2_ == ((guint) 0)) {
		guint _tmp3_;
		_tmp3_ = self->priv->_non_quiescent_persona_store_count;
		_tmp1_ = _tmp3_ == ((guint) 0);
	} else {
		_tmp1_ = FALSE;
	}
	_tmp4_ = _tmp1_;
	if (_tmp4_) {
		gboolean _tmp5_;
		_tmp5_ = self->priv->_is_quiescent;
		_tmp0_ = _tmp5_ == FALSE;
	} else {
		_tmp0_ = FALSE;
	}
	_tmp6_ = _tmp0_;
	if (_tmp6_) {
		gboolean _tmp7_ = FALSE;
		const gchar* _tmp8_;
		gint _tmp9_;
		gint _tmp10_;
		gboolean _tmp12_;
		guint _tmp15_;
		_tmp8_ = self->priv->_configured_primary_store_type_id;
		_tmp9_ = strlen (_tmp8_);
		_tmp10_ = _tmp9_;
		if (_tmp10_ > 0) {
			FolksPersonaStore* _tmp11_;
			_tmp11_ = self->priv->_primary_store;
			_tmp7_ = _tmp11_ == NULL;
		} else {
			_tmp7_ = FALSE;
		}
		_tmp12_ = _tmp7_;
		if (_tmp12_) {
			const gchar* _tmp13_;
			const gchar* _tmp14_;
			_tmp13_ = self->priv->_configured_primary_store_type_id;
			_tmp14_ = self->priv->_configured_primary_store_id;
			g_warning ("Failed to find primary PersonaStore with type ID " "'%s' and ID '%s'.\n" "Individuals will not be linked properly " "and creating new links between Personas will not work.\n" "The configured primary PersonaStore's backend may not be " "installed. If you are unsure, check with your " "distribution.", _tmp13_, _tmp14_);
		}
		folks_internal_profiling_point ("reached quiescence in " "IndividualAggregator", NULL);
		self->priv->_is_quiescent = TRUE;
		g_object_notify ((GObject*) self, "is-quiescent");
		_tmp15_ = self->priv->_quiescent_timeout_id;
		if (_tmp15_ != ((guint) 0)) {
			guint _tmp16_;
			_tmp16_ = self->priv->_quiescent_timeout_id;
			g_source_remove (_tmp16_);
			self->priv->_quiescent_timeout_id = (guint) 0;
		}
	}
}


static gboolean _folks_individual_aggregator_quiescent_timeout_cb (FolksIndividualAggregator* self) {
	gboolean result = FALSE;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_is_quiescent;
	if (_tmp0_ == FALSE) {
		guint _tmp1_;
		guint _tmp2_;
		_tmp1_ = self->priv->_non_quiescent_backend_count;
		_tmp2_ = self->priv->_non_quiescent_persona_store_count;
		g_warning ("Failed to reach quiescence normally (%u backends and %u " "persona stores still haven't reached quiescence). Forcing " "IndividualAggregator quiescence due to reaching the timeout.", _tmp1_, _tmp2_);
		self->priv->_is_quiescent = TRUE;
		g_object_notify ((GObject*) self, "is-quiescent");
	}
	self->priv->_quiescent_timeout_id = (guint) 0;
	result = FALSE;
	return result;
}


static void _folks_individual_aggregator_persona_store_is_user_set_default_changed_cb (FolksIndividualAggregator* self, GObject* obj, GParamSpec* pspec) {
	FolksPersonaStore* store = NULL;
	GObject* _tmp0_;
	FolksPersonaStore* _tmp1_;
	FolksPersonaStore* _tmp2_;
	FolksPersonaStore* _tmp3_;
	const gchar* _tmp4_;
	const gchar* _tmp5_;
	FolksPersonaStore* _tmp6_;
	const gchar* _tmp7_;
	const gchar* _tmp8_;
	FolksPersonaStore* _tmp9_;
	gboolean _tmp10_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (obj != NULL);
	g_return_if_fail (pspec != NULL);
	_tmp0_ = obj;
	_tmp1_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp0_, FOLKS_TYPE_PERSONA_STORE, FolksPersonaStore));
	store = _tmp1_;
	_tmp2_ = store;
	_tmp3_ = store;
	_tmp4_ = folks_persona_store_get_type_id (_tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = store;
	_tmp7_ = folks_persona_store_get_id (_tmp6_);
	_tmp8_ = _tmp7_;
	g_debug ("PersonaStore.is-user-set-default changed for store %p " "(type ID: %s, ID: %s)", _tmp2_, _tmp5_, _tmp8_);
	_tmp9_ = store;
	_tmp10_ = _folks_individual_aggregator_maybe_configure_as_primary (self, _tmp9_);
	if (_tmp10_) {
		FolksPersonaStore* _tmp11_;
		_tmp11_ = store;
		_folks_individual_aggregator_set_primary_store (self, _tmp11_);
	}
	_g_object_unref0 (store);
}


static gboolean _folks_individual_aggregator_maybe_configure_as_primary (FolksIndividualAggregator* self, FolksPersonaStore* store) {
	gboolean result = FALSE;
	gboolean configured = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_;
	gboolean _tmp5_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (store != NULL, FALSE);
	g_debug ("individual-aggregator.vala:1795: _maybe_configure_as_primary()");
	configured = FALSE;
	_tmp1_ = self->priv->_user_configured_primary_store;
	if (!_tmp1_) {
		FolksPersonaStore* _tmp2_;
		gboolean _tmp3_;
		gboolean _tmp4_;
		_tmp2_ = store;
		_tmp3_ = folks_persona_store_get_is_user_set_default (_tmp2_);
		_tmp4_ = _tmp3_;
		_tmp0_ = _tmp4_;
	} else {
		_tmp0_ = FALSE;
	}
	_tmp5_ = _tmp0_;
	if (_tmp5_) {
		FolksPersonaStore* _tmp6_;
		const gchar* _tmp7_;
		const gchar* _tmp8_;
		FolksPersonaStore* _tmp9_;
		const gchar* _tmp10_;
		const gchar* _tmp11_;
		FolksPersonaStore* _tmp12_;
		const gchar* _tmp13_;
		const gchar* _tmp14_;
		gchar* _tmp15_;
		FolksPersonaStore* _tmp16_;
		const gchar* _tmp17_;
		const gchar* _tmp18_;
		gchar* _tmp19_;
		_tmp6_ = store;
		_tmp7_ = folks_persona_store_get_type_id (_tmp6_);
		_tmp8_ = _tmp7_;
		_tmp9_ = store;
		_tmp10_ = folks_persona_store_get_id (_tmp9_);
		_tmp11_ = _tmp10_;
		g_debug ("individual-aggregator.vala:1802: Setting primary store IDs to '%s' and" \
" '%s'.", _tmp8_, _tmp11_);
		_tmp12_ = store;
		_tmp13_ = folks_persona_store_get_type_id (_tmp12_);
		_tmp14_ = _tmp13_;
		_tmp15_ = g_strdup (_tmp14_);
		_g_free0 (self->priv->_configured_primary_store_type_id);
		self->priv->_configured_primary_store_type_id = _tmp15_;
		_tmp16_ = store;
		_tmp17_ = folks_persona_store_get_id (_tmp16_);
		_tmp18_ = _tmp17_;
		_tmp19_ = g_strdup (_tmp18_);
		_g_free0 (self->priv->_configured_primary_store_id);
		self->priv->_configured_primary_store_id = _tmp19_;
		configured = TRUE;
	}
	result = configured;
	return result;
}


static void _folks_individual_aggregator_individual_removed_cb (FolksIndividualAggregator* self, FolksIndividual* i, FolksIndividual* replacement) {
	FolksIndividual* _tmp0_;
	FolksIndividual* _tmp1_;
	GeeMap* _tmp2_;
	FolksIndividual* _tmp3_;
	const gchar* _tmp4_;
	const gchar* _tmp5_;
	gpointer _tmp6_ = NULL;
	FolksIndividual* _tmp7_;
	FolksIndividual* _tmp8_;
	gboolean _tmp9_;
	FolksIndividual* _tmp10_;
	FolksIndividual* _tmp20_;
	GeeSet* _tmp21_;
	GeeSet* _tmp22_;
	gint _tmp23_;
	gint _tmp24_;
	FolksIndividual* _tmp34_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (i != NULL);
	_tmp0_ = self->priv->_user;
	_tmp1_ = i;
	if (_tmp0_ == _tmp1_) {
		folks_individual_aggregator_set_user (self, NULL);
	}
	_tmp2_ = self->priv->_individuals;
	_tmp3_ = i;
	_tmp4_ = folks_individual_get_id (_tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = gee_map_get (_tmp2_, _tmp5_);
	_tmp7_ = (FolksIndividual*) _tmp6_;
	_tmp8_ = i;
	_tmp9_ = _tmp7_ != _tmp8_;
	_g_object_unref0 (_tmp7_);
	if (_tmp9_) {
		return;
	}
	_tmp10_ = replacement;
	if (_tmp10_ != NULL) {
		FolksIndividual* _tmp11_;
		const gchar* _tmp12_;
		const gchar* _tmp13_;
		FolksIndividual* _tmp14_;
		const gchar* _tmp15_;
		const gchar* _tmp16_;
		_tmp11_ = i;
		_tmp12_ = folks_individual_get_id (_tmp11_);
		_tmp13_ = _tmp12_;
		_tmp14_ = replacement;
		_tmp15_ = folks_individual_get_id (G_TYPE_CHECK_INSTANCE_CAST (_tmp14_, FOLKS_TYPE_INDIVIDUAL, FolksIndividual));
		_tmp16_ = _tmp15_;
		g_debug ("individual-aggregator.vala:1824: Individual '%s' removed (replaced by " \
"'%s')", _tmp13_, _tmp16_);
	} else {
		FolksIndividual* _tmp17_;
		const gchar* _tmp18_;
		const gchar* _tmp19_;
		_tmp17_ = i;
		_tmp18_ = folks_individual_get_id (_tmp17_);
		_tmp19_ = _tmp18_;
		g_debug ("individual-aggregator.vala:1829: Individual '%s' removed (not replaced" \
")", _tmp19_);
	}
	_tmp20_ = i;
	_tmp21_ = folks_individual_get_personas (_tmp20_);
	_tmp22_ = _tmp21_;
	_tmp23_ = gee_collection_get_size ((GeeCollection*) _tmp22_);
	_tmp24_ = _tmp23_;
	if (_tmp24_ > 0) {
		GeeHashMultiMap* changes = NULL;
		GeeHashMultiMap* _tmp25_;
		FolksSmallSet* individuals = NULL;
		FolksSmallSet* _tmp26_;
		FolksSmallSet* _tmp27_;
		FolksIndividual* _tmp28_;
		GeeHashMultiMap* _tmp29_;
		FolksIndividual* _tmp30_;
		FolksIndividual* _tmp31_;
		FolksSmallSet* _tmp32_;
		GeeHashMultiMap* _tmp33_;
		_tmp25_ = gee_hash_multi_map_new (FOLKS_TYPE_INDIVIDUAL, (GBoxedCopyFunc) g_object_ref, g_object_unref, FOLKS_TYPE_INDIVIDUAL, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
		changes = _tmp25_;
		_tmp26_ = folks_small_set_new (FOLKS_TYPE_INDIVIDUAL, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL);
		individuals = _tmp26_;
		_tmp27_ = individuals;
		_tmp28_ = i;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp27_, _tmp28_);
		_tmp29_ = changes;
		_tmp30_ = i;
		_tmp31_ = replacement;
		gee_multi_map_set ((GeeMultiMap*) _tmp29_, _tmp30_, _tmp31_);
		_tmp32_ = individuals;
		_tmp33_ = changes;
		_folks_individual_aggregator_emit_individuals_changed (self, NULL, (GeeSet*) _tmp32_, (GeeMultiMap*) _tmp33_, NULL, NULL, FOLKS_GROUP_DETAILS_CHANGE_REASON_NONE);
		_g_object_unref0 (individuals);
		_g_object_unref0 (changes);
	}
	_tmp34_ = i;
	_folks_individual_aggregator_disconnect_from_individual (self, _tmp34_);
}


static void folks_individual_aggregator_add_persona_from_details_data_free (gpointer _data) {
	FolksIndividualAggregatorAddPersonaFromDetailsData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->parent);
	_g_object_unref0 (_data_->persona_store);
	_g_hash_table_unref0 (_data_->details);
	_g_object_unref0 (_data_->result);
	_g_object_unref0 (_data_->self);
	g_slice_free (FolksIndividualAggregatorAddPersonaFromDetailsData, _data_);
}


static gpointer _g_hash_table_ref0 (gpointer self) {
	return self ? g_hash_table_ref (self) : NULL;
}


void folks_individual_aggregator_add_persona_from_details (FolksIndividualAggregator* self, FolksIndividual* parent, FolksPersonaStore* persona_store, GHashTable* details, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	FolksIndividualAggregatorAddPersonaFromDetailsData* _data_;
	FolksIndividualAggregator* _tmp0_;
	FolksIndividual* _tmp1_;
	FolksIndividual* _tmp2_;
	FolksPersonaStore* _tmp3_;
	FolksPersonaStore* _tmp4_;
	GHashTable* _tmp5_;
	GHashTable* _tmp6_;
	_data_ = g_slice_new0 (FolksIndividualAggregatorAddPersonaFromDetailsData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, folks_individual_aggregator_add_persona_from_details);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, folks_individual_aggregator_add_persona_from_details_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = parent;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	_g_object_unref0 (_data_->parent);
	_data_->parent = _tmp2_;
	_tmp3_ = persona_store;
	_tmp4_ = _g_object_ref0 (_tmp3_);
	_g_object_unref0 (_data_->persona_store);
	_data_->persona_store = _tmp4_;
	_tmp5_ = details;
	_tmp6_ = _g_hash_table_ref0 (_tmp5_);
	_g_hash_table_unref0 (_data_->details);
	_data_->details = _tmp6_;
	folks_individual_aggregator_add_persona_from_details_co (_data_);
}


FolksPersona* folks_individual_aggregator_add_persona_from_details_finish (FolksIndividualAggregator* self, GAsyncResult* _res_, GError** error) {
	FolksPersona* result;
	FolksIndividualAggregatorAddPersonaFromDetailsData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return NULL;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
	result = _data_->result;
	_data_->result = NULL;
	return result;
}


/**
   * Add a new persona in the given {@link PersonaStore} based on the
   * ``details`` provided.
   *
   * If the target store is offline, this function will throw
   * {@link IndividualAggregatorError.STORE_OFFLINE}. It's the responsibility of
   * the caller to cache details and re-try this function if it wishes to make
   * offline adds work.
   *
   * The details hash is a backend-specific mapping of key, value strings.
   * Common keys include:
   *
   *  * contact - service-specific contact ID
   *  * message - a user-readable message to pass to the persona being added
   *
   * If a {@link Persona} with the given details already exists in the store, no
   * error will be thrown and this function will return ``null``.
   *
   * @param parent an optional {@link Individual} to add the new {@link Persona}
   * to. This persona will be appended to its ordered list of personas.
   * @param persona_store the {@link PersonaStore} to add the persona to
   * @param details a key-value map of details to use in creating the new
   * {@link Persona}
   * @return the new {@link Persona} or ``null`` if the corresponding
   * {@link Persona} already existed. If non-``null``, the new {@link Persona}
   * will also be added to a new or existing {@link Individual} as necessary.
   * @throws IndividualAggregatorError.STORE_OFFLINE if the persona store was
   * offline
   * @throws IndividualAggregatorError.ADD_FAILED if any other error occurred
   * while adding the persona
   *
   * @since 0.3.5
   */
static void folks_individual_aggregator_add_persona_from_details_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	FolksIndividualAggregatorAddPersonaFromDetailsData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	folks_individual_aggregator_add_persona_from_details_co (_data_);
}


static gboolean folks_individual_aggregator_add_persona_from_details_co (FolksIndividualAggregatorAddPersonaFromDetailsData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->persona = NULL;
	{
		_data_->_tmp0_ = _data_->details;
		_data_->_tmp1_ = NULL;
		_data_->_tmp1_ = _folks_individual_aggregator_asv_copy (_data_->self, _data_->_tmp0_);
		_data_->details_copy = _data_->_tmp1_;
		_data_->_tmp3_ = _data_->persona_store;
		_data_->_tmp4_ = _data_->details_copy;
		_data_->_state_ = 1;
		folks_persona_store_add_persona_from_details (_data_->_tmp3_, _data_->_tmp4_, folks_individual_aggregator_add_persona_from_details_ready, _data_);
		return FALSE;
		_state_1:
		_data_->_tmp5_ = NULL;
		_data_->_tmp5_ = folks_persona_store_add_persona_from_details_finish (_data_->_tmp3_, _data_->_res_, &_data_->_inner_error_);
		_data_->_tmp2_ = _data_->_tmp5_;
		if (_data_->_inner_error_ != NULL) {
			_g_hash_table_unref0 (_data_->details_copy);
			if (_data_->_inner_error_->domain == FOLKS_PERSONA_STORE_ERROR) {
				goto __catch18_folks_persona_store_error;
			}
			_g_hash_table_unref0 (_data_->details_copy);
			_g_object_unref0 (_data_->persona);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
		_g_object_unref0 (_data_->persona);
		_data_->persona = _data_->_tmp2_;
		_g_hash_table_unref0 (_data_->details_copy);
	}
	goto __finally18;
	__catch18_folks_persona_store_error:
	{
		_data_->e = _data_->_inner_error_;
		_data_->_inner_error_ = NULL;
		_data_->_tmp6_ = _data_->e;
		if (g_error_matches (_data_->_tmp6_, FOLKS_PERSONA_STORE_ERROR, FOLKS_PERSONA_STORE_ERROR_STORE_OFFLINE)) {
			_data_->_tmp7_ = _data_->e;
			_data_->_tmp8_ = _data_->_tmp7_->message;
			_data_->_tmp9_ = g_error_new_literal (FOLKS_INDIVIDUAL_AGGREGATOR_ERROR, FOLKS_INDIVIDUAL_AGGREGATOR_ERROR_STORE_OFFLINE, _data_->_tmp8_);
			_data_->_inner_error_ = _data_->_tmp9_;
			_g_error_free0 (_data_->e);
			goto __finally18;
		} else {
			_data_->_tmp10_ = _data_->persona_store;
			_data_->_tmp11_ = folks_persona_store_get_type_id (_data_->_tmp10_);
			_data_->_tmp12_ = _data_->_tmp11_;
			_data_->_tmp13_ = _data_->persona_store;
			_data_->_tmp14_ = folks_persona_store_get_id (_data_->_tmp13_);
			_data_->_tmp15_ = _data_->_tmp14_;
			_data_->_tmp16_ = NULL;
			_data_->_tmp16_ = _folks_individual_aggregator_get_store_full_id (_data_->self, _data_->_tmp12_, _data_->_tmp15_);
			_data_->full_id = _data_->_tmp16_;
			_data_->_tmp17_ = NULL;
			_data_->_tmp17_ = _ ("Failed to add contact for persona store ID '%s': %s");
			_data_->_tmp18_ = _data_->full_id;
			_data_->_tmp19_ = _data_->e;
			_data_->_tmp20_ = _data_->_tmp19_->message;
			_data_->_tmp21_ = g_error_new (FOLKS_INDIVIDUAL_AGGREGATOR_ERROR, FOLKS_INDIVIDUAL_AGGREGATOR_ERROR_ADD_FAILED, _data_->_tmp17_, _data_->_tmp18_, _data_->_tmp20_);
			_data_->_inner_error_ = _data_->_tmp21_;
			_g_free0 (_data_->full_id);
			_g_error_free0 (_data_->e);
			goto __finally18;
		}
		_g_error_free0 (_data_->e);
	}
	__finally18:
	if (_data_->_inner_error_ != NULL) {
		if (_data_->_inner_error_->domain == FOLKS_INDIVIDUAL_AGGREGATOR_ERROR) {
			g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
			g_error_free (_data_->_inner_error_);
			_g_object_unref0 (_data_->persona);
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		} else {
			_g_object_unref0 (_data_->persona);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	_data_->_tmp23_ = _data_->parent;
	if (_data_->_tmp23_ != NULL) {
		_data_->_tmp24_ = _data_->persona;
		_data_->_tmp22_ = _data_->_tmp24_ != NULL;
	} else {
		_data_->_tmp22_ = FALSE;
	}
	_data_->_tmp25_ = _data_->_tmp22_;
	if (_data_->_tmp25_) {
		_data_->_tmp26_ = _data_->parent;
		_data_->_tmp27_ = folks_individual_get_personas (G_TYPE_CHECK_INSTANCE_CAST (_data_->_tmp26_, FOLKS_TYPE_INDIVIDUAL, FolksIndividual));
		_data_->_tmp28_ = _data_->_tmp27_;
		_data_->_tmp29_ = _data_->persona;
		gee_collection_add ((GeeCollection*) _data_->_tmp28_, G_TYPE_CHECK_INSTANCE_CAST (_data_->_tmp29_, FOLKS_TYPE_PERSONA, FolksPersona));
	}
	_data_->result = _data_->persona;
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
	_g_object_unref0 (_data_->persona);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static Block8Data* block8_data_ref (Block8Data* _data8_) {
	g_atomic_int_inc (&_data8_->_ref_count_);
	return _data8_;
}


static void block8_data_unref (void * _userdata_) {
	Block8Data* _data8_;
	_data8_ = (Block8Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data8_->_ref_count_)) {
		FolksIndividualAggregator * self;
		self = _data8_->self;
		_g_hash_table_unref0 (_data8_->retval);
		_g_object_unref0 (self);
		g_slice_free (Block8Data, _data8_);
	}
}


static void _g_free0_ (gpointer var) {
	var = (g_free (var), NULL);
}


static void _vala_GValue_free (GValue* self) {
	g_value_unset (self);
	g_free (self);
}


static void __vala_GValue_free0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (_vala_GValue_free (var), NULL));
}


static GValue* _g_value_dup (GValue* self) {
	return g_boxed_copy (G_TYPE_VALUE, self);
}


static gpointer __g_value_dup0 (gpointer self) {
	return self ? _g_value_dup (self) : NULL;
}


static void __lambda68_ (Block8Data* _data8_, const gchar* k, GValue* v) {
	FolksIndividualAggregator * self;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	GValue* _tmp2_;
	GValue* _tmp3_;
	self = _data8_->self;
	g_return_if_fail (k != NULL);
	_tmp0_ = k;
	_tmp1_ = g_strdup ((const gchar*) _tmp0_);
	_tmp2_ = v;
	_tmp3_ = __g_value_dup0 (_tmp2_);
	g_hash_table_insert (_data8_->retval, _tmp1_, _tmp3_);
}


static void ___lambda68__gh_func (gconstpointer key, gconstpointer value, gpointer self) {
	__lambda68_ (self, key, value);
}


static GHashTable* _folks_individual_aggregator_asv_copy (FolksIndividualAggregator* self, GHashTable* asv) {
	GHashTable* result = NULL;
	Block8Data* _data8_;
	GHashFunc _tmp0_;
	GEqualFunc _tmp1_;
	GHashTable* _tmp2_;
	GHashTable* _tmp3_;
	GHashTable* _tmp4_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (asv != NULL, NULL);
	_data8_ = g_slice_new0 (Block8Data);
	_data8_->_ref_count_ = 1;
	_data8_->self = g_object_ref (self);
	_tmp0_ = g_str_hash;
	_tmp1_ = g_str_equal;
	_tmp2_ = g_hash_table_new_full (_tmp0_, _tmp1_, _g_free0_, __vala_GValue_free0_);
	_data8_->retval = _tmp2_;
	_tmp3_ = asv;
	g_hash_table_foreach (_tmp3_, ___lambda68__gh_func, _data8_);
	_tmp4_ = _g_hash_table_ref0 (_data8_->retval);
	result = _tmp4_;
	block8_data_unref (_data8_);
	_data8_ = NULL;
	return result;
}


static void folks_individual_aggregator_remove_individual_data_free (gpointer _data) {
	FolksIndividualAggregatorRemoveIndividualData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->individual);
	_g_object_unref0 (_data_->self);
	g_slice_free (FolksIndividualAggregatorRemoveIndividualData, _data_);
}


void folks_individual_aggregator_remove_individual (FolksIndividualAggregator* self, FolksIndividual* individual, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	FolksIndividualAggregatorRemoveIndividualData* _data_;
	FolksIndividualAggregator* _tmp0_;
	FolksIndividual* _tmp1_;
	FolksIndividual* _tmp2_;
	_data_ = g_slice_new0 (FolksIndividualAggregatorRemoveIndividualData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, folks_individual_aggregator_remove_individual);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, folks_individual_aggregator_remove_individual_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = individual;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	_g_object_unref0 (_data_->individual);
	_data_->individual = _tmp2_;
	folks_individual_aggregator_remove_individual_co (_data_);
}


void folks_individual_aggregator_remove_individual_finish (FolksIndividualAggregator* self, GAsyncResult* _res_, GError** error) {
	FolksIndividualAggregatorRemoveIndividualData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


/**
   * Completely remove the individual and all of its personas from their
   * backing stores.
   *
   * This method is safe to call multiple times concurrently (for the same
   * individual or different individuals).
   *
   * @param individual the {@link Individual} to remove
   * @throws GLib.Error if removing the persona failed  this will be passed
   * through from {@link PersonaStore.remove_persona}
   *
   * @since 0.1.11
   */
static void folks_individual_aggregator_remove_individual_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	FolksIndividualAggregatorRemoveIndividualData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	folks_individual_aggregator_remove_individual_co (_data_);
}


static gboolean folks_individual_aggregator_remove_individual_co (FolksIndividualAggregatorRemoveIndividualData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = _data_->individual;
	_data_->_tmp1_ = folks_individual_get_personas (_data_->_tmp0_);
	_data_->_tmp2_ = _data_->_tmp1_;
	_data_->_tmp3_ = NULL;
	_data_->_tmp3_ = folks_small_set_copy ((GeeIterable*) _data_->_tmp2_, NULL, NULL, NULL, NULL, NULL, NULL);
	_data_->personas = _data_->_tmp3_;
	{
		_data_->_tmp4_ = _data_->personas;
		_data_->_tmp5_ = _g_object_ref0 (_data_->_tmp4_);
		_data_->_persona_list = _data_->_tmp5_;
		_data_->_tmp6_ = _data_->_persona_list;
		_data_->_tmp7_ = gee_collection_get_size ((GeeCollection*) _data_->_tmp6_);
		_data_->_tmp8_ = _data_->_tmp7_;
		_data_->_persona_size = _data_->_tmp8_;
		_data_->_persona_index = -1;
		while (TRUE) {
			_data_->_tmp9_ = _data_->_persona_index;
			_data_->_persona_index = _data_->_tmp9_ + 1;
			_data_->_tmp10_ = _data_->_persona_index;
			_data_->_tmp11_ = _data_->_persona_size;
			if (!(_data_->_tmp10_ < _data_->_tmp11_)) {
				break;
			}
			_data_->_tmp12_ = _data_->_persona_list;
			_data_->_tmp13_ = _data_->_persona_index;
			_data_->_tmp14_ = NULL;
			_data_->_tmp14_ = folks_small_set_get (_data_->_tmp12_, _data_->_tmp13_);
			_data_->_tmp15_ = _g_object_ref0 ((FolksPersona*) _data_->_tmp14_);
			_data_->persona = _data_->_tmp15_;
			_data_->_tmp16_ = _data_->persona;
			_data_->_tmp17_ = folks_persona_get_store (_data_->_tmp16_);
			_data_->_tmp18_ = _data_->_tmp17_;
			_data_->_tmp19_ = _data_->persona;
			_data_->_state_ = 1;
			folks_persona_store_remove_persona (_data_->_tmp18_, _data_->_tmp19_, folks_individual_aggregator_remove_individual_ready, _data_);
			return FALSE;
			_state_1:
			folks_persona_store_remove_persona_finish (_data_->_tmp18_, _data_->_res_, &_data_->_inner_error_);
			if (_data_->_inner_error_ != NULL) {
				g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
				g_error_free (_data_->_inner_error_);
				_g_object_unref0 (_data_->persona);
				_g_object_unref0 (_data_->_persona_list);
				_g_object_unref0 (_data_->personas);
				if (_data_->_state_ == 0) {
					g_simple_async_result_complete_in_idle (_data_->_async_result);
				} else {
					g_simple_async_result_complete (_data_->_async_result);
				}
				g_object_unref (_data_->_async_result);
				return FALSE;
			}
			_g_object_unref0 (_data_->persona);
		}
		_g_object_unref0 (_data_->_persona_list);
	}
	_g_object_unref0 (_data_->personas);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void folks_individual_aggregator_remove_persona_data_free (gpointer _data) {
	FolksIndividualAggregatorRemovePersonaData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->persona);
	_g_object_unref0 (_data_->self);
	g_slice_free (FolksIndividualAggregatorRemovePersonaData, _data_);
}


void folks_individual_aggregator_remove_persona (FolksIndividualAggregator* self, FolksPersona* persona, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	FolksIndividualAggregatorRemovePersonaData* _data_;
	FolksIndividualAggregator* _tmp0_;
	FolksPersona* _tmp1_;
	FolksPersona* _tmp2_;
	_data_ = g_slice_new0 (FolksIndividualAggregatorRemovePersonaData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, folks_individual_aggregator_remove_persona);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, folks_individual_aggregator_remove_persona_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = persona;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	_g_object_unref0 (_data_->persona);
	_data_->persona = _tmp2_;
	folks_individual_aggregator_remove_persona_co (_data_);
}


void folks_individual_aggregator_remove_persona_finish (FolksIndividualAggregator* self, GAsyncResult* _res_, GError** error) {
	FolksIndividualAggregatorRemovePersonaData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


/**
   * Completely remove the persona from its backing store.
   *
   * This will leave other personas in the same individual alone.
   *
   * This method is safe to call multiple times concurrently (for the same
   * persona or different personas).
   *
   * @param persona the {@link Persona} to remove
   * @throws GLib.Error if removing the persona failed  this will be passed
   * through from {@link PersonaStore.remove_persona}
   *
   * @since 0.1.11
   */
static void folks_individual_aggregator_remove_persona_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	FolksIndividualAggregatorRemovePersonaData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	folks_individual_aggregator_remove_persona_co (_data_);
}


static gboolean folks_individual_aggregator_remove_persona_co (FolksIndividualAggregatorRemovePersonaData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = _data_->persona;
	_data_->_tmp1_ = folks_persona_get_store (_data_->_tmp0_);
	_data_->_tmp2_ = _data_->_tmp1_;
	_data_->_tmp3_ = _data_->persona;
	_data_->_state_ = 1;
	folks_persona_store_remove_persona (_data_->_tmp2_, _data_->_tmp3_, folks_individual_aggregator_remove_persona_ready, _data_);
	return FALSE;
	_state_1:
	folks_persona_store_remove_persona_finish (_data_->_tmp2_, _data_->_res_, &_data_->_inner_error_);
	if (_data_->_inner_error_ != NULL) {
		g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
		g_error_free (_data_->_inner_error_);
		if (_data_->_state_ == 0) {
			g_simple_async_result_complete_in_idle (_data_->_async_result);
		} else {
			g_simple_async_result_complete (_data_->_async_result);
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void folks_individual_aggregator_link_personas_data_free (gpointer _data) {
	FolksIndividualAggregatorLinkPersonasData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->personas);
	_g_object_unref0 (_data_->self);
	g_slice_free (FolksIndividualAggregatorLinkPersonasData, _data_);
}


void folks_individual_aggregator_link_personas (FolksIndividualAggregator* self, GeeSet* personas, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	FolksIndividualAggregatorLinkPersonasData* _data_;
	FolksIndividualAggregator* _tmp0_;
	GeeSet* _tmp1_;
	GeeSet* _tmp2_;
	_data_ = g_slice_new0 (FolksIndividualAggregatorLinkPersonasData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, folks_individual_aggregator_link_personas);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, folks_individual_aggregator_link_personas_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = personas;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	_g_object_unref0 (_data_->personas);
	_data_->personas = _tmp2_;
	folks_individual_aggregator_link_personas_co (_data_);
}


void folks_individual_aggregator_link_personas_finish (FolksIndividualAggregator* self, GAsyncResult* _res_, GError** error) {
	FolksIndividualAggregatorLinkPersonasData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


/**
   * Link the given {@link Persona}s together.
   *
   * Create links between the given {@link Persona}s so that they form a single
   * {@link Individual}. The new {@link Individual} will be returned via the
   * {@link IndividualAggregator.individuals_changed} signal.
   *
   * Removal of the {@link Individual}s which the {@link Persona}s were in
   * before is signalled by {@link IndividualAggregator.individuals_changed} and
   * {@link Individual.removed}.
   *
   * This method is safe to call multiple times concurrently.
   *
   * @param personas the {@link Persona}s to be linked
   * @throws IndividualAggregatorError.NO_PRIMARY_STORE if no primary store has
   * been configured for the individual aggregator
   * @throws IndividualAggregatorError if adding the linking persona failed 
   * this will be passed through from
   * {@link IndividualAggregator.add_persona_from_details}
   *
   * @since 0.5.1
   */
static void folks_individual_aggregator_link_personas_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	FolksIndividualAggregatorLinkPersonasData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	folks_individual_aggregator_link_personas_co (_data_);
}


static gboolean folks_individual_aggregator_link_personas_co (FolksIndividualAggregatorLinkPersonasData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = _data_->self->priv->_primary_store;
	if (_data_->_tmp0_ == NULL) {
		_data_->_tmp1_ = NULL;
		_data_->_tmp1_ = _ ("Cant link personas with no primary store.");
		_data_->_tmp2_ = g_strconcat (_data_->_tmp1_, "\n", NULL);
		_data_->_tmp3_ = _data_->_tmp2_;
		_data_->_tmp4_ = NULL;
		_data_->_tmp4_ = _ ("Persona store %s:%s is configured as primary, but could not be found" \
" or failed to load.");
		_data_->_tmp5_ = g_strconcat (_data_->_tmp3_, _data_->_tmp4_, NULL);
		_data_->_tmp6_ = _data_->_tmp5_;
		_data_->_tmp7_ = g_strconcat (_data_->_tmp6_, "\n", NULL);
		_data_->_tmp8_ = _data_->_tmp7_;
		_data_->_tmp9_ = NULL;
		_data_->_tmp9_ = _ ("Check the relevant service is running, or change the default store in " \
"that service or using the %s GSettings key.");
		_data_->_tmp10_ = g_strconcat (_data_->_tmp8_, _data_->_tmp9_, NULL);
		_data_->_tmp11_ = _data_->_tmp10_;
		_data_->_tmp12_ = _data_->self->priv->_configured_primary_store_type_id;
		_data_->_tmp13_ = _data_->self->priv->_configured_primary_store_id;
		_data_->_tmp14_ = NULL;
		_data_->_tmp14_ = g_strdup_printf ("%s %s", FOLKS_INDIVIDUAL_AGGREGATOR__FOLKS_GSETTINGS_SCHEMA, FOLKS_INDIVIDUAL_AGGREGATOR__PRIMARY_STORE_CONFIG_KEY);
		_data_->_tmp15_ = _data_->_tmp14_;
		_data_->_tmp16_ = g_error_new (FOLKS_INDIVIDUAL_AGGREGATOR_ERROR, FOLKS_INDIVIDUAL_AGGREGATOR_ERROR_NO_PRIMARY_STORE, _data_->_tmp11_, _data_->_tmp12_, _data_->_tmp13_, _data_->_tmp15_);
		_data_->_tmp17_ = _data_->_tmp16_;
		_g_free0 (_data_->_tmp15_);
		_g_free0 (_data_->_tmp11_);
		_g_free0 (_data_->_tmp8_);
		_g_free0 (_data_->_tmp6_);
		_g_free0 (_data_->_tmp3_);
		_data_->_inner_error_ = _data_->_tmp17_;
		if (_data_->_inner_error_->domain == FOLKS_INDIVIDUAL_AGGREGATOR_ERROR) {
			g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
			g_error_free (_data_->_inner_error_);
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	_data_->_tmp18_ = _data_->personas;
	_data_->_tmp19_ = gee_collection_get_size ((GeeCollection*) _data_->_tmp18_);
	_data_->_tmp20_ = _data_->_tmp19_;
	if (_data_->_tmp20_ <= 1) {
		if (_data_->_state_ == 0) {
			g_simple_async_result_complete_in_idle (_data_->_async_result);
		} else {
			g_simple_async_result_complete (_data_->_async_result);
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->_tmp21_ = _data_->self->priv->_linking_enabled;
	if (_data_->_tmp21_ == FALSE) {
		g_debug ("individual-aggregator.vala:2017: Can't link Personas: linking disabled" \
".");
		if (_data_->_state_ == 0) {
			g_simple_async_result_complete_in_idle (_data_->_async_result);
		} else {
			g_simple_async_result_complete (_data_->_async_result);
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	{
		_data_->_tmp22_ = _data_->personas;
		_data_->_tmp23_ = NULL;
		_data_->_tmp23_ = gee_iterable_iterator ((GeeIterable*) _data_->_tmp22_);
		_data_->_p_it = _data_->_tmp23_;
		while (TRUE) {
			_data_->_tmp24_ = _data_->_p_it;
			_data_->_tmp25_ = FALSE;
			_data_->_tmp25_ = gee_iterator_next (_data_->_tmp24_);
			if (!_data_->_tmp25_) {
				break;
			}
			_data_->_tmp26_ = _data_->_p_it;
			_data_->_tmp27_ = NULL;
			_data_->_tmp27_ = gee_iterator_get (_data_->_tmp26_);
			_data_->p = (FolksPersona*) _data_->_tmp27_;
			_data_->_tmp28_ = _data_->p;
			_data_->_tmp29_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_data_->_tmp28_, FOLKS_TYPE_ANTI_LINKABLE) ? ((FolksAntiLinkable*) _data_->_tmp28_) : NULL);
			_data_->al = _data_->_tmp29_;
			_data_->_tmp30_ = _data_->al;
			if (_data_->_tmp30_ != NULL) {
				{
					_data_->_tmp31_ = _data_->al;
					_data_->_tmp32_ = _data_->personas;
					_data_->_state_ = 1;
					folks_anti_linkable_remove_anti_links (G_TYPE_CHECK_INSTANCE_CAST (_data_->_tmp31_, FOLKS_TYPE_ANTI_LINKABLE, FolksAntiLinkable), _data_->_tmp32_, folks_individual_aggregator_link_personas_ready, _data_);
					return FALSE;
					_state_1:
					folks_anti_linkable_remove_anti_links_finish (G_TYPE_CHECK_INSTANCE_CAST (_data_->_tmp31_, FOLKS_TYPE_ANTI_LINKABLE, FolksAntiLinkable), _data_->_res_, &_data_->_inner_error_);
					if (_data_->_inner_error_ != NULL) {
						if (_data_->_inner_error_->domain == FOLKS_PROPERTY_ERROR) {
							goto __catch19_folks_property_error;
						}
						_g_object_unref0 (_data_->al);
						_g_object_unref0 (_data_->p);
						_g_object_unref0 (_data_->_p_it);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
						g_clear_error (&_data_->_inner_error_);
						return FALSE;
					}
				}
				goto __finally19;
				__catch19_folks_property_error:
				{
					_data_->e = _data_->_inner_error_;
					_data_->_inner_error_ = NULL;
					_data_->_tmp33_ = NULL;
					_data_->_tmp33_ = _ ("Anti-links can't be removed between personas being linked.");
					_data_->_tmp34_ = g_error_new_literal (FOLKS_INDIVIDUAL_AGGREGATOR_ERROR, FOLKS_INDIVIDUAL_AGGREGATOR_ERROR_PROPERTY_NOT_WRITEABLE, _data_->_tmp33_);
					_data_->_inner_error_ = _data_->_tmp34_;
					_g_error_free0 (_data_->e);
					goto __finally19;
				}
				__finally19:
				if (_data_->_inner_error_ != NULL) {
					if (_data_->_inner_error_->domain == FOLKS_INDIVIDUAL_AGGREGATOR_ERROR) {
						g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
						g_error_free (_data_->_inner_error_);
						_g_object_unref0 (_data_->al);
						_g_object_unref0 (_data_->p);
						_g_object_unref0 (_data_->_p_it);
						if (_data_->_state_ == 0) {
							g_simple_async_result_complete_in_idle (_data_->_async_result);
						} else {
							g_simple_async_result_complete (_data_->_async_result);
						}
						g_object_unref (_data_->_async_result);
						return FALSE;
					} else {
						_g_object_unref0 (_data_->al);
						_g_object_unref0 (_data_->p);
						_g_object_unref0 (_data_->_p_it);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
						g_clear_error (&_data_->_inner_error_);
						return FALSE;
					}
				}
			}
			_g_object_unref0 (_data_->al);
			_g_object_unref0 (_data_->p);
		}
		_g_object_unref0 (_data_->_p_it);
	}
	_data_->_tmp35_ = _data_->self->priv->_primary_store;
	_data_->_tmp36_ = folks_persona_store_get_type_id (G_TYPE_CHECK_INSTANCE_CAST (_data_->_tmp35_, FOLKS_TYPE_PERSONA_STORE, FolksPersonaStore));
	_data_->_tmp37_ = _data_->_tmp36_;
	_data_->_tmp38_ = _data_->self->priv->_configured_primary_store_type_id;
	_vala_assert (g_strcmp0 (_data_->_tmp37_, _data_->_tmp38_) == 0, "((!) this._primary_store).type_id ==           this._configured_primary_store_type_id");
	_data_->_tmp39_ = _data_->personas;
	_data_->_tmp40_ = NULL;
	_data_->_tmp40_ = _folks_individual_aggregator_build_linking_details (_data_->self, _data_->_tmp39_);
	_data_->details = _data_->_tmp40_;
	_data_->_tmp41_ = _data_->self->priv->_primary_store;
	_data_->_tmp42_ = _data_->details;
	_data_->_state_ = 2;
	folks_individual_aggregator_add_persona_from_details (_data_->self, NULL, G_TYPE_CHECK_INSTANCE_CAST (_data_->_tmp41_, FOLKS_TYPE_PERSONA_STORE, FolksPersonaStore), _data_->_tmp42_, folks_individual_aggregator_link_personas_ready, _data_);
	return FALSE;
	_state_2:
	_data_->_tmp43_ = NULL;
	_data_->_tmp43_ = folks_individual_aggregator_add_persona_from_details_finish (_data_->self, _data_->_res_, &_data_->_inner_error_);
	_data_->_tmp44_ = _data_->_tmp43_;
	_g_object_unref0 (_data_->_tmp44_);
	if (_data_->_inner_error_ != NULL) {
		if (_data_->_inner_error_->domain == FOLKS_INDIVIDUAL_AGGREGATOR_ERROR) {
			g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
			g_error_free (_data_->_inner_error_);
			_g_hash_table_unref0 (_data_->details);
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		} else {
			_g_hash_table_unref0 (_data_->details);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	_g_hash_table_unref0 (_data_->details);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static guint _folks_abstract_field_details_hash_static_gee_hash_data_func (gconstpointer v, gpointer self) {
	guint result;
	result = folks_abstract_field_details_hash_static (v);
	return result;
}


static gboolean _folks_abstract_field_details_equal_static_gee_equal_data_func (gconstpointer a, gconstpointer b, gpointer self) {
	gboolean result;
	result = folks_abstract_field_details_equal_static (a, b);
	return result;
}


static GHashTable* _folks_individual_aggregator_build_linking_details (FolksIndividualAggregator* self, GeeSet* personas) {
	GHashTable* result = NULL;
	GeeHashMultiMap* protocols_addrs_set = NULL;
	GeeHashMultiMap* _tmp0_;
	GeeHashMultiMap* web_service_addrs_set = NULL;
	GeeHashMultiMap* _tmp1_;
	FolksSmallSet* local_ids = NULL;
	FolksSmallSet* _tmp2_;
	GHashTable* details = NULL;
	GHashFunc _tmp52_;
	GEqualFunc _tmp53_;
	GHashTable* _tmp54_;
	GeeHashMultiMap* _tmp55_;
	gint _tmp56_;
	gint _tmp57_;
	GeeHashMultiMap* _tmp66_;
	gint _tmp67_;
	gint _tmp68_;
	FolksSmallSet* _tmp77_;
	gint _tmp78_;
	gint _tmp79_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (personas != NULL, NULL);
	_tmp0_ = gee_hash_multi_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, FOLKS_TYPE_IM_FIELD_DETAILS, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL, _folks_abstract_field_details_hash_static_gee_hash_data_func, NULL, NULL, _folks_abstract_field_details_equal_static_gee_equal_data_func, NULL, NULL);
	protocols_addrs_set = _tmp0_;
	_tmp1_ = gee_hash_multi_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, FOLKS_TYPE_WEB_SERVICE_FIELD_DETAILS, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL, _folks_abstract_field_details_hash_static_gee_hash_data_func, NULL, NULL, _folks_abstract_field_details_equal_static_gee_equal_data_func, NULL, NULL);
	web_service_addrs_set = _tmp1_;
	_tmp2_ = folks_small_set_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL, NULL, NULL, NULL);
	local_ids = _tmp2_;
	{
		GeeIterator* _persona_it = NULL;
		GeeSet* _tmp3_;
		GeeIterator* _tmp4_ = NULL;
		_tmp3_ = personas;
		_tmp4_ = gee_iterable_iterator ((GeeIterable*) _tmp3_);
		_persona_it = _tmp4_;
		while (TRUE) {
			GeeIterator* _tmp5_;
			gboolean _tmp6_ = FALSE;
			FolksPersona* persona = NULL;
			GeeIterator* _tmp7_;
			gpointer _tmp8_ = NULL;
			FolksPersona* _tmp9_;
			FolksPersona* _tmp25_;
			FolksPersona* _tmp41_;
			_tmp5_ = _persona_it;
			_tmp6_ = gee_iterator_next (_tmp5_);
			if (!_tmp6_) {
				break;
			}
			_tmp7_ = _persona_it;
			_tmp8_ = gee_iterator_get (_tmp7_);
			persona = (FolksPersona*) _tmp8_;
			_tmp9_ = persona;
			if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp9_, FOLKS_TYPE_IM_DETAILS)) {
				FolksImDetails* im_details = NULL;
				FolksPersona* _tmp10_;
				FolksImDetails* _tmp11_;
				GeeMapIterator* iter = NULL;
				FolksImDetails* _tmp12_;
				GeeMultiMap* _tmp13_;
				GeeMultiMap* _tmp14_;
				GeeMapIterator* _tmp15_ = NULL;
				_tmp10_ = persona;
				_tmp11_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp10_, FOLKS_TYPE_IM_DETAILS, FolksImDetails));
				im_details = _tmp11_;
				_tmp12_ = im_details;
				_tmp13_ = folks_im_details_get_im_addresses (_tmp12_);
				_tmp14_ = _tmp13_;
				_tmp15_ = gee_multi_map_map_iterator (_tmp14_);
				iter = _tmp15_;
				while (TRUE) {
					GeeMapIterator* _tmp16_;
					gboolean _tmp17_ = FALSE;
					GeeHashMultiMap* _tmp18_;
					GeeMapIterator* _tmp19_;
					gpointer _tmp20_ = NULL;
					gchar* _tmp21_;
					GeeMapIterator* _tmp22_;
					gpointer _tmp23_ = NULL;
					FolksImFieldDetails* _tmp24_;
					_tmp16_ = iter;
					_tmp17_ = gee_map_iterator_next (_tmp16_);
					if (!_tmp17_) {
						break;
					}
					_tmp18_ = protocols_addrs_set;
					_tmp19_ = iter;
					_tmp20_ = gee_map_iterator_get_key (_tmp19_);
					_tmp21_ = (gchar*) _tmp20_;
					_tmp22_ = iter;
					_tmp23_ = gee_map_iterator_get_value (_tmp22_);
					_tmp24_ = (FolksImFieldDetails*) _tmp23_;
					gee_multi_map_set ((GeeMultiMap*) _tmp18_, _tmp21_, _tmp24_);
					_g_object_unref0 (_tmp24_);
					_g_free0 (_tmp21_);
				}
				_g_object_unref0 (iter);
				_g_object_unref0 (im_details);
			}
			_tmp25_ = persona;
			if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp25_, FOLKS_TYPE_WEB_SERVICE_DETAILS)) {
				FolksWebServiceDetails* ws_details = NULL;
				FolksPersona* _tmp26_;
				FolksWebServiceDetails* _tmp27_;
				GeeMapIterator* iter = NULL;
				FolksWebServiceDetails* _tmp28_;
				GeeMultiMap* _tmp29_;
				GeeMultiMap* _tmp30_;
				GeeMapIterator* _tmp31_ = NULL;
				_tmp26_ = persona;
				_tmp27_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp26_, FOLKS_TYPE_WEB_SERVICE_DETAILS, FolksWebServiceDetails));
				ws_details = _tmp27_;
				_tmp28_ = ws_details;
				_tmp29_ = folks_web_service_details_get_web_service_addresses (_tmp28_);
				_tmp30_ = _tmp29_;
				_tmp31_ = gee_multi_map_map_iterator (_tmp30_);
				iter = _tmp31_;
				while (TRUE) {
					GeeMapIterator* _tmp32_;
					gboolean _tmp33_ = FALSE;
					GeeHashMultiMap* _tmp34_;
					GeeMapIterator* _tmp35_;
					gpointer _tmp36_ = NULL;
					gchar* _tmp37_;
					GeeMapIterator* _tmp38_;
					gpointer _tmp39_ = NULL;
					FolksWebServiceFieldDetails* _tmp40_;
					_tmp32_ = iter;
					_tmp33_ = gee_map_iterator_next (_tmp32_);
					if (!_tmp33_) {
						break;
					}
					_tmp34_ = web_service_addrs_set;
					_tmp35_ = iter;
					_tmp36_ = gee_map_iterator_get_key (_tmp35_);
					_tmp37_ = (gchar*) _tmp36_;
					_tmp38_ = iter;
					_tmp39_ = gee_map_iterator_get_value (_tmp38_);
					_tmp40_ = (FolksWebServiceFieldDetails*) _tmp39_;
					gee_multi_map_set ((GeeMultiMap*) _tmp34_, _tmp37_, _tmp40_);
					_g_object_unref0 (_tmp40_);
					_g_free0 (_tmp37_);
				}
				_g_object_unref0 (iter);
				_g_object_unref0 (ws_details);
			}
			_tmp41_ = persona;
			if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp41_, FOLKS_TYPE_LOCAL_ID_DETAILS)) {
				{
					GeeIterator* _id_it = NULL;
					FolksPersona* _tmp42_;
					GeeSet* _tmp43_;
					GeeSet* _tmp44_;
					GeeIterator* _tmp45_ = NULL;
					_tmp42_ = persona;
					_tmp43_ = folks_local_id_details_get_local_ids (G_TYPE_CHECK_INSTANCE_CAST (_tmp42_, FOLKS_TYPE_LOCAL_ID_DETAILS, FolksLocalIdDetails));
					_tmp44_ = _tmp43_;
					_tmp45_ = gee_iterable_iterator ((GeeIterable*) _tmp44_);
					_id_it = _tmp45_;
					while (TRUE) {
						GeeIterator* _tmp46_;
						gboolean _tmp47_ = FALSE;
						gchar* id = NULL;
						GeeIterator* _tmp48_;
						gpointer _tmp49_ = NULL;
						FolksSmallSet* _tmp50_;
						const gchar* _tmp51_;
						_tmp46_ = _id_it;
						_tmp47_ = gee_iterator_next (_tmp46_);
						if (!_tmp47_) {
							break;
						}
						_tmp48_ = _id_it;
						_tmp49_ = gee_iterator_get (_tmp48_);
						id = (gchar*) _tmp49_;
						_tmp50_ = local_ids;
						_tmp51_ = id;
						gee_abstract_collection_add ((GeeAbstractCollection*) _tmp50_, _tmp51_);
						_g_free0 (id);
					}
					_g_object_unref0 (_id_it);
				}
			}
			_g_object_unref0 (persona);
		}
		_g_object_unref0 (_persona_it);
	}
	_tmp52_ = g_str_hash;
	_tmp53_ = g_str_equal;
	_tmp54_ = g_hash_table_new_full (_tmp52_, _tmp53_, _g_free0_, __vala_GValue_free0_);
	details = _tmp54_;
	_tmp55_ = protocols_addrs_set;
	_tmp56_ = gee_multi_map_get_size ((GeeMultiMap*) _tmp55_);
	_tmp57_ = _tmp56_;
	if (_tmp57_ > 0) {
		GValue im_addresses_value = {0};
		GValue _tmp58_ = {0};
		GeeHashMultiMap* _tmp59_;
		GHashTable* _tmp60_;
		const gchar* _tmp61_ = NULL;
		gchar* _tmp62_;
		GValue _tmp63_;
		GValue _tmp64_;
		GValue* _tmp65_;
		g_value_init (&_tmp58_, GEE_TYPE_MULTI_MAP);
		im_addresses_value = _tmp58_;
		_tmp59_ = protocols_addrs_set;
		g_value_set_object (&im_addresses_value, (GObject*) _tmp59_);
		_tmp60_ = details;
		_tmp61_ = folks_persona_store_detail_key (FOLKS_PERSONA_DETAIL_IM_ADDRESSES);
		_tmp62_ = g_strdup ((const gchar*) _tmp61_);
		_tmp63_ = im_addresses_value;
		_tmp64_ = _tmp63_;
		_tmp65_ = __g_value_dup0 (&_tmp64_);
		g_hash_table_insert (_tmp60_, _tmp62_, _tmp65_);
		G_IS_VALUE (&im_addresses_value) ? (g_value_unset (&im_addresses_value), NULL) : NULL;
	}
	_tmp66_ = web_service_addrs_set;
	_tmp67_ = gee_multi_map_get_size ((GeeMultiMap*) _tmp66_);
	_tmp68_ = _tmp67_;
	if (_tmp68_ > 0) {
		GValue web_service_addresses_value = {0};
		GValue _tmp69_ = {0};
		GeeHashMultiMap* _tmp70_;
		GHashTable* _tmp71_;
		const gchar* _tmp72_ = NULL;
		gchar* _tmp73_;
		GValue _tmp74_;
		GValue _tmp75_;
		GValue* _tmp76_;
		g_value_init (&_tmp69_, GEE_TYPE_MULTI_MAP);
		web_service_addresses_value = _tmp69_;
		_tmp70_ = web_service_addrs_set;
		g_value_set_object (&web_service_addresses_value, (GObject*) _tmp70_);
		_tmp71_ = details;
		_tmp72_ = folks_persona_store_detail_key (FOLKS_PERSONA_DETAIL_WEB_SERVICE_ADDRESSES);
		_tmp73_ = g_strdup ((const gchar*) _tmp72_);
		_tmp74_ = web_service_addresses_value;
		_tmp75_ = _tmp74_;
		_tmp76_ = __g_value_dup0 (&_tmp75_);
		g_hash_table_insert (_tmp71_, _tmp73_, _tmp76_);
		G_IS_VALUE (&web_service_addresses_value) ? (g_value_unset (&web_service_addresses_value), NULL) : NULL;
	}
	_tmp77_ = local_ids;
	_tmp78_ = gee_collection_get_size ((GeeCollection*) _tmp77_);
	_tmp79_ = _tmp78_;
	if (_tmp79_ > 0) {
		GValue local_ids_value = {0};
		GValue _tmp80_ = {0};
		FolksSmallSet* _tmp81_;
		GHashTable* _tmp82_;
		const gchar* _tmp83_ = NULL;
		gchar* _tmp84_;
		GValue _tmp85_;
		GValue _tmp86_;
		GValue* _tmp87_;
		g_value_init (&_tmp80_, GEE_TYPE_SET);
		local_ids_value = _tmp80_;
		_tmp81_ = local_ids;
		g_value_set_object (&local_ids_value, (GObject*) _tmp81_);
		_tmp82_ = details;
		_tmp83_ = folks_persona_store_detail_key (FOLKS_PERSONA_DETAIL_LOCAL_IDS);
		_tmp84_ = g_strdup ((const gchar*) _tmp83_);
		_tmp85_ = local_ids_value;
		_tmp86_ = _tmp85_;
		_tmp87_ = __g_value_dup0 (&_tmp86_);
		g_hash_table_insert (_tmp82_, _tmp84_, _tmp87_);
		G_IS_VALUE (&local_ids_value) ? (g_value_unset (&local_ids_value), NULL) : NULL;
	}
	result = details;
	_g_object_unref0 (local_ids);
	_g_object_unref0 (web_service_addrs_set);
	_g_object_unref0 (protocols_addrs_set);
	return result;
}


static void folks_individual_aggregator_unlink_individual_data_free (gpointer _data) {
	FolksIndividualAggregatorUnlinkIndividualData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->individual);
	_g_object_unref0 (_data_->self);
	g_slice_free (FolksIndividualAggregatorUnlinkIndividualData, _data_);
}


void folks_individual_aggregator_unlink_individual (FolksIndividualAggregator* self, FolksIndividual* individual, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	FolksIndividualAggregatorUnlinkIndividualData* _data_;
	FolksIndividualAggregator* _tmp0_;
	FolksIndividual* _tmp1_;
	FolksIndividual* _tmp2_;
	_data_ = g_slice_new0 (FolksIndividualAggregatorUnlinkIndividualData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, folks_individual_aggregator_unlink_individual);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, folks_individual_aggregator_unlink_individual_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = individual;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	_g_object_unref0 (_data_->individual);
	_data_->individual = _tmp2_;
	folks_individual_aggregator_unlink_individual_co (_data_);
}


void folks_individual_aggregator_unlink_individual_finish (FolksIndividualAggregator* self, GAsyncResult* _res_, GError** error) {
	FolksIndividualAggregatorUnlinkIndividualData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


/**
   * Unlinks the given {@link Individual} into its constituent {@link Persona}s.
   *
   * This completely unlinks the given {@link Individual}, destroying all of
   * its writeable {@link Persona}s.
   *
   * The {@link Individual}'s removal is signalled by
   * {@link IndividualAggregator.individuals_changed} and
   * {@link Individual.removed}.
   *
   * The {@link Persona}s comprising the {@link Individual} will be re-linked
   * into one or more new {@link Individual}s, depending on how much linking
   * data remains (typically only implicit links remain). The addition of these
   * new {@link Individual}s will be signalled by
   * {@link IndividualAggregator.individuals_changed}.
   *
   * This method is safe to call multiple times concurrently, although
   * concurrent calls for the same individual may result in duplicate personas
   * being created.
   *
   * @param individual the {@link Individual} to unlink
   * @throws GLib.Error if removing the linking persona failed  this will be
   * passed through from {@link PersonaStore.remove_persona}
   *
   * @since 0.1.13
   */
static void folks_individual_aggregator_unlink_individual_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	FolksIndividualAggregatorUnlinkIndividualData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	folks_individual_aggregator_unlink_individual_co (_data_);
}


static gboolean folks_individual_aggregator_unlink_individual_co (FolksIndividualAggregatorUnlinkIndividualData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = _data_->self->priv->_linking_enabled;
	if (_data_->_tmp0_ == FALSE) {
		_data_->_tmp1_ = _data_->individual;
		_data_->_tmp2_ = folks_individual_get_id (_data_->_tmp1_);
		_data_->_tmp3_ = _data_->_tmp2_;
		g_debug ("individual-aggregator.vala:2159: Can't unlink Individual '%s': linking" \
" disabled.", _data_->_tmp3_);
		if (_data_->_state_ == 0) {
			g_simple_async_result_complete_in_idle (_data_->_async_result);
		} else {
			g_simple_async_result_complete (_data_->_async_result);
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->_tmp4_ = _data_->individual;
	_data_->_tmp5_ = folks_individual_get_id (_data_->_tmp4_);
	_data_->_tmp6_ = _data_->_tmp5_;
	g_debug ("individual-aggregator.vala:2164: Unlinking Individual '%s':", _data_->_tmp6_);
	_data_->_tmp7_ = _data_->individual;
	_data_->_tmp8_ = folks_individual_get_personas (_data_->_tmp7_);
	_data_->_tmp9_ = _data_->_tmp8_;
	_data_->_tmp10_ = NULL;
	_data_->_tmp10_ = folks_small_set_copy ((GeeIterable*) _data_->_tmp9_, NULL, NULL, NULL, NULL, NULL, NULL);
	_data_->individual_personas = _data_->_tmp10_;
	g_debug ("individual-aggregator.vala:2180:     Inserting anti-links:");
	{
		_data_->_tmp11_ = _data_->individual_personas;
		_data_->_tmp12_ = _g_object_ref0 (_data_->_tmp11_);
		_data_->_pers_list = _data_->_tmp12_;
		_data_->_tmp13_ = _data_->_pers_list;
		_data_->_tmp14_ = gee_collection_get_size ((GeeCollection*) _data_->_tmp13_);
		_data_->_tmp15_ = _data_->_tmp14_;
		_data_->_pers_size = _data_->_tmp15_;
		_data_->_pers_index = -1;
		while (TRUE) {
			_data_->_tmp16_ = _data_->_pers_index;
			_data_->_pers_index = _data_->_tmp16_ + 1;
			_data_->_tmp17_ = _data_->_pers_index;
			_data_->_tmp18_ = _data_->_pers_size;
			if (!(_data_->_tmp17_ < _data_->_tmp18_)) {
				break;
			}
			_data_->_tmp19_ = _data_->_pers_list;
			_data_->_tmp20_ = _data_->_pers_index;
			_data_->_tmp21_ = NULL;
			_data_->_tmp21_ = folks_small_set_get (_data_->_tmp19_, _data_->_tmp20_);
			_data_->_tmp22_ = _g_object_ref0 ((FolksPersona*) _data_->_tmp21_);
			_data_->pers = _data_->_tmp22_;
			{
				_data_->_tmp23_ = folks_small_set_new (FOLKS_TYPE_PERSONA, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL);
				_data_->personas = _data_->_tmp23_;
				_data_->_tmp24_ = _data_->personas;
				_data_->_tmp25_ = _data_->pers;
				gee_abstract_collection_add ((GeeAbstractCollection*) _data_->_tmp24_, _data_->_tmp25_);
				_data_->_tmp26_ = _data_->pers;
				_data_->_tmp27_ = folks_persona_get_uid (_data_->_tmp26_);
				_data_->_tmp28_ = _data_->_tmp27_;
				_data_->_tmp29_ = _data_->pers;
				g_debug ("individual-aggregator.vala:2187:         Anti-linking persona '%s' (%p" \
")", _data_->_tmp28_, _data_->_tmp29_);
				_data_->_tmp30_ = _data_->personas;
				_data_->_state_ = 1;
				_folks_individual_aggregator_ensure_personas_property_writeable (_data_->self, (GeeSet*) _data_->_tmp30_, "anti-links", folks_individual_aggregator_unlink_individual_ready, _data_);
				return FALSE;
				_state_1:
				_data_->_tmp31_ = NULL;
				_data_->_tmp31_ = _folks_individual_aggregator_ensure_personas_property_writeable_finish (_data_->self, _data_->_res_, &_data_->_inner_error_);
				_data_->writeable_persona = _data_->_tmp31_;
				if (_data_->_inner_error_ != NULL) {
					_g_object_unref0 (_data_->personas);
					if (_data_->_inner_error_->domain == FOLKS_INDIVIDUAL_AGGREGATOR_ERROR) {
						goto __catch20_folks_individual_aggregator_error;
					}
					_g_object_unref0 (_data_->personas);
					_g_object_unref0 (_data_->pers);
					_g_object_unref0 (_data_->_pers_list);
					_g_object_unref0 (_data_->individual_personas);
					g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
					g_clear_error (&_data_->_inner_error_);
					return FALSE;
				}
				_data_->_tmp32_ = _data_->writeable_persona;
				_data_->_tmp33_ = folks_persona_get_uid (_data_->_tmp32_);
				_data_->_tmp34_ = _data_->_tmp33_;
				_data_->_tmp35_ = _data_->writeable_persona;
				g_debug ("individual-aggregator.vala:2192:         Writeable persona '%s' (%p)", _data_->_tmp34_, _data_->_tmp35_);
				_data_->_tmp36_ = _data_->individual_personas;
				_data_->_tmp37_ = NULL;
				_data_->_tmp37_ = folks_small_set_copy ((GeeIterable*) _data_->_tmp36_, NULL, NULL, NULL, NULL, NULL, NULL);
				_data_->anti_link_personas = _data_->_tmp37_;
				_data_->_tmp38_ = _data_->anti_link_personas;
				_data_->_tmp39_ = _data_->pers;
				gee_abstract_collection_remove ((GeeAbstractCollection*) _data_->_tmp38_, _data_->_tmp39_);
				_data_->_tmp40_ = _data_->writeable_persona;
				_data_->_tmp41_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_data_->_tmp40_, FOLKS_TYPE_ANTI_LINKABLE) ? ((FolksAntiLinkable*) _data_->_tmp40_) : NULL);
				_data_->al = _data_->_tmp41_;
				_data_->_tmp42_ = _data_->al;
				_vala_assert (_data_->_tmp42_ != NULL, "al != null");
				_data_->_tmp43_ = _data_->al;
				_data_->_tmp44_ = _data_->anti_link_personas;
				_data_->_state_ = 2;
				folks_anti_linkable_add_anti_links (G_TYPE_CHECK_INSTANCE_CAST (_data_->_tmp43_, FOLKS_TYPE_ANTI_LINKABLE, FolksAntiLinkable), (GeeSet*) _data_->_tmp44_, folks_individual_aggregator_unlink_individual_ready, _data_);
				return FALSE;
				_state_2:
				folks_anti_linkable_add_anti_links_finish (G_TYPE_CHECK_INSTANCE_CAST (_data_->_tmp43_, FOLKS_TYPE_ANTI_LINKABLE, FolksAntiLinkable), _data_->_res_, &_data_->_inner_error_);
				if (_data_->_inner_error_ != NULL) {
					_g_object_unref0 (_data_->al);
					_g_object_unref0 (_data_->anti_link_personas);
					_g_object_unref0 (_data_->writeable_persona);
					_g_object_unref0 (_data_->personas);
					if (_data_->_inner_error_->domain == FOLKS_INDIVIDUAL_AGGREGATOR_ERROR) {
						goto __catch20_folks_individual_aggregator_error;
					}
					goto __finally20;
				}
				g_debug ("individual-aggregator.vala:2202: ");
				_g_object_unref0 (_data_->al);
				_g_object_unref0 (_data_->anti_link_personas);
				_g_object_unref0 (_data_->writeable_persona);
				_g_object_unref0 (_data_->personas);
			}
			goto __finally20;
			__catch20_folks_individual_aggregator_error:
			{
				_data_->e1 = _data_->_inner_error_;
				_data_->_inner_error_ = NULL;
				_data_->_tmp45_ = _data_->e1;
				_data_->_tmp46_ = _data_->_tmp45_->message;
				g_debug ("    Failed to ensure anti-links property is writeable " "(continuing anyway): %s", _data_->_tmp46_);
				_g_error_free0 (_data_->e1);
			}
			__finally20:
			if (_data_->_inner_error_ != NULL) {
				g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
				g_error_free (_data_->_inner_error_);
				_g_object_unref0 (_data_->pers);
				_g_object_unref0 (_data_->_pers_list);
				_g_object_unref0 (_data_->individual_personas);
				if (_data_->_state_ == 0) {
					g_simple_async_result_complete_in_idle (_data_->_async_result);
				} else {
					g_simple_async_result_complete (_data_->_async_result);
				}
				g_object_unref (_data_->_async_result);
				return FALSE;
			}
			_g_object_unref0 (_data_->pers);
		}
		_g_object_unref0 (_data_->_pers_list);
	}
	_g_object_unref0 (_data_->individual_personas);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void folks_individual_aggregator_ensure_individual_property_writeable_data_free (gpointer _data) {
	FolksIndividualAggregatorEnsureIndividualPropertyWriteableData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->individual);
	_g_free0 (_data_->property_name);
	_g_object_unref0 (_data_->result);
	_g_object_unref0 (_data_->self);
	g_slice_free (FolksIndividualAggregatorEnsureIndividualPropertyWriteableData, _data_);
}


void folks_individual_aggregator_ensure_individual_property_writeable (FolksIndividualAggregator* self, FolksIndividual* individual, const gchar* property_name, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	FolksIndividualAggregatorEnsureIndividualPropertyWriteableData* _data_;
	FolksIndividualAggregator* _tmp0_;
	FolksIndividual* _tmp1_;
	FolksIndividual* _tmp2_;
	const gchar* _tmp3_;
	gchar* _tmp4_;
	_data_ = g_slice_new0 (FolksIndividualAggregatorEnsureIndividualPropertyWriteableData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, folks_individual_aggregator_ensure_individual_property_writeable);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, folks_individual_aggregator_ensure_individual_property_writeable_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = individual;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	_g_object_unref0 (_data_->individual);
	_data_->individual = _tmp2_;
	_tmp3_ = property_name;
	_tmp4_ = g_strdup (_tmp3_);
	_g_free0 (_data_->property_name);
	_data_->property_name = _tmp4_;
	folks_individual_aggregator_ensure_individual_property_writeable_co (_data_);
}


FolksPersona* folks_individual_aggregator_ensure_individual_property_writeable_finish (FolksIndividualAggregator* self, GAsyncResult* _res_, GError** error) {
	FolksPersona* result;
	FolksIndividualAggregatorEnsureIndividualPropertyWriteableData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return NULL;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
	result = _data_->result;
	_data_->result = NULL;
	return result;
}


/**
   * Ensure that the given property is writeable for the given
   * {@link Individual}.
   *
   * This makes sure that there is at least one {@link Persona} in the
   * individual which has ``property_name`` in its
   * {@link Persona.writeable_properties}. If no such persona exists in the
   * individual, a new one will be created and linked to the individual. (Note
   * that due to the design of the aggregator, this will result in the previous
   * individual being removed and replaced by a new one with the new persona;
   * listen to the {@link Individual.removed} signal to see the replacement.)
   *
   * It may not be possible to create a new persona which has the given property
   * as writeable. In that case, a
   * {@link IndividualAggregatorError.NO_PRIMARY_STORE} or
   * {@link IndividualAggregatorError.PROPERTY_NOT_WRITEABLE} error will be
   * thrown.
   *
   * This method is safe to call multiple times concurrently, although
   * concurrent calls for the same individual may result in duplicate personas
   * being created.
   *
   * @param individual the individual for which ``property_name`` should be
   * writeable
   * @param property_name the name of the property which needs to be writeable
   * (this should be in lower case using hyphens, e.g. web-service-addresses)
   * @return a persona (new or existing) which has the given property as
   * writeable
   * @throws IndividualAggregatorError.NO_PRIMARY_STORE if no primary store was
   * configured for this individual aggregator
   * @throws IndividualAggregatorError.PROPERTY_NOT_WRITEABLE if the given
   * ``property_name`` referred to a non-writeable property
   * @throws IndividualAggregatorError if adding a new persona (using
   * {@link IndividualAggregator.add_persona_from_details}) failed, or if
   * linking personas (using {@link IndividualAggregator.link_personas}) failed
   *
   * @since 0.6.2
   */
static void folks_individual_aggregator_ensure_individual_property_writeable_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	FolksIndividualAggregatorEnsureIndividualPropertyWriteableData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	folks_individual_aggregator_ensure_individual_property_writeable_co (_data_);
}


static gboolean folks_individual_aggregator_ensure_individual_property_writeable_co (FolksIndividualAggregatorEnsureIndividualPropertyWriteableData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = _data_->individual;
	_data_->_tmp1_ = folks_individual_get_id (_data_->_tmp0_);
	_data_->_tmp2_ = _data_->_tmp1_;
	_data_->_tmp3_ = _data_->property_name;
	g_debug ("individual-aggregator.vala:2254: ensure_individual_property_writeable:" \
" %s, %s", _data_->_tmp2_, _data_->_tmp3_);
	_data_->_tmp4_ = _data_->individual;
	_data_->_tmp5_ = folks_individual_get_personas (_data_->_tmp4_);
	_data_->_tmp6_ = _data_->_tmp5_;
	_data_->_tmp7_ = _data_->property_name;
	_data_->_state_ = 1;
	_folks_individual_aggregator_ensure_personas_property_writeable (_data_->self, _data_->_tmp6_, _data_->_tmp7_, folks_individual_aggregator_ensure_individual_property_writeable_ready, _data_);
	return FALSE;
	_state_1:
	_data_->_tmp8_ = NULL;
	_data_->_tmp8_ = _folks_individual_aggregator_ensure_personas_property_writeable_finish (_data_->self, _data_->_res_, &_data_->_inner_error_);
	_data_->p = _data_->_tmp8_;
	if (_data_->_inner_error_ != NULL) {
		if (_data_->_inner_error_->domain == FOLKS_INDIVIDUAL_AGGREGATOR_ERROR) {
			g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
			g_error_free (_data_->_inner_error_);
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	_data_->result = _data_->p;
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
	_g_object_unref0 (_data_->p);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void _folks_individual_aggregator_ensure_personas_property_writeable_data_free (gpointer _data) {
	FolksIndividualAggregatorEnsurePersonasPropertyWriteableData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->personas);
	_g_free0 (_data_->property_name);
	_g_object_unref0 (_data_->result);
	_g_object_unref0 (_data_->self);
	g_slice_free (FolksIndividualAggregatorEnsurePersonasPropertyWriteableData, _data_);
}


static void _folks_individual_aggregator_ensure_personas_property_writeable (FolksIndividualAggregator* self, GeeSet* personas, const gchar* property_name, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	FolksIndividualAggregatorEnsurePersonasPropertyWriteableData* _data_;
	FolksIndividualAggregator* _tmp0_;
	GeeSet* _tmp1_;
	GeeSet* _tmp2_;
	const gchar* _tmp3_;
	gchar* _tmp4_;
	_data_ = g_slice_new0 (FolksIndividualAggregatorEnsurePersonasPropertyWriteableData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, _folks_individual_aggregator_ensure_personas_property_writeable);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, _folks_individual_aggregator_ensure_personas_property_writeable_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = personas;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	_g_object_unref0 (_data_->personas);
	_data_->personas = _tmp2_;
	_tmp3_ = property_name;
	_tmp4_ = g_strdup (_tmp3_);
	_g_free0 (_data_->property_name);
	_data_->property_name = _tmp4_;
	_folks_individual_aggregator_ensure_personas_property_writeable_co (_data_);
}


static FolksPersona* _folks_individual_aggregator_ensure_personas_property_writeable_finish (FolksIndividualAggregator* self, GAsyncResult* _res_, GError** error) {
	FolksPersona* result;
	FolksIndividualAggregatorEnsurePersonasPropertyWriteableData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return NULL;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
	result = _data_->result;
	_data_->result = NULL;
	return result;
}


static gboolean _vala_string_array_contains (gchar** stack, int stack_length, gchar* needle) {
	int i;
	for (i = 0; i < stack_length; i++) {
		if (g_strcmp0 (stack[i], needle) == 0) {
			return TRUE;
		}
	}
	return FALSE;
}


static void _folks_individual_aggregator_ensure_personas_property_writeable_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	FolksIndividualAggregatorEnsurePersonasPropertyWriteableData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	_folks_individual_aggregator_ensure_personas_property_writeable_co (_data_);
}


static gboolean _folks_individual_aggregator_ensure_personas_property_writeable_co (FolksIndividualAggregatorEnsurePersonasPropertyWriteableData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	{
		_data_->_tmp0_ = _data_->personas;
		_data_->_tmp1_ = NULL;
		_data_->_tmp1_ = gee_iterable_iterator ((GeeIterable*) _data_->_tmp0_);
		_data_->_p1_it = _data_->_tmp1_;
		while (TRUE) {
			_data_->_tmp2_ = _data_->_p1_it;
			_data_->_tmp3_ = FALSE;
			_data_->_tmp3_ = gee_iterator_next (_data_->_tmp2_);
			if (!_data_->_tmp3_) {
				break;
			}
			_data_->_tmp4_ = _data_->_p1_it;
			_data_->_tmp5_ = NULL;
			_data_->_tmp5_ = gee_iterator_get (_data_->_tmp4_);
			_data_->p1 = (FolksPersona*) _data_->_tmp5_;
			_data_->_tmp6_ = _data_->property_name;
			_data_->_tmp7_ = _data_->p1;
			_data_->_tmp8_ = folks_persona_get_writeable_properties (_data_->_tmp7_, &_data_->_tmp8__length1);
			_data_->_tmp9_ = _data_->_tmp8_;
			_data_->_tmp9__length1 = _data_->_tmp8__length1;
			if (_vala_string_array_contains (_data_->_tmp9_, _data_->_tmp9__length1, _data_->_tmp6_)) {
				_data_->_tmp10_ = _data_->p1;
				_data_->_tmp11_ = folks_persona_get_uid (_data_->_tmp10_);
				_data_->_tmp12_ = _data_->_tmp11_;
				g_debug ("individual-aggregator.vala:2274:     Returning existing persona: %s", _data_->_tmp12_);
				_data_->result = _data_->p1;
				_g_object_unref0 (_data_->_p1_it);
				if (_data_->_state_ == 0) {
					g_simple_async_result_complete_in_idle (_data_->_async_result);
				} else {
					g_simple_async_result_complete (_data_->_async_result);
				}
				g_object_unref (_data_->_async_result);
				return FALSE;
			}
			_g_object_unref0 (_data_->p1);
		}
		_g_object_unref0 (_data_->_p1_it);
	}
	_data_->_tmp13_ = _data_->personas;
	_data_->_tmp14_ = NULL;
	_data_->_tmp14_ = _folks_individual_aggregator_build_linking_details (_data_->self, _data_->_tmp13_);
	_data_->details = _data_->_tmp14_;
	_data_->new_persona = NULL;
	_data_->_tmp16_ = _data_->self->priv->_primary_store;
	if (_data_->_tmp16_ != NULL) {
		_data_->_tmp17_ = _data_->property_name;
		_data_->_tmp18_ = _data_->self->priv->_primary_store;
		_data_->_tmp19_ = folks_persona_store_get_always_writeable_properties (G_TYPE_CHECK_INSTANCE_CAST (_data_->_tmp18_, FOLKS_TYPE_PERSONA_STORE, FolksPersonaStore), &_data_->_tmp19__length1);
		_data_->_tmp20_ = _data_->_tmp19_;
		_data_->_tmp20__length1 = _data_->_tmp19__length1;
		_data_->_tmp15_ = _vala_string_array_contains (_data_->_tmp20_, _data_->_tmp20__length1, _data_->_tmp17_);
	} else {
		_data_->_tmp15_ = FALSE;
	}
	_data_->_tmp21_ = _data_->_tmp15_;
	if (_data_->_tmp21_) {
		{
			g_debug ("individual-aggregator.vala:2291:     Using writeable store");
			_data_->_tmp23_ = _data_->self->priv->_primary_store;
			_data_->_tmp24_ = _data_->details;
			_data_->_state_ = 1;
			folks_individual_aggregator_add_persona_from_details (_data_->self, NULL, G_TYPE_CHECK_INSTANCE_CAST (_data_->_tmp23_, FOLKS_TYPE_PERSONA_STORE, FolksPersonaStore), _data_->_tmp24_, _folks_individual_aggregator_ensure_personas_property_writeable_ready, _data_);
			return FALSE;
			_state_1:
			_data_->_tmp25_ = NULL;
			_data_->_tmp25_ = folks_individual_aggregator_add_persona_from_details_finish (_data_->self, _data_->_res_, &_data_->_inner_error_);
			_data_->_tmp22_ = _data_->_tmp25_;
			if (_data_->_inner_error_ != NULL) {
				if (_data_->_inner_error_->domain == FOLKS_INDIVIDUAL_AGGREGATOR_ERROR) {
					goto __catch21_folks_individual_aggregator_error;
				}
				_g_object_unref0 (_data_->new_persona);
				_g_hash_table_unref0 (_data_->details);
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
				g_clear_error (&_data_->_inner_error_);
				return FALSE;
			}
			_g_object_unref0 (_data_->new_persona);
			_data_->new_persona = _data_->_tmp22_;
		}
		goto __finally21;
		__catch21_folks_individual_aggregator_error:
		{
			_data_->e1 = _data_->_inner_error_;
			_data_->_inner_error_ = NULL;
			_g_object_unref0 (_data_->new_persona);
			_data_->new_persona = NULL;
			_g_error_free0 (_data_->e1);
		}
		__finally21:
		if (_data_->_inner_error_ != NULL) {
			if (_data_->_inner_error_->domain == FOLKS_INDIVIDUAL_AGGREGATOR_ERROR) {
				g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
				g_error_free (_data_->_inner_error_);
				_g_object_unref0 (_data_->new_persona);
				_g_hash_table_unref0 (_data_->details);
				if (_data_->_state_ == 0) {
					g_simple_async_result_complete_in_idle (_data_->_async_result);
				} else {
					g_simple_async_result_complete (_data_->_async_result);
				}
				g_object_unref (_data_->_async_result);
				return FALSE;
			} else {
				_g_object_unref0 (_data_->new_persona);
				_g_hash_table_unref0 (_data_->details);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
				g_clear_error (&_data_->_inner_error_);
				return FALSE;
			}
		}
	}
	_data_->_tmp26_ = _data_->new_persona;
	if (_data_->_tmp26_ == NULL) {
		{
			_data_->_tmp27_ = _data_->self->priv->_stores;
			_data_->_tmp28_ = gee_abstract_map_get_values ((GeeMap*) _data_->_tmp27_);
			_data_->_tmp29_ = _data_->_tmp28_;
			_data_->_tmp30_ = _data_->_tmp29_;
			_data_->_tmp31_ = NULL;
			_data_->_tmp31_ = gee_iterable_iterator ((GeeIterable*) _data_->_tmp30_);
			_data_->_tmp32_ = _data_->_tmp31_;
			_g_object_unref0 (_data_->_tmp30_);
			_data_->_s_it = _data_->_tmp32_;
			while (TRUE) {
				_data_->_tmp33_ = _data_->_s_it;
				_data_->_tmp34_ = FALSE;
				_data_->_tmp34_ = gee_iterator_next (_data_->_tmp33_);
				if (!_data_->_tmp34_) {
					break;
				}
				_data_->_tmp35_ = _data_->_s_it;
				_data_->_tmp36_ = NULL;
				_data_->_tmp36_ = gee_iterator_get (_data_->_tmp35_);
				_data_->s = (FolksPersonaStore*) _data_->_tmp36_;
				_data_->_tmp38_ = _data_->s;
				_data_->_tmp39_ = _data_->self->priv->_primary_store;
				if (_data_->_tmp38_ == _data_->_tmp39_) {
					_data_->_tmp37_ = TRUE;
				} else {
					_data_->_tmp40_ = _data_->property_name;
					_data_->_tmp41_ = _data_->s;
					_data_->_tmp42_ = folks_persona_store_get_always_writeable_properties (_data_->_tmp41_, &_data_->_tmp42__length1);
					_data_->_tmp43_ = _data_->_tmp42_;
					_data_->_tmp43__length1 = _data_->_tmp42__length1;
					_data_->_tmp37_ = !_vala_string_array_contains (_data_->_tmp43_, _data_->_tmp43__length1, _data_->_tmp40_);
				}
				_data_->_tmp44_ = _data_->_tmp37_;
				if (_data_->_tmp44_) {
					_g_object_unref0 (_data_->s);
					continue;
				}
				{
					_data_->_tmp45_ = _data_->s;
					_data_->_tmp46_ = folks_persona_store_get_id (_data_->_tmp45_);
					_data_->_tmp47_ = _data_->_tmp46_;
					g_debug ("individual-aggregator.vala:2315:     Using store %s", _data_->_tmp47_);
					_data_->_tmp49_ = _data_->s;
					_data_->_tmp50_ = _data_->details;
					_data_->_state_ = 2;
					folks_individual_aggregator_add_persona_from_details (_data_->self, NULL, _data_->_tmp49_, _data_->_tmp50_, _folks_individual_aggregator_ensure_personas_property_writeable_ready, _data_);
					return FALSE;
					_state_2:
					_data_->_tmp51_ = NULL;
					_data_->_tmp51_ = folks_individual_aggregator_add_persona_from_details_finish (_data_->self, _data_->_res_, &_data_->_inner_error_);
					_data_->_tmp48_ = _data_->_tmp51_;
					if (_data_->_inner_error_ != NULL) {
						if (_data_->_inner_error_->domain == FOLKS_INDIVIDUAL_AGGREGATOR_ERROR) {
							goto __catch22_folks_individual_aggregator_error;
						}
						_g_object_unref0 (_data_->s);
						_g_object_unref0 (_data_->_s_it);
						_g_object_unref0 (_data_->new_persona);
						_g_hash_table_unref0 (_data_->details);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
						g_clear_error (&_data_->_inner_error_);
						return FALSE;
					}
					_g_object_unref0 (_data_->new_persona);
					_data_->new_persona = _data_->_tmp48_;
				}
				goto __finally22;
				__catch22_folks_individual_aggregator_error:
				{
					_data_->e2 = _data_->_inner_error_;
					_data_->_inner_error_ = NULL;
					_g_object_unref0 (_data_->new_persona);
					_data_->new_persona = NULL;
					_g_error_free0 (_data_->e2);
					_g_object_unref0 (_data_->s);
					continue;
				}
				__finally22:
				if (_data_->_inner_error_ != NULL) {
					if (_data_->_inner_error_->domain == FOLKS_INDIVIDUAL_AGGREGATOR_ERROR) {
						g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
						g_error_free (_data_->_inner_error_);
						_g_object_unref0 (_data_->s);
						_g_object_unref0 (_data_->_s_it);
						_g_object_unref0 (_data_->new_persona);
						_g_hash_table_unref0 (_data_->details);
						if (_data_->_state_ == 0) {
							g_simple_async_result_complete_in_idle (_data_->_async_result);
						} else {
							g_simple_async_result_complete (_data_->_async_result);
						}
						g_object_unref (_data_->_async_result);
						return FALSE;
					} else {
						_g_object_unref0 (_data_->s);
						_g_object_unref0 (_data_->_s_it);
						_g_object_unref0 (_data_->new_persona);
						_g_hash_table_unref0 (_data_->details);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
						g_clear_error (&_data_->_inner_error_);
						return FALSE;
					}
				}
				_g_object_unref0 (_data_->s);
			}
			_g_object_unref0 (_data_->_s_it);
		}
	}
	_data_->_tmp53_ = _data_->new_persona;
	if (_data_->_tmp53_ == NULL) {
		_data_->_tmp54_ = _data_->self->priv->_primary_store;
		_data_->_tmp52_ = _data_->_tmp54_ == NULL;
	} else {
		_data_->_tmp52_ = FALSE;
	}
	_data_->_tmp55_ = _data_->_tmp52_;
	if (_data_->_tmp55_) {
		_data_->_tmp56_ = NULL;
		_data_->_tmp56_ = _ ("Cant add personas with no primary store.");
		_data_->_tmp57_ = g_strconcat (_data_->_tmp56_, "\n", NULL);
		_data_->_tmp58_ = _data_->_tmp57_;
		_data_->_tmp59_ = NULL;
		_data_->_tmp59_ = _ ("Persona store %s:%s is configured as primary, but could not be found" \
" or failed to load.");
		_data_->_tmp60_ = g_strconcat (_data_->_tmp58_, _data_->_tmp59_, NULL);
		_data_->_tmp61_ = _data_->_tmp60_;
		_data_->_tmp62_ = g_strconcat (_data_->_tmp61_, "\n", NULL);
		_data_->_tmp63_ = _data_->_tmp62_;
		_data_->_tmp64_ = NULL;
		_data_->_tmp64_ = _ ("Check the relevant service is running, or change the default store in " \
"that service or using the %s GSettings key.");
		_data_->_tmp65_ = g_strconcat (_data_->_tmp63_, _data_->_tmp64_, NULL);
		_data_->_tmp66_ = _data_->_tmp65_;
		_data_->_tmp67_ = _data_->self->priv->_configured_primary_store_type_id;
		_data_->_tmp68_ = _data_->self->priv->_configured_primary_store_id;
		_data_->_tmp69_ = NULL;
		_data_->_tmp69_ = g_strdup_printf ("%s %s", FOLKS_INDIVIDUAL_AGGREGATOR__FOLKS_GSETTINGS_SCHEMA, FOLKS_INDIVIDUAL_AGGREGATOR__PRIMARY_STORE_CONFIG_KEY);
		_data_->_tmp70_ = _data_->_tmp69_;
		_data_->_tmp71_ = g_error_new (FOLKS_INDIVIDUAL_AGGREGATOR_ERROR, FOLKS_INDIVIDUAL_AGGREGATOR_ERROR_NO_PRIMARY_STORE, _data_->_tmp66_, _data_->_tmp67_, _data_->_tmp68_, _data_->_tmp70_);
		_data_->_tmp72_ = _data_->_tmp71_;
		_g_free0 (_data_->_tmp70_);
		_g_free0 (_data_->_tmp66_);
		_g_free0 (_data_->_tmp63_);
		_g_free0 (_data_->_tmp61_);
		_g_free0 (_data_->_tmp58_);
		_data_->_inner_error_ = _data_->_tmp72_;
		if (_data_->_inner_error_->domain == FOLKS_INDIVIDUAL_AGGREGATOR_ERROR) {
			g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
			g_error_free (_data_->_inner_error_);
			_g_object_unref0 (_data_->new_persona);
			_g_hash_table_unref0 (_data_->details);
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		} else {
			_g_object_unref0 (_data_->new_persona);
			_g_hash_table_unref0 (_data_->details);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	} else {
		_data_->_tmp73_ = _data_->new_persona;
		if (_data_->_tmp73_ == NULL) {
			_data_->_tmp74_ = NULL;
			_data_->_tmp74_ = _ ("Can't write to requested property (%s) of the writeable store.");
			_data_->_tmp75_ = _data_->property_name;
			_data_->_tmp76_ = g_error_new (FOLKS_INDIVIDUAL_AGGREGATOR_ERROR, FOLKS_INDIVIDUAL_AGGREGATOR_ERROR_PROPERTY_NOT_WRITEABLE, _data_->_tmp74_, _data_->_tmp75_);
			_data_->_inner_error_ = _data_->_tmp76_;
			if (_data_->_inner_error_->domain == FOLKS_INDIVIDUAL_AGGREGATOR_ERROR) {
				g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
				g_error_free (_data_->_inner_error_);
				_g_object_unref0 (_data_->new_persona);
				_g_hash_table_unref0 (_data_->details);
				if (_data_->_state_ == 0) {
					g_simple_async_result_complete_in_idle (_data_->_async_result);
				} else {
					g_simple_async_result_complete (_data_->_async_result);
				}
				g_object_unref (_data_->_async_result);
				return FALSE;
			} else {
				_g_object_unref0 (_data_->new_persona);
				_g_hash_table_unref0 (_data_->details);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
				g_clear_error (&_data_->_inner_error_);
				return FALSE;
			}
		}
	}
	_data_->_tmp77_ = _data_->new_persona;
	_data_->_tmp78_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_data_->_tmp77_, FOLKS_TYPE_PERSONA, FolksPersona));
	_data_->result = _data_->_tmp78_;
	_g_object_unref0 (_data_->new_persona);
	_g_hash_table_unref0 (_data_->details);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
	_g_object_unref0 (_data_->new_persona);
	_g_hash_table_unref0 (_data_->details);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void folks_individual_aggregator_look_up_individual_data_free (gpointer _data) {
	FolksIndividualAggregatorLookUpIndividualData* _data_;
	_data_ = _data;
	_g_free0 (_data_->id);
	_g_object_unref0 (_data_->result);
	_g_object_unref0 (_data_->self);
	g_slice_free (FolksIndividualAggregatorLookUpIndividualData, _data_);
}


void folks_individual_aggregator_look_up_individual (FolksIndividualAggregator* self, const gchar* id, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	FolksIndividualAggregatorLookUpIndividualData* _data_;
	FolksIndividualAggregator* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	_data_ = g_slice_new0 (FolksIndividualAggregatorLookUpIndividualData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, folks_individual_aggregator_look_up_individual);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, folks_individual_aggregator_look_up_individual_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = id;
	_tmp2_ = g_strdup (_tmp1_);
	_g_free0 (_data_->id);
	_data_->id = _tmp2_;
	folks_individual_aggregator_look_up_individual_co (_data_);
}


FolksIndividual* folks_individual_aggregator_look_up_individual_finish (FolksIndividualAggregator* self, GAsyncResult* _res_, GError** error) {
	FolksIndividual* result;
	FolksIndividualAggregatorLookUpIndividualData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return NULL;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
	result = _data_->result;
	_data_->result = NULL;
	return result;
}


/**
   * Look up an individual in the aggregator.
   *
   * This returns the {@link Individual} with the given ``id`` if it exists in
   * the aggregator, and ``null`` otherwise.
   *
   * In future, when lazy-loading of individuals' properties is added to folks,
   * this method guarantees to load all properties of the individual, even if
   * the aggregator hasn't lazy-loaded anything else.
   *
   * This method is safe to call before {@link IndividualAggregator.prepare} has
   * been called, and will call {@link IndividualAggregator.prepare} itself in
   * that case.
   *
   * This method is safe to call multiple times concurrently.
   *
   * @param id ID of the individual to look up
   * @return individual with ``id``, or ``null`` if no such individual was found
   * @throws GLib.Error from {@link IndividualAggregator.prepare}
   *
   * @since 0.7.0
   */
static void folks_individual_aggregator_look_up_individual_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	FolksIndividualAggregatorLookUpIndividualData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	folks_individual_aggregator_look_up_individual_co (_data_);
}


static gboolean folks_individual_aggregator_look_up_individual_co (FolksIndividualAggregatorLookUpIndividualData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_state_ = 1;
	folks_individual_aggregator_prepare (_data_->self, folks_individual_aggregator_look_up_individual_ready, _data_);
	return FALSE;
	_state_1:
	folks_individual_aggregator_prepare_finish (_data_->self, _data_->_res_, &_data_->_inner_error_);
	if (_data_->_inner_error_ != NULL) {
		g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
		g_error_free (_data_->_inner_error_);
		if (_data_->_state_ == 0) {
			g_simple_async_result_complete_in_idle (_data_->_async_result);
		} else {
			g_simple_async_result_complete (_data_->_async_result);
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->_tmp0_ = _data_->self->priv->_individuals;
	_data_->_tmp1_ = _data_->id;
	_data_->_tmp2_ = NULL;
	_data_->_tmp2_ = gee_map_get (_data_->_tmp0_, _data_->_tmp1_);
	_data_->result = (FolksIndividual*) _data_->_tmp2_;
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


gboolean folks_individual_aggregator_get_is_prepared (FolksIndividualAggregator* self) {
	gboolean result;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_is_prepared;
	result = _tmp0_;
	return result;
}


gboolean folks_individual_aggregator_get_is_quiescent (FolksIndividualAggregator* self) {
	gboolean result;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_is_quiescent;
	result = _tmp0_;
	return result;
}


FolksPersonaStore* folks_individual_aggregator_get_primary_store (FolksIndividualAggregator* self) {
	FolksPersonaStore* result;
	FolksPersonaStore* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_primary_store;
	result = _tmp0_;
	return result;
}


GeeMap* folks_individual_aggregator_get_individuals (FolksIndividualAggregator* self) {
	GeeMap* result;
	GeeMap* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_individuals_ro;
	result = _tmp0_;
	return result;
}


static void folks_individual_aggregator_set_individuals (FolksIndividualAggregator* self, GeeMap* value) {
	GeeMap* _tmp0_;
	GeeMap* _tmp1_;
	GeeMap* _tmp2_;
	GeeMap* _tmp3_;
	GeeMap* _tmp4_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_individuals);
	self->priv->_individuals = _tmp1_;
	_tmp2_ = self->priv->_individuals;
	_tmp3_ = gee_map_get_read_only_view (_tmp2_);
	_tmp4_ = _tmp3_;
	_g_object_unref0 (self->priv->_individuals_ro);
	self->priv->_individuals_ro = _tmp4_;
	g_object_notify ((GObject *) self, "individuals");
}


FolksIndividual* folks_individual_aggregator_get_user (FolksIndividualAggregator* self) {
	FolksIndividual* result;
	FolksIndividual* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_user;
	result = _tmp0_;
	return result;
}


static void folks_individual_aggregator_set_user (FolksIndividualAggregator* self, FolksIndividual* value) {
	FolksIndividual* _tmp0_;
	FolksIndividual* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_user);
	self->priv->_user = _tmp1_;
	g_object_notify ((GObject *) self, "user");
}


static void g_cclosure_user_marshal_VOID__OBJECT_OBJECT_STRING_OBJECT_ENUM (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__OBJECT_OBJECT_STRING_OBJECT_ENUM) (gpointer data1, gpointer arg_1, gpointer arg_2, const char* arg_3, gpointer arg_4, gint arg_5, gpointer data2);
	register GMarshalFunc_VOID__OBJECT_OBJECT_STRING_OBJECT_ENUM callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 6);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__OBJECT_OBJECT_STRING_OBJECT_ENUM) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_object (param_values + 1), g_value_get_object (param_values + 2), g_value_get_string (param_values + 3), g_value_get_object (param_values + 4), g_value_get_enum (param_values + 5), data2);
}


static void _g_ptr_array_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_ptr_array_unref (var), NULL));
}


static gchar* string_strip (const gchar* self) {
	gchar* result = NULL;
	gchar* _result_ = NULL;
	gchar* _tmp0_ = NULL;
	const gchar* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	_tmp1_ = _result_;
	g_strstrip (_tmp1_);
	result = _result_;
	return result;
}


static GObject * folks_individual_aggregator_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	FolksIndividualAggregator * self;
	GeeHashMap* _tmp0_;
	GeeHashMap* _tmp1_;
	GeeMap* _tmp2_;
	GeeMap* _tmp3_;
	GeeMap* _tmp4_;
	GHashFunc _tmp5_;
	GEqualFunc _tmp6_;
	GHashTable* _tmp7_;
	FolksSmallSet* _tmp8_;
	FolksDebug* _tmp9_ = NULL;
	FolksDebug* _tmp10_;
	gchar* store_config_ids = NULL;
	const gchar* _tmp11_ = NULL;
	gchar* _tmp12_;
	const gchar* _tmp13_;
	const gchar* _tmp21_;
	const gchar* _tmp36_;
	const gchar* _tmp37_;
	gchar* disable_linking = NULL;
	const gchar* _tmp38_ = NULL;
	gchar* _tmp39_;
	const gchar* _tmp40_;
	gboolean _tmp45_ = FALSE;
	gboolean _tmp46_ = FALSE;
	const gchar* _tmp47_;
	gboolean _tmp49_;
	gboolean _tmp51_;
	FolksBackendStore* _tmp52_ = NULL;
	parent_class = G_OBJECT_CLASS (folks_individual_aggregator_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FOLKS_TYPE_INDIVIDUAL_AGGREGATOR, FolksIndividualAggregator);
	_tmp0_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, FOLKS_TYPE_PERSONA_STORE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->_stores);
	self->priv->_stores = _tmp0_;
	_tmp1_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, FOLKS_TYPE_INDIVIDUAL, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->_individuals);
	self->priv->_individuals = (GeeMap*) _tmp1_;
	_tmp2_ = self->priv->_individuals;
	_tmp3_ = gee_map_get_read_only_view (_tmp2_);
	_tmp4_ = _tmp3_;
	_g_object_unref0 (self->priv->_individuals_ro);
	self->priv->_individuals_ro = _tmp4_;
	_tmp5_ = g_str_hash;
	_tmp6_ = g_str_equal;
	_tmp7_ = g_hash_table_new_full (_tmp5_, _tmp6_, _g_free0_, _g_ptr_array_unref0_);
	_g_hash_table_unref0 (self->priv->_link_map);
	self->priv->_link_map = _tmp7_;
	_tmp8_ = folks_small_set_new (FOLKS_TYPE_BACKEND, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->_backends);
	self->priv->_backends = _tmp8_;
	_tmp9_ = folks_debug_dup ();
	_g_object_unref0 (self->priv->_debug);
	self->priv->_debug = _tmp9_;
	_tmp10_ = self->priv->_debug;
	g_signal_connect_object (_tmp10_, "print-status", (GCallback) __folks_individual_aggregator_debug_print_status_folks_debug_print_status, self, 0);
	_tmp11_ = g_getenv ("FOLKS_PRIMARY_STORE");
	_tmp12_ = g_strdup (_tmp11_);
	store_config_ids = _tmp12_;
	_tmp13_ = store_config_ids;
	if (_tmp13_ == NULL) {
		const gchar* _tmp14_ = NULL;
		gchar* _tmp15_;
		const gchar* _tmp16_;
		_tmp14_ = g_getenv ("FOLKS_WRITEABLE_STORE");
		_tmp15_ = g_strdup (_tmp14_);
		_g_free0 (store_config_ids);
		store_config_ids = _tmp15_;
		_tmp16_ = store_config_ids;
		if (_tmp16_ != NULL) {
			gchar* deprecated_warn = NULL;
			gchar* _tmp17_;
			const gchar* _tmp18_;
			gchar* _tmp19_;
			const gchar* _tmp20_;
			_tmp17_ = g_strdup ("FOLKS_WRITEABLE_STORE is deprecated, ");
			deprecated_warn = _tmp17_;
			_tmp18_ = deprecated_warn;
			_tmp19_ = g_strconcat (_tmp18_, "use FOLKS_PRIMARY_STORE", NULL);
			_g_free0 (deprecated_warn);
			deprecated_warn = _tmp19_;
			_tmp20_ = deprecated_warn;
			g_warning ("individual-aggregator.vala:376: %s", _tmp20_);
			_g_free0 (deprecated_warn);
		}
	}
	_tmp21_ = store_config_ids;
	if (_tmp21_ != NULL) {
		const gchar* _tmp22_;
		g_debug ("individual-aggregator.vala:382: Setting primary store IDs from environ" \
"ment variable.");
		_tmp22_ = store_config_ids;
		_folks_individual_aggregator_configure_primary_store (self, (const gchar*) _tmp22_);
	} else {
		gboolean _tmp23_;
		GSettings* settings = NULL;
		GSettings* _tmp28_;
		gchar* val = NULL;
		GSettings* _tmp29_;
		gchar* _tmp30_ = NULL;
		gboolean _tmp31_ = FALSE;
		const gchar* _tmp32_;
		gboolean _tmp34_;
		g_debug ("individual-aggregator.vala:387: Setting primary store IDs to defaults.");
		_tmp23_ = HAVE_EDS;
		if (_tmp23_) {
			gchar* _tmp24_;
			gchar* _tmp25_;
			_tmp24_ = g_strdup ("eds");
			_g_free0 (self->priv->_configured_primary_store_type_id);
			self->priv->_configured_primary_store_type_id = _tmp24_;
			_tmp25_ = g_strdup ("system-address-book");
			_g_free0 (self->priv->_configured_primary_store_id);
			self->priv->_configured_primary_store_id = _tmp25_;
		} else {
			gchar* _tmp26_;
			gchar* _tmp27_;
			_tmp26_ = g_strdup ("key-file");
			_g_free0 (self->priv->_configured_primary_store_type_id);
			self->priv->_configured_primary_store_type_id = _tmp26_;
			_tmp27_ = g_strdup ("");
			_g_free0 (self->priv->_configured_primary_store_id);
			self->priv->_configured_primary_store_id = _tmp27_;
		}
		_tmp28_ = g_settings_new (FOLKS_INDIVIDUAL_AGGREGATOR__FOLKS_GSETTINGS_SCHEMA);
		settings = _tmp28_;
		_tmp29_ = settings;
		_tmp30_ = g_settings_get_string (_tmp29_, FOLKS_INDIVIDUAL_AGGREGATOR__PRIMARY_STORE_CONFIG_KEY);
		val = _tmp30_;
		_tmp32_ = val;
		if (_tmp32_ != NULL) {
			const gchar* _tmp33_;
			_tmp33_ = val;
			_tmp31_ = g_strcmp0 (_tmp33_, "") != 0;
		} else {
			_tmp31_ = FALSE;
		}
		_tmp34_ = _tmp31_;
		if (_tmp34_) {
			const gchar* _tmp35_;
			g_debug ("individual-aggregator.vala:403: Setting primary store IDs from GSettin" \
"gs.");
			_tmp35_ = val;
			_folks_individual_aggregator_configure_primary_store (self, (const gchar*) _tmp35_);
		}
		_g_free0 (val);
		_g_object_unref0 (settings);
	}
	_tmp36_ = self->priv->_configured_primary_store_type_id;
	_tmp37_ = self->priv->_configured_primary_store_id;
	g_debug ("individual-aggregator.vala:408: Primary store IDs are '%s' and '%s'.", _tmp36_, _tmp37_);
	_tmp38_ = g_getenv ("FOLKS_DISABLE_LINKING");
	_tmp39_ = g_strdup (_tmp38_);
	disable_linking = _tmp39_;
	_tmp40_ = disable_linking;
	if (_tmp40_ != NULL) {
		const gchar* _tmp41_;
		gchar* _tmp42_ = NULL;
		gchar* _tmp43_;
		gchar* _tmp44_ = NULL;
		_tmp41_ = disable_linking;
		_tmp42_ = string_strip ((const gchar*) _tmp41_);
		_tmp43_ = _tmp42_;
		_tmp44_ = g_utf8_strdown (_tmp43_, (gssize) (-1));
		_g_free0 (disable_linking);
		disable_linking = _tmp44_;
		_g_free0 (_tmp43_);
	}
	_tmp47_ = disable_linking;
	if (_tmp47_ == NULL) {
		_tmp46_ = TRUE;
	} else {
		const gchar* _tmp48_;
		_tmp48_ = disable_linking;
		_tmp46_ = g_strcmp0 (_tmp48_, "no") == 0;
	}
	_tmp49_ = _tmp46_;
	if (_tmp49_) {
		_tmp45_ = TRUE;
	} else {
		const gchar* _tmp50_;
		_tmp50_ = disable_linking;
		_tmp45_ = g_strcmp0 (_tmp50_, "0") == 0;
	}
	_tmp51_ = _tmp45_;
	self->priv->_linking_enabled = _tmp51_;
	_tmp52_ = folks_backend_store_dup ();
	_g_object_unref0 (self->priv->_backend_store);
	self->priv->_backend_store = _tmp52_;
	g_debug ("individual-aggregator.vala:420: Constructing IndividualAggregator %p", self);
	_g_free0 (disable_linking);
	_g_free0 (store_config_ids);
	return obj;
}


static void folks_individual_aggregator_class_init (FolksIndividualAggregatorClass * klass) {
	folks_individual_aggregator_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (FolksIndividualAggregatorPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_folks_individual_aggregator_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_folks_individual_aggregator_set_property;
	G_OBJECT_CLASS (klass)->constructor = folks_individual_aggregator_constructor;
	G_OBJECT_CLASS (klass)->finalize = folks_individual_aggregator_finalize;
	/**
	   * Whether {@link IndividualAggregator.prepare} has successfully completed for
	   * this aggregator.
	   *
	   * @since 0.3.0
	   */
	g_object_class_install_property (G_OBJECT_CLASS (klass), FOLKS_INDIVIDUAL_AGGREGATOR_IS_PREPARED, g_param_spec_boolean ("is-prepared", "is-prepared", "is-prepared", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	/**
	   * Whether the aggregator has reached a quiescent state. This will happen at
	   * some point after {@link IndividualAggregator.prepare} has successfully
	   * completed for the aggregator. An aggregator is in a quiescent state when
	   * all the {@link PersonaStore}s listed by its backends have reached a
	   * quiescent state. Once it's reached a quiescent state, this property will
	   * never change again (from ``true`` to ``false``).
	   *
	   * It's guaranteed that this property's value will only ever change after
	   * {@link IndividualAggregator.is_prepared} has changed to ``true``.
	   *
	   * @since 0.6.2
	   */
	g_object_class_install_property (G_OBJECT_CLASS (klass), FOLKS_INDIVIDUAL_AGGREGATOR_IS_QUIESCENT, g_param_spec_boolean ("is-quiescent", "is-quiescent", "is-quiescent", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	/**
	   * Our configured primary (writeable) store.
	   *
	   * Which one to use is decided (in order or precedence)
	   * by:
	   *
	   * - the FOLKS_PRIMARY_STORE env var (mostly for debugging)
	   * - the GSettings key set in ``_PRIMARY_STORE_CONFIG_KEY`` (system set store)
	   * - going with the ``key-file`` or ``eds`` store as the fall-back option
	   *
	   * @since 0.5.0
	   */
	g_object_class_install_property (G_OBJECT_CLASS (klass), FOLKS_INDIVIDUAL_AGGREGATOR_PRIMARY_STORE, g_param_spec_object ("primary-store", "primary-store", "primary-store", FOLKS_TYPE_PERSONA_STORE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	/**
	   * A map from {@link Individual.id}s to their {@link Individual}s.
	   *
	   * This is the canonical set of {@link Individual}s provided by this
	   * IndividualAggregator.
	   *
	   * {@link Individual}s may be added or removed using
	   * {@link IndividualAggregator.add_persona_from_details} and
	   * {@link IndividualAggregator.remove_individual}, respectively.
	   *
	   * @since 0.5.1
	   */
	g_object_class_install_property (G_OBJECT_CLASS (klass), FOLKS_INDIVIDUAL_AGGREGATOR_INDIVIDUALS, g_param_spec_object ("individuals", "individuals", "individuals", GEE_TYPE_MAP, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	/**
	   * The {@link Individual} representing the user.
	   *
	   * If it exists, this holds the {@link Individual} who is the user: the
	   * {@link Individual} containing the {@link Persona}s who are the owners of
	   * the accounts for their respective backends.
	   *
	   * @since 0.3.0
	   */
	g_object_class_install_property (G_OBJECT_CLASS (klass), FOLKS_INDIVIDUAL_AGGREGATOR_USER, g_param_spec_object ("user", "user", "user", FOLKS_TYPE_INDIVIDUAL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	/**
	   * Emitted when one or more {@link Individual}s are added to or removed from
	   * the aggregator.
	   *
	   * If more information about the relationships between {@link Individual}s
	   * which have been linked and unlinked is needed, consider connecting to
	   * {@link IndividualAggregator.individuals_changed_detailed} instead, which is
	   * emitted at the same time as this signal.
	   *
	   * This will not be emitted until after {@link IndividualAggregator.prepare}
	   * has been called.
	   *
	   * @param added a list of {@link Individual}s which have been added
	   * @param removed a list of {@link Individual}s which have been removed
	   * @param message a string message from the backend, if any
	   * @param actor the {@link Persona} who made the change, if known
	   * @param reason the reason for the change
	   *
	   * @since 0.5.1
	   */
	g_signal_new ("individuals_changed", FOLKS_TYPE_INDIVIDUAL_AGGREGATOR, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__OBJECT_OBJECT_STRING_OBJECT_ENUM, G_TYPE_NONE, 5, GEE_TYPE_SET, GEE_TYPE_SET, G_TYPE_STRING, FOLKS_TYPE_PERSONA, FOLKS_GROUP_DETAILS_TYPE_CHANGE_REASON);
	/**
	   * Emitted when one or more {@link Individual}s are added to or removed from
	   * the aggregator.
	   *
	   * This is emitted at the same time as
	   * {@link IndividualAggregator.individuals_changed}, but includes more
	   * information about the relationships between {@link Individual}s which have
	   * been linked and unlinked.
	   *
	   * Individuals which have been linked will be listed in the multi-map as
	   * mappings from the old individuals to the single new individual which
	   * replaces them (i.e. each of the old individuals will map to the same new
	   * individual). This new individual is the one which will be specified as the
	   * ``replacement_individual`` in the {@link Individual.removed} signal for the
	   * old individuals.
	   *
	   * Individuals which have been unlinked will be listed in the multi-map as
	   * a mapping from the unlinked individual to a set of one or more individuals
	   * which replace it.
	   *
	   * Individuals which have been added will be listed in the multi-map as a
	   * mapping from ``null`` to the set of added individuals. If ``null`` doesn't
	   * map to anything, no individuals have been added to the aggregator.
	   *
	   * Individuals which have been removed will be listed in the multi-map as
	   * mappings from the removed individual to ``null``.
	   *
	   * This will not be emitted until after {@link IndividualAggregator.prepare}
	   * has been called.
	   *
	   * @param changes a mapping of old {@link Individual}s to new
	   * {@link Individual}s for the individuals which have changed in the
	   * aggregator
	   *
	   * @since 0.6.2
	   */
	g_signal_new ("individuals_changed_detailed", FOLKS_TYPE_INDIVIDUAL_AGGREGATOR, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, GEE_TYPE_MULTI_MAP);
}


static void folks_individual_aggregator_instance_init (FolksIndividualAggregator * self) {
	self->priv = FOLKS_INDIVIDUAL_AGGREGATOR_GET_PRIVATE (self);
	self->priv->_primary_store = NULL;
	self->priv->_linking_enabled = TRUE;
	g_static_rec_mutex_init (&self->priv->__lock__is_prepared);
	self->priv->_is_prepared = FALSE;
	self->priv->_prepare_pending = FALSE;
	self->priv->_non_quiescent_persona_store_count = (guint) 0;
	self->priv->_non_quiescent_backend_count = (guint) 0;
	self->priv->_is_quiescent = FALSE;
	self->priv->_quiescent_timeout_id = (guint) 0;
	self->priv->_user_configured_primary_store = FALSE;
}


static void folks_individual_aggregator_finalize (GObject* obj) {
	FolksIndividualAggregator * self;
	guint _tmp0_;
	FolksBackendStore* _tmp2_;
	guint _tmp3_ = 0U;
	FolksDebug* _tmp4_;
	guint _tmp5_ = 0U;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FOLKS_TYPE_INDIVIDUAL_AGGREGATOR, FolksIndividualAggregator);
	g_debug ("individual-aggregator.vala:425: Destroying IndividualAggregator %p", self);
	_tmp0_ = self->priv->_quiescent_timeout_id;
	if (_tmp0_ != ((guint) 0)) {
		guint _tmp1_;
		_tmp1_ = self->priv->_quiescent_timeout_id;
		g_source_remove (_tmp1_);
		self->priv->_quiescent_timeout_id = (guint) 0;
	}
	_tmp2_ = self->priv->_backend_store;
	g_signal_parse_name ("backend-available", FOLKS_TYPE_BACKEND_STORE, &_tmp3_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (_tmp2_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp3_, 0, NULL, (GCallback) __folks_individual_aggregator_backend_available_cb_folks_backend_store_backend_available, self);
	_tmp4_ = self->priv->_debug;
	g_signal_parse_name ("print-status", FOLKS_TYPE_DEBUG, &_tmp5_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (_tmp4_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp5_, 0, NULL, (GCallback) __folks_individual_aggregator_debug_print_status_folks_debug_print_status, self);
	_g_object_unref0 (self->priv->_backend_store);
	_g_object_unref0 (self->priv->_stores);
	_g_object_unref0 (self->priv->_backends);
	_g_hash_table_unref0 (self->priv->_link_map);
	g_static_rec_mutex_free (&self->priv->__lock__is_prepared);
	_g_object_unref0 (self->priv->_debug);
	_g_free0 (self->priv->_configured_primary_store_type_id);
	_g_free0 (self->priv->_configured_primary_store_id);
	_g_object_unref0 (self->priv->_individuals);
	_g_object_unref0 (self->priv->_individuals_ro);
	_g_object_unref0 (self->priv->_user);
	G_OBJECT_CLASS (folks_individual_aggregator_parent_class)->finalize (obj);
}


/**
 * Stores {@link Individual}s which have been created through
 * aggregation of all the {@link Persona}s provided by the various
 * {@link Backend}s.
 *
 * This is the main interface for client applications.
 *
 * Linking and unlinking of personas and individuals is performed entirely
 * through the aggregator. Personas may be linked together to form individuals;
 * for example, the personas which form ``individual1`` and ``individual2`` may
 * be linked together with ``another_persona`` to give a new {@link Individual}:
 * {{{
 *   var personas = new HashSet<Persona> ();
 *   personas.add_all (individual1.personas);
 *   personas.add_all (individual2.personas);
 *   personas.add (another_persona);
 *   yield my_individual_aggregator.link_personas (personas);
 * }}}
 * The individuals which contained those personas will be removed when
 * {@link IndividualAggregator.link_personas} is called. Any personas in those
 * individuals which were not included in the linking call may end up implicitly
 * linked to the new individual, or may be aggregated into other new
 * individuals.
 *
 * For example, consider the situation where ``individual1`` contains two
 * personas, ``persona1A`` and ``persona1B``; ``individual2`` contains one
 * persona, ``persona2A``; and ``another_persona`` comes from ``individual3``,
 * which also contains ``persona3A`` and ``persona3B``. Calling
 * {@link IndividualAggregator.link_personas} on ``persona1A``, ``persona1B``,
 * ``persona2A`` and ``another_persona`` will result in ``individual1`` and
 * ``individual2`` being removed. A new {@link Individual} will be created
 * containing all the personas passed to the linking function. It might also
 * contain ``persona3A`` and ``persona3B``; or they might be in one or two other
 * new individuals.
 *
 * An existing individual may be unlinked to form singleton
 * individuals for each of its personas:
 * {{{
 *   yield my_individual_aggregator.unlink_individual (my_individual);
 * }}}
 *
 * Note that to link two individuals together, their two sets of personas must
 * be linked together. There is no API to directly link the individuals
 * themselves, as conceptually folks links {@link Persona}s, not
 * {@link Individual}s.
 */
GType folks_individual_aggregator_get_type (void) {
	static volatile gsize folks_individual_aggregator_type_id__volatile = 0;
	if (g_once_init_enter (&folks_individual_aggregator_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FolksIndividualAggregatorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) folks_individual_aggregator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FolksIndividualAggregator), 0, (GInstanceInitFunc) folks_individual_aggregator_instance_init, NULL };
		GType folks_individual_aggregator_type_id;
		folks_individual_aggregator_type_id = g_type_register_static (G_TYPE_OBJECT, "FolksIndividualAggregator", &g_define_type_info, 0);
		g_once_init_leave (&folks_individual_aggregator_type_id__volatile, folks_individual_aggregator_type_id);
	}
	return folks_individual_aggregator_type_id__volatile;
}


static void _vala_folks_individual_aggregator_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	FolksIndividualAggregator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, FOLKS_TYPE_INDIVIDUAL_AGGREGATOR, FolksIndividualAggregator);
	switch (property_id) {
		case FOLKS_INDIVIDUAL_AGGREGATOR_IS_PREPARED:
		g_value_set_boolean (value, folks_individual_aggregator_get_is_prepared (self));
		break;
		case FOLKS_INDIVIDUAL_AGGREGATOR_IS_QUIESCENT:
		g_value_set_boolean (value, folks_individual_aggregator_get_is_quiescent (self));
		break;
		case FOLKS_INDIVIDUAL_AGGREGATOR_PRIMARY_STORE:
		g_value_set_object (value, folks_individual_aggregator_get_primary_store (self));
		break;
		case FOLKS_INDIVIDUAL_AGGREGATOR_INDIVIDUALS:
		g_value_set_object (value, folks_individual_aggregator_get_individuals (self));
		break;
		case FOLKS_INDIVIDUAL_AGGREGATOR_USER:
		g_value_set_object (value, folks_individual_aggregator_get_user (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_folks_individual_aggregator_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	FolksIndividualAggregator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, FOLKS_TYPE_INDIVIDUAL_AGGREGATOR, FolksIndividualAggregator);
	switch (property_id) {
		case FOLKS_INDIVIDUAL_AGGREGATOR_INDIVIDUALS:
		folks_individual_aggregator_set_individuals (self, g_value_get_object (value));
		break;
		case FOLKS_INDIVIDUAL_AGGREGATOR_USER:
		folks_individual_aggregator_set_user (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



