/* backend-store.c generated by valac 0.27.1.3-6129, the Vala compiler
 * generated from backend-store.vala, do not modify */

/*
 * Copyright (C) 2008 Nokia Corporation.
 * Copyright (C) 2008 Zeeshan Ali (Khattak) <zeeshanak@gnome.org>.
 * Copyright (C) 2010 Collabora Ltd.
 *
 * This library is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 2.1 of the License, or
 * (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Authors: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
 *          Travis Reitter <travis.reitter@collabora.co.uk>
 *
 * This file was originally part of Rygel.
 */

#include <glib.h>
#include <glib-object.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <folks/small-set.h>
#include <gio/gio.h>
#include <gmodule.h>
#include <folks-internal.h>
#include <config.h>
#include <glib/gi18n-lib.h>


#define FOLKS_TYPE_BACKEND_STORE (folks_backend_store_get_type ())
#define FOLKS_BACKEND_STORE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FOLKS_TYPE_BACKEND_STORE, FolksBackendStore))
#define FOLKS_BACKEND_STORE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FOLKS_TYPE_BACKEND_STORE, FolksBackendStoreClass))
#define FOLKS_IS_BACKEND_STORE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FOLKS_TYPE_BACKEND_STORE))
#define FOLKS_IS_BACKEND_STORE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FOLKS_TYPE_BACKEND_STORE))
#define FOLKS_BACKEND_STORE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FOLKS_TYPE_BACKEND_STORE, FolksBackendStoreClass))

typedef struct _FolksBackendStore FolksBackendStore;
typedef struct _FolksBackendStoreClass FolksBackendStoreClass;
typedef struct _FolksBackendStorePrivate FolksBackendStorePrivate;

#define FOLKS_TYPE_BACKEND (folks_backend_get_type ())
#define FOLKS_BACKEND(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FOLKS_TYPE_BACKEND, FolksBackend))
#define FOLKS_BACKEND_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FOLKS_TYPE_BACKEND, FolksBackendClass))
#define FOLKS_IS_BACKEND(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FOLKS_TYPE_BACKEND))
#define FOLKS_IS_BACKEND_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FOLKS_TYPE_BACKEND))
#define FOLKS_BACKEND_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FOLKS_TYPE_BACKEND, FolksBackendClass))

typedef struct _FolksBackend FolksBackend;
typedef struct _FolksBackendClass FolksBackendClass;

#define FOLKS_TYPE_DEBUG (folks_debug_get_type ())
#define FOLKS_DEBUG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FOLKS_TYPE_DEBUG, FolksDebug))
#define FOLKS_DEBUG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FOLKS_TYPE_DEBUG, FolksDebugClass))
#define FOLKS_IS_DEBUG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FOLKS_TYPE_DEBUG))
#define FOLKS_IS_DEBUG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FOLKS_TYPE_DEBUG))
#define FOLKS_DEBUG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FOLKS_TYPE_DEBUG, FolksDebugClass))

typedef struct _FolksDebug FolksDebug;
typedef struct _FolksDebugClass FolksDebugClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_key_file_free0(var) ((var == NULL) ? NULL : (var = (g_key_file_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define FOLKS_TYPE_PERSONA_STORE (folks_persona_store_get_type ())
#define FOLKS_PERSONA_STORE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FOLKS_TYPE_PERSONA_STORE, FolksPersonaStore))
#define FOLKS_PERSONA_STORE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FOLKS_TYPE_PERSONA_STORE, FolksPersonaStoreClass))
#define FOLKS_IS_PERSONA_STORE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FOLKS_TYPE_PERSONA_STORE))
#define FOLKS_IS_PERSONA_STORE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FOLKS_TYPE_PERSONA_STORE))
#define FOLKS_PERSONA_STORE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FOLKS_TYPE_PERSONA_STORE, FolksPersonaStoreClass))

typedef struct _FolksPersonaStore FolksPersonaStore;
typedef struct _FolksPersonaStoreClass FolksPersonaStoreClass;

#define FOLKS_TYPE_PERSONA_STORE_TRUST (folks_persona_store_trust_get_type ())

#define FOLKS_TYPE_PERSONA (folks_persona_get_type ())
#define FOLKS_PERSONA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FOLKS_TYPE_PERSONA, FolksPersona))
#define FOLKS_PERSONA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FOLKS_TYPE_PERSONA, FolksPersonaClass))
#define FOLKS_IS_PERSONA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FOLKS_TYPE_PERSONA))
#define FOLKS_IS_PERSONA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FOLKS_TYPE_PERSONA))
#define FOLKS_PERSONA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FOLKS_TYPE_PERSONA, FolksPersonaClass))

typedef struct _FolksPersona FolksPersona;
typedef struct _FolksPersonaClass FolksPersonaClass;
typedef struct _FolksBackendStorePrepareData FolksBackendStorePrepareData;
typedef struct _Block1Data Block1Data;
typedef struct _FolksBackendStoreLoadBackendsData FolksBackendStoreLoadBackendsData;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _FolksBackendStoreBackendLoadIfNeededData FolksBackendStoreBackendLoadIfNeededData;
typedef struct _FolksBackendStoreBackendUnloadIfNeededData FolksBackendStoreBackendUnloadIfNeededData;
typedef struct _FolksBackendStoreEnableBackendData FolksBackendStoreEnableBackendData;
typedef struct _FolksBackendStoreDisableBackendData FolksBackendStoreDisableBackendData;
#define __g_list_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_object_unref0_ (var), NULL)))
typedef struct _FolksBackendStoreGetModulesFromDirData FolksBackendStoreGetModulesFromDirData;
#define _g_module_close0(var) ((var == NULL) ? NULL : (var = (g_module_close (var), NULL)))
typedef struct _FolksBackendStoreGetFileInfoData FolksBackendStoreGetFileInfoData;
typedef struct _FolksBackendStoreLoadDisabledBackendNamesData FolksBackendStoreLoadDisabledBackendNamesData;
typedef struct _FolksBackendStoreSaveKeyFileData FolksBackendStoreSaveKeyFileData;
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _FolksBackendStore {
	GObject parent_instance;
	FolksBackendStorePrivate * priv;
};

struct _FolksBackendStoreClass {
	GObjectClass parent_class;
};

struct _FolksBackendStorePrivate {
	GeeHashMap* _backend_hash;
	FolksSmallSet* _backends_allowed;
	FolksSmallSet* _backends_disabled;
	GeeHashMap* _prepared_backends;
	GeeMap* _prepared_backends_ro;
	GFile* _config_file;
	GKeyFile* _backends_key_file;
	GeeHashMap* _modules;
	gboolean _is_prepared;
	FolksDebug* _debug;
};

typedef void (*FolksBackendStoreModuleFinalizeFunc) (FolksBackendStore* store);
typedef enum  {
	FOLKS_PERSONA_STORE_TRUST_NONE,
	FOLKS_PERSONA_STORE_TRUST_PARTIAL,
	FOLKS_PERSONA_STORE_TRUST_FULL
} FolksPersonaStoreTrust;

struct _FolksBackendStorePrepareData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	FolksBackendStore* self;
	gboolean _tmp0_;
};

struct _Block1Data {
	int _ref_count_;
	FolksBackendStore* self;
	gint backends_remaining;
	gpointer _async_data_;
};

struct _FolksBackendStoreLoadBackendsData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	FolksBackendStore* self;
	Block1Data* _data1_;
	gboolean _tmp0_;
	GeeIterator* _backend_existing_it;
	GeeHashMap* _tmp1_;
	GeeCollection* _tmp2_;
	GeeCollection* _tmp3_;
	GeeCollection* _tmp4_;
	GeeIterator* _tmp5_;
	GeeIterator* _tmp6_;
	GeeIterator* _tmp7_;
	gboolean _tmp8_;
	FolksBackend* backend_existing;
	GeeIterator* _tmp9_;
	gpointer _tmp10_;
	FolksBackend* _tmp11_;
	gchar* _path;
	const gchar* _tmp12_;
	gchar* _tmp13_;
	gchar* path;
	const gchar* _tmp14_;
	gchar* _tmp15_;
	const gchar* _tmp16_;
	const gchar* _tmp17_;
	gchar* _tmp18_;
	const gchar* _tmp19_;
	GeeHashMap* modules;
	GeeHashMap* _tmp20_;
	gchar** path_split;
	const gchar* _tmp21_;
	gchar** _tmp22_;
	gchar** _tmp23_;
	gint path_split_length1;
	gint _path_split_size_;
	gchar** _tmp24_;
	gint _tmp24__length1;
	gchar** subpath_collection;
	gint subpath_collection_length1;
	gint _subpath_collection_size_;
	gint subpath_it;
	const gchar* subpath;
	GFile* file;
	const gchar* _tmp25_;
	GFile* _tmp26_;
	gboolean is_file;
	gboolean is_dir;
	GFile* _tmp27_;
	gboolean _tmp28_;
	gboolean _tmp29_;
	gboolean _tmp30_;
	GeeHashMap* _tmp31_;
	const gchar* _tmp32_;
	GFile* _tmp33_;
	gboolean _tmp34_;
	GeeHashMap* cur_modules;
	GFile* _tmp35_;
	GeeHashMap* _tmp36_;
	GeeHashMap* _tmp37_;
	GeeIterator* _entry_it;
	GeeHashMap* _tmp38_;
	GeeSet* _tmp39_;
	GeeSet* _tmp40_;
	GeeSet* _tmp41_;
	GeeIterator* _tmp42_;
	GeeIterator* _tmp43_;
	GeeIterator* _tmp44_;
	gboolean _tmp45_;
	GeeMapEntry* entry;
	GeeIterator* _tmp46_;
	gpointer _tmp47_;
	GeeHashMap* _tmp48_;
	GeeMapEntry* _tmp49_;
	gconstpointer _tmp50_;
	const gchar* _tmp51_;
	GeeMapEntry* _tmp52_;
	gconstpointer _tmp53_;
	GFile* _tmp54_;
	const gchar* _tmp55_;
	GeeIterator* _module_it;
	GeeHashMap* _tmp56_;
	GeeCollection* _tmp57_;
	GeeCollection* _tmp58_;
	GeeCollection* _tmp59_;
	GeeIterator* _tmp60_;
	GeeIterator* _tmp61_;
	GeeIterator* _tmp62_;
	gboolean _tmp63_;
	GFile* module;
	GeeIterator* _tmp64_;
	gpointer _tmp65_;
	GFile* _tmp66_;
	GeeIterator* _backend_it;
	GeeHashMap* _tmp67_;
	GeeCollection* _tmp68_;
	GeeCollection* _tmp69_;
	GeeCollection* _tmp70_;
	GeeIterator* _tmp71_;
	GeeIterator* _tmp72_;
	GeeIterator* _tmp73_;
	gboolean _tmp74_;
	FolksBackend* backend;
	GeeIterator* _tmp75_;
	gpointer _tmp76_;
	gint _tmp77_;
	FolksBackend* _tmp78_;
	gint _tmp79_;
	gint _tmp80_;
};

struct _FolksBackendStoreBackendLoadIfNeededData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	FolksBackendStore* self;
	FolksBackend* backend;
	FolksBackend* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	gboolean _tmp3_;
	GeeHashMap* _tmp4_;
	FolksBackend* _tmp5_;
	const gchar* _tmp6_;
	const gchar* _tmp7_;
	gboolean _tmp8_;
	FolksBackend* _tmp9_;
	FolksBackend* _tmp10_;
	const gchar* _tmp11_;
	const gchar* _tmp12_;
	GeeHashMap* _tmp13_;
	FolksBackend* _tmp14_;
	const gchar* _tmp15_;
	const gchar* _tmp16_;
	FolksBackend* _tmp17_;
	FolksBackend* _tmp18_;
	GError* e;
	GError* _tmp19_;
	FolksBackend* _tmp20_;
	const gchar* _tmp21_;
	const gchar* _tmp22_;
	GError* _tmp23_;
	const gchar* _tmp24_;
	FolksBackend* _tmp25_;
	const gchar* _tmp26_;
	const gchar* _tmp27_;
	GError* _tmp28_;
	const gchar* _tmp29_;
	GError * _inner_error_;
};

struct _FolksBackendStoreBackendUnloadIfNeededData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	FolksBackendStore* self;
	FolksBackend* backend;
	gboolean result;
	gboolean unloaded;
	FolksBackend* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	gboolean _tmp3_;
	FolksBackend* backend_existing;
	GeeHashMap* _tmp4_;
	FolksBackend* _tmp5_;
	const gchar* _tmp6_;
	const gchar* _tmp7_;
	gpointer _tmp8_;
	FolksBackend* _tmp9_;
	FolksBackend* _tmp10_;
	GError* e;
	FolksBackend* _tmp11_;
	const gchar* _tmp12_;
	const gchar* _tmp13_;
	GError* _tmp14_;
	const gchar* _tmp15_;
	GeeHashMap* _tmp16_;
	FolksBackend* _tmp17_;
	const gchar* _tmp18_;
	const gchar* _tmp19_;
	GError * _inner_error_;
};

struct _FolksBackendStoreEnableBackendData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	FolksBackendStore* self;
	gchar* name;
	GKeyFile* _tmp0_;
	const gchar* _tmp1_;
};

struct _FolksBackendStoreDisableBackendData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	FolksBackendStore* self;
	gchar* name;
	GKeyFile* _tmp0_;
	const gchar* _tmp1_;
};

struct _FolksBackendStoreGetModulesFromDirData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	FolksBackendStore* self;
	GFile* dir;
	GeeHashMap* result;
	GFile* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* attributes;
	gchar* _tmp3_;
	GList* infos;
	GFileEnumerator* enumerator;
	GFile* _tmp4_;
	const gchar* _tmp5_;
	GFileEnumerator* _tmp6_;
	GList* _tmp7_;
	GFileEnumerator* _tmp8_;
	GList* _tmp9_;
	GList* _tmp10_;
	GError* _error_;
	const gchar* _tmp11_;
	GFile* _tmp12_;
	gchar* _tmp13_;
	gchar* _tmp14_;
	GError* _tmp15_;
	const gchar* _tmp16_;
	GeeHashMap* modules_final;
	GeeHashMap* _tmp17_;
	gchar* _path;
	const gchar* _tmp18_;
	gchar* _tmp19_;
	GList* _tmp20_;
	GList* info_collection;
	GList* info_it;
	GFileInfo* _tmp21_;
	GFileInfo* info;
	GFile* file;
	GFile* _tmp22_;
	GFileInfo* _tmp23_;
	const gchar* _tmp24_;
	GFile* _tmp25_;
	GFileInfo* _tmp26_;
	gboolean _tmp27_;
	GFile* _tmp28_;
	gchar* _tmp29_;
	gchar* _tmp30_;
	GFileInfo* _tmp31_;
	const gchar* _tmp32_;
	GFile* old_file;
	GFile* _tmp33_;
	GFile* _tmp34_;
	GFile* _tmp35_;
	GFileInfo* _tmp36_;
	const gchar* _tmp37_;
	GFile* _tmp38_;
	GFileInfo* _tmp39_;
	GFile* _tmp40_;
	const gchar* _tmp41_;
	GFileInfo* _tmp42_;
	GFileInfo* _tmp43_;
	GError* _vala1__error_;
	const gchar* _tmp44_;
	GFile* _tmp45_;
	gchar* _tmp46_;
	gchar* _tmp47_;
	GFile* _tmp48_;
	gchar* _tmp49_;
	gchar* _tmp50_;
	GError* _tmp51_;
	const gchar* _tmp52_;
	GFileType file_type;
	GFileInfo* _tmp53_;
	GFileType _tmp54_;
	const gchar* content_type;
	GFileInfo* _tmp55_;
	const gchar* _tmp56_;
	gchar* mime;
	const gchar* _tmp57_;
	gchar* _tmp58_;
	GFileType _tmp59_;
	GeeHashMap* modules;
	GFile* _tmp60_;
	GeeHashMap* _tmp61_;
	GeeHashMap* _tmp62_;
	GeeIterator* _entry_it;
	GeeHashMap* _tmp63_;
	GeeSet* _tmp64_;
	GeeSet* _tmp65_;
	GeeSet* _tmp66_;
	GeeIterator* _tmp67_;
	GeeIterator* _tmp68_;
	GeeIterator* _tmp69_;
	gboolean _tmp70_;
	GeeMapEntry* entry;
	GeeIterator* _tmp71_;
	gpointer _tmp72_;
	GeeHashMap* _tmp73_;
	GeeMapEntry* _tmp74_;
	gconstpointer _tmp75_;
	const gchar* _tmp76_;
	GeeMapEntry* _tmp77_;
	gconstpointer _tmp78_;
	GFile* _tmp79_;
	const gchar* _tmp80_;
	gchar* path;
	GFile* _tmp81_;
	gchar* _tmp82_;
	const gchar* _tmp83_;
	GeeHashMap* _tmp84_;
	const gchar* _tmp85_;
	GFile* _tmp86_;
	const gchar* _tmp87_;
	GFile* _tmp88_;
	gchar* _tmp89_;
	gchar* _tmp90_;
	gboolean _tmp91_;
	gboolean _tmp92_;
	gboolean _tmp93_;
	const gchar* _tmp94_;
	const gchar* _tmp95_;
	const gchar* _tmp96_;
	const gchar* _tmp97_;
	GFile* _tmp98_;
	gchar* _tmp99_;
	gchar* _tmp100_;
	const gchar* _tmp101_;
	GFile* _tmp102_;
	gchar* _tmp103_;
	gchar* _tmp104_;
	GError * _inner_error_;
};

typedef void (*FolksBackendStoreModuleInitFunc) (FolksBackendStore* store);
struct _FolksBackendStoreGetFileInfoData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	GFile* file;
	gboolean is_file;
	gboolean is_dir;
	GFileInfo* file_info;
	GFileInfo* _tmp0_;
	GFile* _tmp1_;
	GFileInfo* _tmp2_;
	GFileInfo* _tmp3_;
	GError* _error_;
	GError* _tmp4_;
	const gchar* _tmp5_;
	GFile* _tmp6_;
	gchar* _tmp7_;
	gchar* _tmp8_;
	const gchar* _tmp9_;
	GFile* _tmp10_;
	gchar* _tmp11_;
	gchar* _tmp12_;
	GFileInfo* _tmp13_;
	GFileType _tmp14_;
	GFileInfo* _tmp15_;
	GFileType _tmp16_;
	GError * _inner_error_;
};

struct _FolksBackendStoreLoadDisabledBackendNamesData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	FolksBackendStore* self;
	gchar* envvar;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	const gchar* _tmp2_;
	gchar** tokens;
	const gchar* _tmp3_;
	gchar** _tmp4_;
	gchar** _tmp5_;
	gint tokens_length1;
	gint _tokens_size_;
	FolksSmallSet* _tmp6_;
	gchar** _tmp7_;
	gint _tmp7__length1;
	gchar** s_collection;
	gint s_collection_length1;
	gint _s_collection_size_;
	gint s_it;
	const gchar* s;
	const gchar* _tmp8_;
	const gchar* _tmp9_;
	FolksSmallSet* _tmp10_;
	const gchar* _tmp11_;
	FolksSmallSet* _tmp12_;
	gchar** _tmp13_;
	gint _tmp13__length1;
	gchar** _vala1_s_collection;
	gint _vala1_s_collection_length1;
	gint __vala1_s_collection_size_;
	gint _vala1_s_it;
	const gchar* _vala1_s;
	const gchar* _tmp14_;
	const gchar* _tmp15_;
	gchar* _tmp16_;
	const gchar* _tmp17_;
	gchar** _vala1_tokens;
	const gchar* _tmp18_;
	gchar** _tmp19_;
	gchar** _tmp20_;
	gint _vala1_tokens_length1;
	gint __vala1_tokens_size_;
	FolksSmallSet* _tmp21_;
	gchar** _tmp22_;
	gint _tmp22__length1;
	gchar** _vala2_s_collection;
	gint _vala2_s_collection_length1;
	gint __vala2_s_collection_size_;
	gint _vala2_s_it;
	const gchar* _vala2_s;
	const gchar* _tmp23_;
	const gchar* _tmp24_;
	FolksSmallSet* _tmp25_;
	const gchar* _tmp26_;
	GFile* file;
	const gchar* path;
	const gchar* _tmp27_;
	const gchar* _tmp28_;
	const gchar* _tmp29_;
	GFile* _tmp30_;
	GFile* _tmp31_;
	GFile* _tmp32_;
	GFile* _tmp33_;
	GFile* _tmp34_;
	GFile* _tmp35_;
	gchar* _tmp36_;
	gchar* _tmp37_;
	const gchar* _tmp38_;
	GFile* _tmp39_;
	const gchar* _tmp40_;
	GFile* _tmp41_;
	GFile* _tmp42_;
	GKeyFile* key_file;
	GKeyFile* _tmp43_;
	guint8* contents;
	gint contents_length1;
	gint _contents_size_;
	GFile* _tmp44_;
	guint8* _tmp45_;
	gsize _tmp46_;
	const gchar* contents_s;
	guint8* _tmp47_;
	gint _tmp47__length1;
	const gchar* _tmp48_;
	gint _tmp49_;
	gint _tmp50_;
	GKeyFile* _tmp51_;
	const gchar* _tmp52_;
	const gchar* _tmp53_;
	gint _tmp54_;
	gint _tmp55_;
	GError* e1;
	GError* _tmp56_;
	GFile* _tmp57_;
	gchar* _tmp58_;
	gchar* _tmp59_;
	GError* _tmp60_;
	const gchar* _tmp61_;
	GKeyFile* _tmp62_;
	GKeyFile* _tmp63_;
	GError * _inner_error_;
};

struct _FolksBackendStoreSaveKeyFileData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	FolksBackendStore* self;
	gchar* key_file_data;
	GKeyFile* _tmp0_;
	gchar* _tmp1_;
	GFile* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	GFile* _tmp5_;
	guint8* _tmp6_;
	gint _tmp6__length1;
	guint8* _tmp7_;
	gint _tmp7__length1;
	GError* e;
	GFile* _tmp8_;
	gchar* _tmp9_;
	gchar* _tmp10_;
	GError* _tmp11_;
	const gchar* _tmp12_;
	GError * _inner_error_;
};


static gpointer folks_backend_store_parent_class = NULL;
static FolksBackendStore* folks_backend_store__instance;
static FolksBackendStore* folks_backend_store__instance = NULL;
extern gchar* folks_backend_store_KEY_FILE_GROUP_ALL_OTHERS;
gchar* folks_backend_store_KEY_FILE_GROUP_ALL_OTHERS = NULL;

GType folks_backend_store_get_type (void) G_GNUC_CONST;
GType folks_backend_get_type (void) G_GNUC_CONST;
GType folks_debug_get_type (void) G_GNUC_CONST;
#define FOLKS_BACKEND_STORE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), FOLKS_TYPE_BACKEND_STORE, FolksBackendStorePrivate))
enum  {
	FOLKS_BACKEND_STORE_DUMMY_PROPERTY,
	FOLKS_BACKEND_STORE_ENABLED_BACKENDS,
	FOLKS_BACKEND_STORE_IS_PREPARED
};
void folks_backend_unprepare (FolksBackend* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void folks_backend_unprepare_finish (FolksBackend* self, GAsyncResult* _res_, GError** error);
static void _folks_backend_store_debug_print_status (FolksBackendStore* self, FolksDebug* debug);
static void __folks_backend_store_debug_print_status_folks_debug_print_status (FolksDebug* _sender, gpointer self);
FolksBackendStore* folks_backend_store_dup (void);
static FolksBackendStore* folks_backend_store_new (void);
static FolksBackendStore* folks_backend_store_construct (GType object_type);
#define FOLKS_DEBUG_STATUS_LOG_DOMAIN "folks-status"
void folks_debug_print_heading (FolksDebug* self, const gchar* domain, GLogLevelFlags level, const gchar* format, ...);
void folks_debug_print_line (FolksDebug* self, const gchar* domain, GLogLevelFlags level, const gchar* format, ...);
void folks_debug_indent (FolksDebug* self);
gboolean folks_backend_get_is_prepared (FolksBackend* self);
gboolean folks_backend_get_is_quiescent (FolksBackend* self);
void folks_debug_print_key_value_pairs (FolksDebug* self, const gchar* domain, GLogLevelFlags level, ...);
const gchar* folks_backend_get_name (FolksBackend* self);
GType folks_persona_store_get_type (void) G_GNUC_CONST;
GeeMap* folks_backend_get_persona_stores (FolksBackend* self);
GType folks_persona_store_trust_get_type (void) G_GNUC_CONST;
FolksPersonaStoreTrust folks_persona_store_get_trust_level (FolksPersonaStore* self);
gchar** folks_persona_store_get_always_writeable_properties (FolksPersonaStore* self, int* result_length1);
gboolean folks_persona_store_get_is_prepared (FolksPersonaStore* self);
gboolean folks_persona_store_get_is_primary_store (FolksPersonaStore* self);
gboolean folks_persona_store_get_is_quiescent (FolksPersonaStore* self);
const gchar* folks_persona_store_get_id (FolksPersonaStore* self);
GType folks_persona_get_type (void) G_GNUC_CONST;
GeeMap* folks_persona_store_get_personas (FolksPersonaStore* self);
void folks_debug_unindent (FolksDebug* self);
static void folks_backend_store_prepare_data_free (gpointer _data);
void folks_backend_store_prepare (FolksBackendStore* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void folks_backend_store_prepare_finish (FolksBackendStore* self, GAsyncResult* _res_);
static gboolean folks_backend_store_prepare_co (FolksBackendStorePrepareData* _data_);
static void _folks_backend_store_load_disabled_backend_names (FolksBackendStore* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
static void _folks_backend_store_load_disabled_backend_names_finish (FolksBackendStore* self, GAsyncResult* _res_);
static void folks_backend_store_prepare_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void folks_backend_store_load_backends_data_free (gpointer _data);
void folks_backend_store_load_backends (FolksBackendStore* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void folks_backend_store_load_backends_finish (FolksBackendStore* self, GAsyncResult* _res_, GError** error);
static gboolean folks_backend_store_load_backends_co (FolksBackendStoreLoadBackendsData* _data_);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static void folks_backend_store_load_backends_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void _folks_backend_store_backend_unload_if_needed (FolksBackendStore* self, FolksBackend* backend, GAsyncReadyCallback _callback_, gpointer _user_data_);
static gboolean _folks_backend_store_backend_unload_if_needed_finish (FolksBackendStore* self, GAsyncResult* _res_);
static void _folks_backend_store_get_file_info (GFile* file, GAsyncReadyCallback _callback_, gpointer _user_data_);
static void _folks_backend_store_get_file_info_finish (GAsyncResult* _res_, gboolean* is_file, gboolean* is_dir);
static void _folks_backend_store_get_modules_from_dir (FolksBackendStore* self, GFile* dir, GAsyncReadyCallback _callback_, gpointer _user_data_);
static GeeHashMap* _folks_backend_store_get_modules_from_dir_finish (FolksBackendStore* self, GAsyncResult* _res_);
static void _folks_backend_store_load_module_from_file (FolksBackendStore* self, GFile* file);
static void _folks_backend_store_backend_load_if_needed (FolksBackendStore* self, FolksBackend* backend, GAsyncReadyCallback _callback_, gpointer _user_data_);
static void _folks_backend_store_backend_load_if_needed_finish (FolksBackendStore* self, GAsyncResult* _res_);
static void ____lambda66_ (Block1Data* _data1_, GObject* o, GAsyncResult* r);
static void _____lambda66__gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self);
static void _folks_backend_store_backend_load_if_needed_data_free (gpointer _data);
static gboolean _folks_backend_store_backend_load_if_needed_co (FolksBackendStoreBackendLoadIfNeededData* _data_);
static gboolean _folks_backend_store_backend_is_enabled (FolksBackendStore* self, const gchar* name);
void folks_backend_prepare (FolksBackend* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void folks_backend_prepare_finish (FolksBackend* self, GAsyncResult* _res_, GError** error);
static void _folks_backend_store_backend_load_if_needed_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void _folks_backend_store_backend_unload_if_needed_data_free (gpointer _data);
static gboolean _folks_backend_store_backend_unload_if_needed_co (FolksBackendStoreBackendUnloadIfNeededData* _data_);
static void _folks_backend_store_backend_unload_if_needed_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
void folks_backend_store_add_backend (FolksBackendStore* self, FolksBackend* backend);
void _folks_debug_register_domain (FolksDebug* self, const gchar* domain);
FolksBackend* folks_backend_store_dup_backend_by_name (FolksBackendStore* self, const gchar* name);
GeeCollection* folks_backend_store_list_backends (FolksBackendStore* self);
static void folks_backend_store_enable_backend_data_free (gpointer _data);
void folks_backend_store_enable_backend (FolksBackendStore* self, const gchar* name, GAsyncReadyCallback _callback_, gpointer _user_data_);
void folks_backend_store_enable_backend_finish (FolksBackendStore* self, GAsyncResult* _res_);
static gboolean folks_backend_store_enable_backend_co (FolksBackendStoreEnableBackendData* _data_);
static void _folks_backend_store_save_key_file (FolksBackendStore* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
static void _folks_backend_store_save_key_file_finish (FolksBackendStore* self, GAsyncResult* _res_);
static void folks_backend_store_enable_backend_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void folks_backend_store_disable_backend_data_free (gpointer _data);
void folks_backend_store_disable_backend (FolksBackendStore* self, const gchar* name, GAsyncReadyCallback _callback_, gpointer _user_data_);
void folks_backend_store_disable_backend_finish (FolksBackendStore* self, GAsyncResult* _res_);
static gboolean folks_backend_store_disable_backend_co (FolksBackendStoreDisableBackendData* _data_);
static void folks_backend_store_disable_backend_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void _folks_backend_store_get_modules_from_dir_data_free (gpointer _data);
static gboolean _folks_backend_store_get_modules_from_dir_co (FolksBackendStoreGetModulesFromDirData* _data_);
static void _folks_backend_store_get_modules_from_dir_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void _g_object_unref0_ (gpointer var);
static void _g_list_free__g_object_unref0_ (GList* self);
static void _folks_backend_store_get_file_info_data_free (gpointer _data);
static gboolean _folks_backend_store_get_file_info_co (FolksBackendStoreGetFileInfoData* _data_);
static void _folks_backend_store_get_file_info_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void _folks_backend_store_load_disabled_backend_names_data_free (gpointer _data);
static gboolean _folks_backend_store_load_disabled_backend_names_co (FolksBackendStoreLoadDisabledBackendNamesData* _data_);
static void _folks_backend_store_load_disabled_backend_names_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void _folks_backend_store_save_key_file_data_free (gpointer _data);
static gboolean _folks_backend_store_save_key_file_co (FolksBackendStoreSaveKeyFileData* _data_);
static void _folks_backend_store_save_key_file_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
GeeMap* folks_backend_store_get_enabled_backends (FolksBackendStore* self);
static void folks_backend_store_set_enabled_backends (FolksBackendStore* self, GeeMap* value);
gboolean folks_backend_store_get_is_prepared (FolksBackendStore* self);
static void folks_backend_store_set_is_prepared (FolksBackendStore* self, gboolean value);
static GObject * folks_backend_store_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
FolksDebug* folks_debug_dup_with_flags (const gchar* debug_flags, gboolean colour_enabled);
static void folks_backend_store_finalize (GObject* obj);
static void _vala_folks_backend_store_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_folks_backend_store_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


static void __folks_backend_store_debug_print_status_folks_debug_print_status (FolksDebug* _sender, gpointer self) {
	_folks_backend_store_debug_print_status ((FolksBackendStore*) self, _sender);
}


/**
   * Create a new BackendStore.
   */
static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


FolksBackendStore* folks_backend_store_dup (void) {
	FolksBackendStore* result = NULL;
	FolksBackendStore* _tmp0_ = NULL;
	FolksBackendStore* _tmp3_ = NULL;
	FolksBackendStore* _tmp4_ = NULL;
	_tmp0_ = folks_backend_store__instance;
	if (_tmp0_ == NULL) {
		FolksBackendStore* new_instance = NULL;
		FolksBackendStore* _tmp1_ = NULL;
		FolksBackendStore* _tmp2_ = NULL;
		_tmp1_ = folks_backend_store_new ();
		new_instance = _tmp1_;
		_tmp2_ = new_instance;
		folks_backend_store__instance = _tmp2_;
		result = new_instance;
		return result;
	}
	_tmp3_ = folks_backend_store__instance;
	_tmp4_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp3_, FOLKS_TYPE_BACKEND_STORE, FolksBackendStore));
	result = _tmp4_;
	return result;
}


static FolksBackendStore* folks_backend_store_construct (GType object_type) {
	FolksBackendStore * self = NULL;
	self = (FolksBackendStore*) g_object_new (object_type, NULL);
	return self;
}


static FolksBackendStore* folks_backend_store_new (void) {
	return folks_backend_store_construct (FOLKS_TYPE_BACKEND_STORE);
}


static gchar* _vala_g_strjoinv (const gchar* separator, gchar** str_array, int str_array_length1) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gchar** _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	_tmp0_ = separator;
	if (_tmp0_ == NULL) {
		separator = "";
	}
	_tmp3_ = str_array;
	_tmp3__length1 = str_array_length1;
	if (_tmp3_ != NULL) {
		_tmp2_ = TRUE;
	} else {
		gchar** _tmp4_ = NULL;
		gint _tmp4__length1 = 0;
		_tmp4_ = str_array;
		_tmp4__length1 = str_array_length1;
		_tmp2_ = _tmp4__length1 > 0;
	}
	if (_tmp2_) {
		_tmp1_ = TRUE;
	} else {
		gboolean _tmp5_ = FALSE;
		gchar** _tmp6_ = NULL;
		gint _tmp6__length1 = 0;
		_tmp6_ = str_array;
		_tmp6__length1 = str_array_length1;
		if (_tmp6__length1 == (-1)) {
			gchar** _tmp7_ = NULL;
			gint _tmp7__length1 = 0;
			const gchar* _tmp8_ = NULL;
			_tmp7_ = str_array;
			_tmp7__length1 = str_array_length1;
			_tmp8_ = _tmp7_[0];
			_tmp5_ = _tmp8_ != NULL;
		} else {
			_tmp5_ = FALSE;
		}
		_tmp1_ = _tmp5_;
	}
	if (_tmp1_) {
		gint i = 0;
		gsize len = 0UL;
		gint _tmp31_ = 0;
		gint _tmp33_ = 0;
		gint _tmp34_ = 0;
		gsize _tmp35_ = 0UL;
		const gchar* _tmp36_ = NULL;
		gint _tmp37_ = 0;
		gint _tmp38_ = 0;
		gint _tmp39_ = 0;
		const gchar* res = NULL;
		gsize _tmp40_ = 0UL;
		void* _tmp41_ = NULL;
		void* ptr = NULL;
		const gchar* _tmp42_ = NULL;
		gchar** _tmp43_ = NULL;
		gint _tmp43__length1 = 0;
		const gchar* _tmp44_ = NULL;
		void* _tmp45_ = NULL;
		const gchar* _tmp62_ = NULL;
		len = (gsize) 1;
		{
			gboolean _tmp9_ = FALSE;
			i = 0;
			_tmp9_ = TRUE;
			while (TRUE) {
				gboolean _tmp11_ = FALSE;
				gboolean _tmp12_ = FALSE;
				gchar** _tmp13_ = NULL;
				gint _tmp13__length1 = 0;
				gint _tmp21_ = 0;
				gchar** _tmp22_ = NULL;
				gint _tmp22__length1 = 0;
				gint _tmp23_ = 0;
				const gchar* _tmp24_ = NULL;
				gsize _tmp30_ = 0UL;
				if (!_tmp9_) {
					gint _tmp10_ = 0;
					_tmp10_ = i;
					i = _tmp10_ + 1;
				}
				_tmp9_ = FALSE;
				_tmp13_ = str_array;
				_tmp13__length1 = str_array_length1;
				if (_tmp13__length1 != (-1)) {
					gint _tmp14_ = 0;
					gchar** _tmp15_ = NULL;
					gint _tmp15__length1 = 0;
					_tmp14_ = i;
					_tmp15_ = str_array;
					_tmp15__length1 = str_array_length1;
					_tmp12_ = _tmp14_ < _tmp15__length1;
				} else {
					_tmp12_ = FALSE;
				}
				if (_tmp12_) {
					_tmp11_ = TRUE;
				} else {
					gboolean _tmp16_ = FALSE;
					gchar** _tmp17_ = NULL;
					gint _tmp17__length1 = 0;
					_tmp17_ = str_array;
					_tmp17__length1 = str_array_length1;
					if (_tmp17__length1 == (-1)) {
						gchar** _tmp18_ = NULL;
						gint _tmp18__length1 = 0;
						gint _tmp19_ = 0;
						const gchar* _tmp20_ = NULL;
						_tmp18_ = str_array;
						_tmp18__length1 = str_array_length1;
						_tmp19_ = i;
						_tmp20_ = _tmp18_[_tmp19_];
						_tmp16_ = _tmp20_ != NULL;
					} else {
						_tmp16_ = FALSE;
					}
					_tmp11_ = _tmp16_;
				}
				if (!_tmp11_) {
					break;
				}
				_tmp22_ = str_array;
				_tmp22__length1 = str_array_length1;
				_tmp23_ = i;
				_tmp24_ = _tmp22_[_tmp23_];
				if (_tmp24_ != NULL) {
					gchar** _tmp25_ = NULL;
					gint _tmp25__length1 = 0;
					gint _tmp26_ = 0;
					const gchar* _tmp27_ = NULL;
					gint _tmp28_ = 0;
					gint _tmp29_ = 0;
					_tmp25_ = str_array;
					_tmp25__length1 = str_array_length1;
					_tmp26_ = i;
					_tmp27_ = _tmp25_[_tmp26_];
					_tmp28_ = strlen ((const gchar*) _tmp27_);
					_tmp29_ = _tmp28_;
					_tmp21_ = _tmp29_;
				} else {
					_tmp21_ = 0;
				}
				_tmp30_ = len;
				len = _tmp30_ + _tmp21_;
			}
		}
		_tmp31_ = i;
		if (_tmp31_ == 0) {
			gchar* _tmp32_ = NULL;
			_tmp32_ = g_strdup ("");
			result = _tmp32_;
			return result;
		}
		_tmp33_ = i;
		str_array_length1 = _tmp33_;
		_tmp34_ = str_array_length1;
		_tmp35_ = len;
		_tmp36_ = separator;
		_tmp37_ = strlen ((const gchar*) _tmp36_);
		_tmp38_ = _tmp37_;
		_tmp39_ = i;
		len = _tmp35_ + (_tmp38_ * (_tmp39_ - 1));
		_tmp40_ = len;
		_tmp41_ = g_malloc (_tmp40_);
		res = _tmp41_;
		_tmp42_ = res;
		_tmp43_ = str_array;
		_tmp43__length1 = str_array_length1;
		_tmp44_ = _tmp43_[0];
		_tmp45_ = g_stpcpy ((void*) _tmp42_, (const gchar*) _tmp44_);
		ptr = _tmp45_;
		{
			gboolean _tmp46_ = FALSE;
			i = 1;
			_tmp46_ = TRUE;
			while (TRUE) {
				gint _tmp48_ = 0;
				gchar** _tmp49_ = NULL;
				gint _tmp49__length1 = 0;
				void* _tmp50_ = NULL;
				const gchar* _tmp51_ = NULL;
				void* _tmp52_ = NULL;
				const gchar* _tmp53_ = NULL;
				gchar** _tmp54_ = NULL;
				gint _tmp54__length1 = 0;
				gint _tmp55_ = 0;
				const gchar* _tmp56_ = NULL;
				void* _tmp60_ = NULL;
				void* _tmp61_ = NULL;
				if (!_tmp46_) {
					gint _tmp47_ = 0;
					_tmp47_ = i;
					i = _tmp47_ + 1;
				}
				_tmp46_ = FALSE;
				_tmp48_ = i;
				_tmp49_ = str_array;
				_tmp49__length1 = str_array_length1;
				if (!(_tmp48_ < _tmp49__length1)) {
					break;
				}
				_tmp50_ = ptr;
				_tmp51_ = separator;
				_tmp52_ = g_stpcpy (_tmp50_, (const gchar*) _tmp51_);
				ptr = _tmp52_;
				_tmp54_ = str_array;
				_tmp54__length1 = str_array_length1;
				_tmp55_ = i;
				_tmp56_ = _tmp54_[_tmp55_];
				if (_tmp56_ != NULL) {
					gchar** _tmp57_ = NULL;
					gint _tmp57__length1 = 0;
					gint _tmp58_ = 0;
					const gchar* _tmp59_ = NULL;
					_tmp57_ = str_array;
					_tmp57__length1 = str_array_length1;
					_tmp58_ = i;
					_tmp59_ = _tmp57_[_tmp58_];
					_tmp53_ = (const gchar*) _tmp59_;
				} else {
					_tmp53_ = "";
				}
				_tmp60_ = ptr;
				_tmp61_ = g_stpcpy (_tmp60_, _tmp53_);
				ptr = _tmp61_;
			}
		}
		_tmp62_ = res;
		res = NULL;
		result = (gchar*) _tmp62_;
		return result;
	} else {
		gchar* _tmp63_ = NULL;
		_tmp63_ = g_strdup ("");
		result = _tmp63_;
		return result;
	}
}


static void _folks_backend_store_debug_print_status (FolksBackendStore* self, FolksDebug* debug) {
	static const char domain[] = FOLKS_DEBUG_STATUS_LOG_DOMAIN;
	static const GLogLevelFlags level = G_LOG_LEVEL_INFO;
	FolksDebug* _tmp0_ = NULL;
	FolksDebug* _tmp1_ = NULL;
	GeeHashMap* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
	FolksDebug* _tmp5_ = NULL;
	FolksDebug* _tmp93_ = NULL;
	FolksDebug* _tmp94_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (debug != NULL);
	_tmp0_ = debug;
	folks_debug_print_heading (_tmp0_, domain, level, "BackendStore (%p)", self);
	_tmp1_ = debug;
	_tmp2_ = self->priv->_backend_hash;
	_tmp3_ = gee_abstract_map_get_size ((GeeMap*) _tmp2_);
	_tmp4_ = _tmp3_;
	folks_debug_print_line (_tmp1_, domain, level, "%u Backends:", (guint) _tmp4_);
	_tmp5_ = debug;
	folks_debug_indent (_tmp5_);
	{
		GeeIterator* _backend_it = NULL;
		GeeHashMap* _tmp6_ = NULL;
		GeeCollection* _tmp7_ = NULL;
		GeeCollection* _tmp8_ = NULL;
		GeeCollection* _tmp9_ = NULL;
		GeeIterator* _tmp10_ = NULL;
		GeeIterator* _tmp11_ = NULL;
		_tmp6_ = self->priv->_backend_hash;
		_tmp7_ = gee_abstract_map_get_values ((GeeMap*) _tmp6_);
		_tmp8_ = _tmp7_;
		_tmp9_ = _tmp8_;
		_tmp10_ = gee_iterable_iterator ((GeeIterable*) _tmp9_);
		_tmp11_ = _tmp10_;
		_g_object_unref0 (_tmp9_);
		_backend_it = _tmp11_;
		while (TRUE) {
			GeeIterator* _tmp12_ = NULL;
			gboolean _tmp13_ = FALSE;
			FolksBackend* backend = NULL;
			GeeIterator* _tmp14_ = NULL;
			gpointer _tmp15_ = NULL;
			FolksDebug* _tmp16_ = NULL;
			FolksBackend* _tmp17_ = NULL;
			const gchar* _tmp18_ = NULL;
			FolksBackend* _tmp19_ = NULL;
			gboolean _tmp20_ = FALSE;
			gboolean _tmp21_ = FALSE;
			const gchar* _tmp22_ = NULL;
			FolksBackend* _tmp23_ = NULL;
			gboolean _tmp24_ = FALSE;
			gboolean _tmp25_ = FALSE;
			FolksDebug* _tmp26_ = NULL;
			guint _tmp27_ = 0U;
			gchar* _tmp28_ = NULL;
			gchar* _tmp29_ = NULL;
			FolksBackend* _tmp30_ = NULL;
			const gchar* _tmp31_ = NULL;
			const gchar* _tmp32_ = NULL;
			FolksDebug* _tmp33_ = NULL;
			FolksBackend* _tmp34_ = NULL;
			GeeMap* _tmp35_ = NULL;
			GeeMap* _tmp36_ = NULL;
			gint _tmp37_ = 0;
			gint _tmp38_ = 0;
			FolksDebug* _tmp39_ = NULL;
			FolksDebug* _tmp92_ = NULL;
			_tmp12_ = _backend_it;
			_tmp13_ = gee_iterator_next (_tmp12_);
			if (!_tmp13_) {
				break;
			}
			_tmp14_ = _backend_it;
			_tmp15_ = gee_iterator_get (_tmp14_);
			backend = (FolksBackend*) _tmp15_;
			_tmp16_ = debug;
			_tmp17_ = backend;
			folks_debug_print_heading (_tmp16_, domain, level, "Backend (%p)", _tmp17_);
			_tmp19_ = backend;
			_tmp20_ = folks_backend_get_is_prepared (_tmp19_);
			_tmp21_ = _tmp20_;
			if (_tmp21_) {
				_tmp18_ = "yes";
			} else {
				_tmp18_ = "no";
			}
			_tmp23_ = backend;
			_tmp24_ = folks_backend_get_is_quiescent (_tmp23_);
			_tmp25_ = _tmp24_;
			if (_tmp25_) {
				_tmp22_ = "yes";
			} else {
				_tmp22_ = "no";
			}
			_tmp26_ = debug;
			_tmp27_ = ((GObject*) self)->ref_count;
			_tmp28_ = g_strdup_printf ("%u", _tmp27_);
			_tmp29_ = _tmp28_;
			_tmp30_ = backend;
			_tmp31_ = folks_backend_get_name (_tmp30_);
			_tmp32_ = _tmp31_;
			folks_debug_print_key_value_pairs (_tmp26_, domain, level, "Ref. count", _tmp29_, "Name", _tmp32_, "Prepared?", _tmp18_, "Quiescent?", _tmp22_, NULL);
			_g_free0 (_tmp29_);
			_tmp33_ = debug;
			_tmp34_ = backend;
			_tmp35_ = folks_backend_get_persona_stores (_tmp34_);
			_tmp36_ = _tmp35_;
			_tmp37_ = gee_map_get_size (_tmp36_);
			_tmp38_ = _tmp37_;
			folks_debug_print_line (_tmp33_, domain, level, "%u PersonaStores:", (guint) _tmp38_);
			_tmp39_ = debug;
			folks_debug_indent (_tmp39_);
			{
				GeeIterator* _persona_store_it = NULL;
				FolksBackend* _tmp40_ = NULL;
				GeeMap* _tmp41_ = NULL;
				GeeMap* _tmp42_ = NULL;
				GeeCollection* _tmp43_ = NULL;
				GeeCollection* _tmp44_ = NULL;
				GeeCollection* _tmp45_ = NULL;
				GeeIterator* _tmp46_ = NULL;
				GeeIterator* _tmp47_ = NULL;
				_tmp40_ = backend;
				_tmp41_ = folks_backend_get_persona_stores (_tmp40_);
				_tmp42_ = _tmp41_;
				_tmp43_ = gee_map_get_values (_tmp42_);
				_tmp44_ = _tmp43_;
				_tmp45_ = _tmp44_;
				_tmp46_ = gee_iterable_iterator ((GeeIterable*) _tmp45_);
				_tmp47_ = _tmp46_;
				_g_object_unref0 (_tmp45_);
				_persona_store_it = _tmp47_;
				while (TRUE) {
					GeeIterator* _tmp48_ = NULL;
					gboolean _tmp49_ = FALSE;
					FolksPersonaStore* persona_store = NULL;
					GeeIterator* _tmp50_ = NULL;
					gpointer _tmp51_ = NULL;
					gchar* trust_level = NULL;
					FolksPersonaStore* _tmp52_ = NULL;
					FolksPersonaStoreTrust _tmp53_ = 0;
					FolksPersonaStoreTrust _tmp54_ = 0;
					gchar* writeable_props = NULL;
					FolksPersonaStore* _tmp58_ = NULL;
					gchar** _tmp59_ = NULL;
					gint _tmp59__length1 = 0;
					gchar** _tmp60_ = NULL;
					gint _tmp60__length1 = 0;
					gchar* _tmp61_ = NULL;
					FolksDebug* _tmp62_ = NULL;
					FolksPersonaStore* _tmp63_ = NULL;
					const gchar* _tmp64_ = NULL;
					FolksPersonaStore* _tmp65_ = NULL;
					gboolean _tmp66_ = FALSE;
					gboolean _tmp67_ = FALSE;
					const gchar* _tmp68_ = NULL;
					FolksPersonaStore* _tmp69_ = NULL;
					gboolean _tmp70_ = FALSE;
					gboolean _tmp71_ = FALSE;
					const gchar* _tmp72_ = NULL;
					FolksPersonaStore* _tmp73_ = NULL;
					gboolean _tmp74_ = FALSE;
					gboolean _tmp75_ = FALSE;
					FolksDebug* _tmp76_ = NULL;
					guint _tmp77_ = 0U;
					gchar* _tmp78_ = NULL;
					gchar* _tmp79_ = NULL;
					FolksPersonaStore* _tmp80_ = NULL;
					const gchar* _tmp81_ = NULL;
					const gchar* _tmp82_ = NULL;
					const gchar* _tmp83_ = NULL;
					const gchar* _tmp84_ = NULL;
					FolksPersonaStore* _tmp85_ = NULL;
					GeeMap* _tmp86_ = NULL;
					GeeMap* _tmp87_ = NULL;
					gint _tmp88_ = 0;
					gint _tmp89_ = 0;
					gchar* _tmp90_ = NULL;
					gchar* _tmp91_ = NULL;
					_tmp48_ = _persona_store_it;
					_tmp49_ = gee_iterator_next (_tmp48_);
					if (!_tmp49_) {
						break;
					}
					_tmp50_ = _persona_store_it;
					_tmp51_ = gee_iterator_get (_tmp50_);
					persona_store = (FolksPersonaStore*) _tmp51_;
					trust_level = NULL;
					_tmp52_ = persona_store;
					_tmp53_ = folks_persona_store_get_trust_level (_tmp52_);
					_tmp54_ = _tmp53_;
					switch (_tmp54_) {
						case FOLKS_PERSONA_STORE_TRUST_NONE:
						{
							gchar* _tmp55_ = NULL;
							_tmp55_ = g_strdup ("none");
							_g_free0 (trust_level);
							trust_level = _tmp55_;
							break;
						}
						case FOLKS_PERSONA_STORE_TRUST_PARTIAL:
						{
							gchar* _tmp56_ = NULL;
							_tmp56_ = g_strdup ("partial");
							_g_free0 (trust_level);
							trust_level = _tmp56_;
							break;
						}
						case FOLKS_PERSONA_STORE_TRUST_FULL:
						{
							gchar* _tmp57_ = NULL;
							_tmp57_ = g_strdup ("full");
							_g_free0 (trust_level);
							trust_level = _tmp57_;
							break;
						}
						default:
						{
							g_assert_not_reached ();
						}
					}
					_tmp58_ = persona_store;
					_tmp59_ = folks_persona_store_get_always_writeable_properties (_tmp58_, &_tmp59__length1);
					_tmp60_ = _tmp59_;
					_tmp60__length1 = _tmp59__length1;
					_tmp61_ = _vala_g_strjoinv (",", _tmp60_, _tmp60__length1);
					writeable_props = _tmp61_;
					_tmp62_ = debug;
					_tmp63_ = persona_store;
					folks_debug_print_heading (_tmp62_, domain, level, "PersonaStore (%p)", _tmp63_);
					_tmp65_ = persona_store;
					_tmp66_ = folks_persona_store_get_is_prepared (_tmp65_);
					_tmp67_ = _tmp66_;
					if (_tmp67_) {
						_tmp64_ = "yes";
					} else {
						_tmp64_ = "no";
					}
					_tmp69_ = persona_store;
					_tmp70_ = folks_persona_store_get_is_primary_store (_tmp69_);
					_tmp71_ = _tmp70_;
					if (_tmp71_) {
						_tmp68_ = "yes";
					} else {
						_tmp68_ = "no";
					}
					_tmp73_ = persona_store;
					_tmp74_ = folks_persona_store_get_is_quiescent (_tmp73_);
					_tmp75_ = _tmp74_;
					if (_tmp75_) {
						_tmp72_ = "yes";
					} else {
						_tmp72_ = "no";
					}
					_tmp76_ = debug;
					_tmp77_ = ((GObject*) self)->ref_count;
					_tmp78_ = g_strdup_printf ("%u", _tmp77_);
					_tmp79_ = _tmp78_;
					_tmp80_ = persona_store;
					_tmp81_ = folks_persona_store_get_id (_tmp80_);
					_tmp82_ = _tmp81_;
					_tmp83_ = writeable_props;
					_tmp84_ = trust_level;
					_tmp85_ = persona_store;
					_tmp86_ = folks_persona_store_get_personas (_tmp85_);
					_tmp87_ = _tmp86_;
					_tmp88_ = gee_map_get_size (_tmp87_);
					_tmp89_ = _tmp88_;
					_tmp90_ = g_strdup_printf ("%i", _tmp89_);
					_tmp91_ = _tmp90_;
					folks_debug_print_key_value_pairs (_tmp76_, domain, level, "Ref. count", _tmp79_, "ID", _tmp82_, "Prepared?", _tmp64_, "Is primary store?", _tmp68_, "Always writeable properties", _tmp83_, "Quiescent?", _tmp72_, "Trust level", _tmp84_, "Persona count", _tmp91_, NULL);
					_g_free0 (_tmp91_);
					_g_free0 (_tmp79_);
					_g_free0 (writeable_props);
					_g_free0 (trust_level);
					_g_object_unref0 (persona_store);
				}
				_g_object_unref0 (_persona_store_it);
			}
			_tmp92_ = debug;
			folks_debug_unindent (_tmp92_);
			_g_object_unref0 (backend);
		}
		_g_object_unref0 (_backend_it);
	}
	_tmp93_ = debug;
	folks_debug_unindent (_tmp93_);
	_tmp94_ = debug;
	folks_debug_print_line (_tmp94_, domain, level, "");
}


static void folks_backend_store_prepare_data_free (gpointer _data) {
	FolksBackendStorePrepareData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (FolksBackendStorePrepareData, _data_);
}


void folks_backend_store_prepare (FolksBackendStore* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	FolksBackendStorePrepareData* _data_;
	FolksBackendStore* _tmp0_ = NULL;
	_data_ = g_slice_new0 (FolksBackendStorePrepareData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, folks_backend_store_prepare);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, folks_backend_store_prepare_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	folks_backend_store_prepare_co (_data_);
}


void folks_backend_store_prepare_finish (FolksBackendStore* self, GAsyncResult* _res_) {
	FolksBackendStorePrepareData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


/**
   * Prepare the BackendStore for use.
   *
   * This must only ever be called before {@link BackendStore.load_backends} is
   * called for the first time. If it isn't called explicitly,
   * {@link BackendStore.load_backends} will call it.
   *
   * This method is safe to call multiple times concurrently (e.g. an
   * asynchronous call may begin between a subsequent asynchronous call
   * beginning and finishing).
   *
   * @since 0.3.0
   */
static void folks_backend_store_prepare_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	FolksBackendStorePrepareData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	folks_backend_store_prepare_co (_data_);
}


static gboolean folks_backend_store_prepare_co (FolksBackendStorePrepareData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	folks_internal_profiling_start ("preparing BackendStore", NULL);
	_data_->_state_ = 1;
	_folks_backend_store_load_disabled_backend_names (_data_->self, folks_backend_store_prepare_ready, _data_);
	return FALSE;
	_state_1:
	_folks_backend_store_load_disabled_backend_names_finish (_data_->self, _data_->_res_);
	_data_->_tmp0_ = FALSE;
	_data_->_tmp0_ = _data_->self->priv->_is_prepared;
	if (_data_->_tmp0_ == FALSE) {
		_data_->self->priv->_is_prepared = TRUE;
		g_object_notify ((GObject*) _data_->self, "is-prepared");
	}
	folks_internal_profiling_end ("preparing BackendStore", NULL);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void folks_backend_store_load_backends_data_free (gpointer _data) {
	FolksBackendStoreLoadBackendsData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (FolksBackendStoreLoadBackendsData, _data_);
}


void folks_backend_store_load_backends (FolksBackendStore* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	FolksBackendStoreLoadBackendsData* _data_;
	FolksBackendStore* _tmp0_ = NULL;
	_data_ = g_slice_new0 (FolksBackendStoreLoadBackendsData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, folks_backend_store_load_backends);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, folks_backend_store_load_backends_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	folks_backend_store_load_backends_co (_data_);
}


void folks_backend_store_load_backends_finish (FolksBackendStore* self, GAsyncResult* _res_, GError** error) {
	FolksBackendStoreLoadBackendsData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


/**
   * Find, load, and prepare all backends which are not disabled.
   *
   * Backends will be searched for in the path given by the
   * ``FOLKS_BACKEND_PATH`` environment variable, if it's set. If it's not set,
   * backends will be searched for in a path set at compilation time.
   *
   * This method is not safe to call multiple times concurrently.
   *
   * @throws GLib.Error currently unused
   */
static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (void * _userdata_) {
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		FolksBackendStore* self;
		self = _data1_->self;
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}


static void folks_backend_store_load_backends_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	FolksBackendStoreLoadBackendsData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	folks_backend_store_load_backends_co (_data_);
}


static void ____lambda66_ (Block1Data* _data1_, GObject* o, GAsyncResult* r) {
	FolksBackendStore* self;
	GAsyncResult* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	self = _data1_->self;
	g_return_if_fail (r != NULL);
	_tmp0_ = r;
	_folks_backend_store_backend_load_if_needed_finish (self, _tmp0_);
	_tmp1_ = _data1_->backends_remaining;
	_data1_->backends_remaining = _tmp1_ - 1;
	_tmp2_ = _data1_->backends_remaining;
	if (_tmp2_ == 0) {
		folks_backend_store_load_backends_co (_data1_->_async_data_);
	}
}


static void _____lambda66__gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self) {
	____lambda66_ (self, source_object, res);
	block1_data_unref (self);
}


static gboolean folks_backend_store_load_backends_co (FolksBackendStoreLoadBackendsData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		case 3:
		goto _state_3;
		case 4:
		goto _state_4;
		case 5:
		goto _state_5;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_data1_ = g_slice_new0 (Block1Data);
	_data_->_data1_->_ref_count_ = 1;
	_data_->_data1_->self = g_object_ref (_data_->self);
	_data_->_data1_->_async_data_ = _data_;
	_data_->_tmp0_ = FALSE;
	_data_->_tmp0_ = g_module_supported ();
	_vala_assert (_data_->_tmp0_, "Module.supported()");
	folks_internal_profiling_start ("loading backends in BackendStore", NULL);
	_data_->_state_ = 1;
	folks_backend_store_prepare (_data_->self, folks_backend_store_load_backends_ready, _data_);
	return FALSE;
	_state_1:
	folks_backend_store_prepare_finish (_data_->self, _data_->_res_);
	{
		_data_->_tmp1_ = NULL;
		_data_->_tmp1_ = _data_->self->priv->_backend_hash;
		_data_->_tmp2_ = NULL;
		_data_->_tmp2_ = gee_abstract_map_get_values ((GeeMap*) _data_->_tmp1_);
		_data_->_tmp3_ = NULL;
		_data_->_tmp3_ = _data_->_tmp2_;
		_data_->_tmp4_ = NULL;
		_data_->_tmp4_ = _data_->_tmp3_;
		_data_->_tmp5_ = NULL;
		_data_->_tmp5_ = gee_iterable_iterator ((GeeIterable*) _data_->_tmp4_);
		_data_->_tmp6_ = NULL;
		_data_->_tmp6_ = _data_->_tmp5_;
		_g_object_unref0 (_data_->_tmp4_);
		_data_->_backend_existing_it = _data_->_tmp6_;
		while (TRUE) {
			_data_->_tmp7_ = NULL;
			_data_->_tmp7_ = _data_->_backend_existing_it;
			_data_->_tmp8_ = FALSE;
			_data_->_tmp8_ = gee_iterator_next (_data_->_tmp7_);
			if (!_data_->_tmp8_) {
				break;
			}
			_data_->_tmp9_ = NULL;
			_data_->_tmp9_ = _data_->_backend_existing_it;
			_data_->_tmp10_ = NULL;
			_data_->_tmp10_ = gee_iterator_get (_data_->_tmp9_);
			_data_->backend_existing = (FolksBackend*) _data_->_tmp10_;
			_data_->_tmp11_ = NULL;
			_data_->_tmp11_ = _data_->backend_existing;
			_data_->_state_ = 2;
			_folks_backend_store_backend_unload_if_needed (_data_->self, _data_->_tmp11_, folks_backend_store_load_backends_ready, _data_);
			return FALSE;
			_state_2:
			_folks_backend_store_backend_unload_if_needed_finish (_data_->self, _data_->_res_);
			_g_object_unref0 (_data_->backend_existing);
		}
		_g_object_unref0 (_data_->_backend_existing_it);
	}
	folks_internal_profiling_point ("unloaded backends in BackendStore");
	_data_->_tmp12_ = NULL;
	_data_->_tmp12_ = g_getenv ("FOLKS_BACKEND_PATH");
	_data_->_tmp13_ = NULL;
	_data_->_tmp13_ = g_strdup (_data_->_tmp12_);
	_data_->_path = _data_->_tmp13_;
	_data_->_tmp14_ = NULL;
	_data_->_tmp14_ = _data_->_path;
	if (_data_->_tmp14_ == NULL) {
		_data_->_tmp15_ = NULL;
		_data_->_tmp15_ = g_strdup (BACKEND_DIR);
		_g_free0 (_data_->path);
		_data_->path = _data_->_tmp15_;
		_data_->_tmp16_ = NULL;
		_data_->_tmp16_ = _data_->path;
		g_debug ("Using built-in backend dir '%s' (override with " "environment variable FOLKS_BACKEND_PATH)", _data_->_tmp16_);
	} else {
		_data_->_tmp17_ = NULL;
		_data_->_tmp17_ = _data_->_path;
		_data_->_tmp18_ = NULL;
		_data_->_tmp18_ = g_strdup ((const gchar*) _data_->_tmp17_);
		_g_free0 (_data_->path);
		_data_->path = _data_->_tmp18_;
		_data_->_tmp19_ = NULL;
		_data_->_tmp19_ = _data_->path;
		g_debug ("Using environment variable FOLKS_BACKEND_PATH = " "'%s' to look for backends", _data_->_tmp19_);
	}
	_data_->_tmp20_ = NULL;
	_data_->_tmp20_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_FILE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	_data_->modules = _data_->_tmp20_;
	_data_->_tmp21_ = NULL;
	_data_->_tmp21_ = _data_->path;
	_data_->_tmp22_ = NULL;
	_data_->_tmp23_ = NULL;
	_data_->_tmp23_ = _data_->_tmp22_ = g_strsplit (_data_->_tmp21_, ":", 0);
	_data_->path_split_length1 = 0;
	_data_->_path_split_size_ = 0;
	_data_->path_split = _data_->_tmp23_;
	_data_->path_split_length1 = _vala_array_length (_data_->_tmp22_);
	_data_->_path_split_size_ = _data_->path_split_length1;
	_data_->_tmp24_ = NULL;
	_data_->_tmp24__length1 = 0;
	_data_->_tmp24_ = _data_->path_split;
	_data_->_tmp24__length1 = _data_->path_split_length1;
	{
		_data_->subpath_collection_length1 = 0;
		_data_->_subpath_collection_size_ = 0;
		_data_->subpath_collection = _data_->_tmp24_;
		_data_->subpath_collection_length1 = _data_->_tmp24__length1;
		for (_data_->subpath_it = 0; _data_->subpath_it < _data_->_tmp24__length1; _data_->subpath_it = _data_->subpath_it + 1) {
			_data_->subpath = _data_->subpath_collection[_data_->subpath_it];
			{
				_data_->_tmp25_ = NULL;
				_data_->_tmp25_ = _data_->subpath;
				_data_->_tmp26_ = NULL;
				_data_->_tmp26_ = g_file_new_for_path (_data_->_tmp25_);
				_data_->file = _data_->_tmp26_;
				_data_->_tmp27_ = NULL;
				_data_->_tmp27_ = _data_->file;
				_data_->_tmp28_ = FALSE;
				_data_->_tmp29_ = FALSE;
				_data_->_state_ = 3;
				_folks_backend_store_get_file_info (_data_->_tmp27_, folks_backend_store_load_backends_ready, _data_);
				return FALSE;
				_state_3:
				_folks_backend_store_get_file_info_finish (_data_->_res_, &_data_->_tmp28_, &_data_->_tmp29_);
				_data_->is_file = _data_->_tmp28_;
				_data_->is_dir = _data_->_tmp29_;
				_data_->_tmp30_ = FALSE;
				_data_->_tmp30_ = _data_->is_file;
				if (_data_->_tmp30_) {
					_data_->_tmp31_ = NULL;
					_data_->_tmp31_ = _data_->modules;
					_data_->_tmp32_ = NULL;
					_data_->_tmp32_ = _data_->subpath;
					_data_->_tmp33_ = NULL;
					_data_->_tmp33_ = _data_->file;
					gee_abstract_map_set ((GeeAbstractMap*) _data_->_tmp31_, _data_->_tmp32_, _data_->_tmp33_);
				} else {
					_data_->_tmp34_ = FALSE;
					_data_->_tmp34_ = _data_->is_dir;
					if (_data_->_tmp34_) {
						_data_->_tmp35_ = NULL;
						_data_->_tmp35_ = _data_->file;
						_data_->_state_ = 4;
						_folks_backend_store_get_modules_from_dir (_data_->self, _data_->_tmp35_, folks_backend_store_load_backends_ready, _data_);
						return FALSE;
						_state_4:
						_data_->_tmp36_ = NULL;
						_data_->_tmp36_ = _folks_backend_store_get_modules_from_dir_finish (_data_->self, _data_->_res_);
						_data_->cur_modules = _data_->_tmp36_;
						_data_->_tmp37_ = NULL;
						_data_->_tmp37_ = _data_->cur_modules;
						if (_data_->_tmp37_ != NULL) {
							{
								_data_->_tmp38_ = NULL;
								_data_->_tmp38_ = _data_->cur_modules;
								_data_->_tmp39_ = NULL;
								_data_->_tmp39_ = gee_abstract_map_get_entries ((GeeMap*) G_TYPE_CHECK_INSTANCE_CAST (_data_->_tmp38_, GEE_TYPE_HASH_MAP, GeeHashMap));
								_data_->_tmp40_ = NULL;
								_data_->_tmp40_ = _data_->_tmp39_;
								_data_->_tmp41_ = NULL;
								_data_->_tmp41_ = _data_->_tmp40_;
								_data_->_tmp42_ = NULL;
								_data_->_tmp42_ = gee_iterable_iterator ((GeeIterable*) _data_->_tmp41_);
								_data_->_tmp43_ = NULL;
								_data_->_tmp43_ = _data_->_tmp42_;
								_g_object_unref0 (_data_->_tmp41_);
								_data_->_entry_it = _data_->_tmp43_;
								while (TRUE) {
									_data_->_tmp44_ = NULL;
									_data_->_tmp44_ = _data_->_entry_it;
									_data_->_tmp45_ = FALSE;
									_data_->_tmp45_ = gee_iterator_next (_data_->_tmp44_);
									if (!_data_->_tmp45_) {
										break;
									}
									_data_->_tmp46_ = NULL;
									_data_->_tmp46_ = _data_->_entry_it;
									_data_->_tmp47_ = NULL;
									_data_->_tmp47_ = gee_iterator_get (_data_->_tmp46_);
									_data_->entry = (GeeMapEntry*) _data_->_tmp47_;
									_data_->_tmp48_ = NULL;
									_data_->_tmp48_ = _data_->modules;
									_data_->_tmp49_ = NULL;
									_data_->_tmp49_ = _data_->entry;
									_data_->_tmp50_ = NULL;
									_data_->_tmp50_ = gee_map_entry_get_key (_data_->_tmp49_);
									_data_->_tmp51_ = NULL;
									_data_->_tmp51_ = _data_->_tmp50_;
									_data_->_tmp52_ = NULL;
									_data_->_tmp52_ = _data_->entry;
									_data_->_tmp53_ = NULL;
									_data_->_tmp53_ = gee_map_entry_get_value (_data_->_tmp52_);
									_data_->_tmp54_ = NULL;
									_data_->_tmp54_ = _data_->_tmp53_;
									gee_abstract_map_set ((GeeAbstractMap*) _data_->_tmp48_, (const gchar*) _data_->_tmp51_, (GFile*) _data_->_tmp54_);
									_g_object_unref0 (_data_->entry);
								}
								_g_object_unref0 (_data_->_entry_it);
							}
						}
						_g_object_unref0 (_data_->cur_modules);
					} else {
						_data_->_tmp55_ = NULL;
						_data_->_tmp55_ = _data_->subpath;
						g_critical ("FOLKS_BACKEND_PATH component '%s' is not a regular " "file or directory; ignoring...", _data_->_tmp55_);
						g_assert_not_reached ();
					}
				}
				_g_object_unref0 (_data_->file);
			}
		}
	}
	folks_internal_profiling_point ("found modules in BackendStore");
	{
		_data_->_tmp56_ = NULL;
		_data_->_tmp56_ = _data_->modules;
		_data_->_tmp57_ = NULL;
		_data_->_tmp57_ = gee_abstract_map_get_values ((GeeMap*) _data_->_tmp56_);
		_data_->_tmp58_ = NULL;
		_data_->_tmp58_ = _data_->_tmp57_;
		_data_->_tmp59_ = NULL;
		_data_->_tmp59_ = _data_->_tmp58_;
		_data_->_tmp60_ = NULL;
		_data_->_tmp60_ = gee_iterable_iterator ((GeeIterable*) _data_->_tmp59_);
		_data_->_tmp61_ = NULL;
		_data_->_tmp61_ = _data_->_tmp60_;
		_g_object_unref0 (_data_->_tmp59_);
		_data_->_module_it = _data_->_tmp61_;
		while (TRUE) {
			_data_->_tmp62_ = NULL;
			_data_->_tmp62_ = _data_->_module_it;
			_data_->_tmp63_ = FALSE;
			_data_->_tmp63_ = gee_iterator_next (_data_->_tmp62_);
			if (!_data_->_tmp63_) {
				break;
			}
			_data_->_tmp64_ = NULL;
			_data_->_tmp64_ = _data_->_module_it;
			_data_->_tmp65_ = NULL;
			_data_->_tmp65_ = gee_iterator_get (_data_->_tmp64_);
			_data_->module = (GFile*) _data_->_tmp65_;
			_data_->_tmp66_ = NULL;
			_data_->_tmp66_ = _data_->module;
			_folks_backend_store_load_module_from_file (_data_->self, _data_->_tmp66_);
			_g_object_unref0 (_data_->module);
		}
		_g_object_unref0 (_data_->_module_it);
	}
	folks_internal_profiling_point ("loaded modules in BackendStore");
	_data_->_data1_->backends_remaining = 1;
	{
		_data_->_tmp67_ = NULL;
		_data_->_tmp67_ = _data_->self->priv->_backend_hash;
		_data_->_tmp68_ = NULL;
		_data_->_tmp68_ = gee_abstract_map_get_values ((GeeMap*) _data_->_tmp67_);
		_data_->_tmp69_ = NULL;
		_data_->_tmp69_ = _data_->_tmp68_;
		_data_->_tmp70_ = NULL;
		_data_->_tmp70_ = _data_->_tmp69_;
		_data_->_tmp71_ = NULL;
		_data_->_tmp71_ = gee_iterable_iterator ((GeeIterable*) _data_->_tmp70_);
		_data_->_tmp72_ = NULL;
		_data_->_tmp72_ = _data_->_tmp71_;
		_g_object_unref0 (_data_->_tmp70_);
		_data_->_backend_it = _data_->_tmp72_;
		while (TRUE) {
			_data_->_tmp73_ = NULL;
			_data_->_tmp73_ = _data_->_backend_it;
			_data_->_tmp74_ = FALSE;
			_data_->_tmp74_ = gee_iterator_next (_data_->_tmp73_);
			if (!_data_->_tmp74_) {
				break;
			}
			_data_->_tmp75_ = NULL;
			_data_->_tmp75_ = _data_->_backend_it;
			_data_->_tmp76_ = NULL;
			_data_->_tmp76_ = gee_iterator_get (_data_->_tmp75_);
			_data_->backend = (FolksBackend*) _data_->_tmp76_;
			_data_->_tmp77_ = 0;
			_data_->_tmp77_ = _data_->_data1_->backends_remaining;
			_data_->_data1_->backends_remaining = _data_->_tmp77_ + 1;
			_data_->_tmp78_ = NULL;
			_data_->_tmp78_ = _data_->backend;
			_folks_backend_store_backend_load_if_needed (_data_->self, _data_->_tmp78_, _____lambda66__gasync_ready_callback, block1_data_ref (_data_->_data1_));
			_g_object_unref0 (_data_->backend);
		}
		_g_object_unref0 (_data_->_backend_it);
	}
	_data_->_tmp79_ = 0;
	_data_->_tmp79_ = _data_->_data1_->backends_remaining;
	_data_->_data1_->backends_remaining = _data_->_tmp79_ - 1;
	_data_->_tmp80_ = 0;
	_data_->_tmp80_ = _data_->_data1_->backends_remaining;
	if (_data_->_tmp80_ > 0) {
		_data_->_state_ = 5;
		return FALSE;
		_state_5:
		;
	}
	folks_internal_profiling_end ("loading backends in BackendStore", NULL);
	_data_->path_split = (_vala_array_free (_data_->path_split, _data_->path_split_length1, (GDestroyNotify) g_free), NULL);
	_g_object_unref0 (_data_->modules);
	_g_free0 (_data_->path);
	_g_free0 (_data_->_path);
	block1_data_unref (_data_->_data1_);
	_data_->_data1_ = NULL;
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void _folks_backend_store_backend_load_if_needed_data_free (gpointer _data) {
	FolksBackendStoreBackendLoadIfNeededData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->backend);
	_g_object_unref0 (_data_->self);
	g_slice_free (FolksBackendStoreBackendLoadIfNeededData, _data_);
}


static void _folks_backend_store_backend_load_if_needed (FolksBackendStore* self, FolksBackend* backend, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	FolksBackendStoreBackendLoadIfNeededData* _data_;
	FolksBackendStore* _tmp0_ = NULL;
	FolksBackend* _tmp1_ = NULL;
	FolksBackend* _tmp2_ = NULL;
	_data_ = g_slice_new0 (FolksBackendStoreBackendLoadIfNeededData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, _folks_backend_store_backend_load_if_needed);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, _folks_backend_store_backend_load_if_needed_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = backend;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	_g_object_unref0 (_data_->backend);
	_data_->backend = _tmp2_;
	_folks_backend_store_backend_load_if_needed_co (_data_);
}


static void _folks_backend_store_backend_load_if_needed_finish (FolksBackendStore* self, GAsyncResult* _res_) {
	FolksBackendStoreBackendLoadIfNeededData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void _folks_backend_store_backend_load_if_needed_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	FolksBackendStoreBackendLoadIfNeededData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	_folks_backend_store_backend_load_if_needed_co (_data_);
}


static gboolean _folks_backend_store_backend_load_if_needed_co (FolksBackendStoreBackendLoadIfNeededData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = NULL;
	_data_->_tmp0_ = _data_->backend;
	_data_->_tmp1_ = NULL;
	_data_->_tmp1_ = folks_backend_get_name (_data_->_tmp0_);
	_data_->_tmp2_ = NULL;
	_data_->_tmp2_ = _data_->_tmp1_;
	_data_->_tmp3_ = FALSE;
	_data_->_tmp3_ = _folks_backend_store_backend_is_enabled (_data_->self, _data_->_tmp2_);
	if (_data_->_tmp3_) {
		_data_->_tmp4_ = NULL;
		_data_->_tmp4_ = _data_->self->priv->_prepared_backends;
		_data_->_tmp5_ = NULL;
		_data_->_tmp5_ = _data_->backend;
		_data_->_tmp6_ = NULL;
		_data_->_tmp6_ = folks_backend_get_name (_data_->_tmp5_);
		_data_->_tmp7_ = NULL;
		_data_->_tmp7_ = _data_->_tmp6_;
		_data_->_tmp8_ = FALSE;
		_data_->_tmp8_ = gee_abstract_map_has_key ((GeeAbstractMap*) _data_->_tmp4_, _data_->_tmp7_);
		if (!_data_->_tmp8_) {
			{
				_data_->_tmp9_ = NULL;
				_data_->_tmp9_ = _data_->backend;
				_data_->_state_ = 1;
				folks_backend_prepare (_data_->_tmp9_, _folks_backend_store_backend_load_if_needed_ready, _data_);
				return FALSE;
				_state_1:
				folks_backend_prepare_finish (_data_->_tmp9_, _data_->_res_, &_data_->_inner_error_);
				if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
					goto __catch0_g_error;
				}
				_data_->_tmp10_ = NULL;
				_data_->_tmp10_ = _data_->backend;
				_data_->_tmp11_ = NULL;
				_data_->_tmp11_ = folks_backend_get_name (_data_->_tmp10_);
				_data_->_tmp12_ = NULL;
				_data_->_tmp12_ = _data_->_tmp11_;
				g_debug ("backend-store.vala:415: New backend '%s' prepared", _data_->_tmp12_);
				_data_->_tmp13_ = NULL;
				_data_->_tmp13_ = _data_->self->priv->_prepared_backends;
				_data_->_tmp14_ = NULL;
				_data_->_tmp14_ = _data_->backend;
				_data_->_tmp15_ = NULL;
				_data_->_tmp15_ = folks_backend_get_name (_data_->_tmp14_);
				_data_->_tmp16_ = NULL;
				_data_->_tmp16_ = _data_->_tmp15_;
				_data_->_tmp17_ = NULL;
				_data_->_tmp17_ = _data_->backend;
				gee_abstract_map_set ((GeeAbstractMap*) _data_->_tmp13_, _data_->_tmp16_, _data_->_tmp17_);
				_data_->_tmp18_ = NULL;
				_data_->_tmp18_ = _data_->backend;
				g_signal_emit_by_name (_data_->self, "backend-available", _data_->_tmp18_);
			}
			goto __finally0;
			__catch0_g_error:
			{
				_data_->e = _data_->_inner_error_;
				_data_->_inner_error_ = NULL;
				_data_->_tmp19_ = NULL;
				_data_->_tmp19_ = _data_->e;
				if (g_error_matches (_data_->_tmp19_, G_DBUS_ERROR, G_DBUS_ERROR_SERVICE_UNKNOWN)) {
					_data_->_tmp20_ = NULL;
					_data_->_tmp20_ = _data_->backend;
					_data_->_tmp21_ = NULL;
					_data_->_tmp21_ = folks_backend_get_name (_data_->_tmp20_);
					_data_->_tmp22_ = NULL;
					_data_->_tmp22_ = _data_->_tmp21_;
					_data_->_tmp23_ = NULL;
					_data_->_tmp23_ = _data_->e;
					_data_->_tmp24_ = NULL;
					_data_->_tmp24_ = _data_->_tmp23_->message;
					g_debug ("backend-store.vala:427: Error preparing Backend '%s': %s", _data_->_tmp22_, _data_->_tmp24_);
				} else {
					_data_->_tmp25_ = NULL;
					_data_->_tmp25_ = _data_->backend;
					_data_->_tmp26_ = NULL;
					_data_->_tmp26_ = folks_backend_get_name (_data_->_tmp25_);
					_data_->_tmp27_ = NULL;
					_data_->_tmp27_ = _data_->_tmp26_;
					_data_->_tmp28_ = NULL;
					_data_->_tmp28_ = _data_->e;
					_data_->_tmp29_ = NULL;
					_data_->_tmp29_ = _data_->_tmp28_->message;
					g_warning ("backend-store.vala:432: Error preparing Backend '%s': %s", _data_->_tmp27_, _data_->_tmp29_);
				}
				_g_error_free0 (_data_->e);
			}
			__finally0:
			if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
				g_clear_error (&_data_->_inner_error_);
				return FALSE;
			}
		}
	}
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void _folks_backend_store_backend_unload_if_needed_data_free (gpointer _data) {
	FolksBackendStoreBackendUnloadIfNeededData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->backend);
	_g_object_unref0 (_data_->self);
	g_slice_free (FolksBackendStoreBackendUnloadIfNeededData, _data_);
}


static void _folks_backend_store_backend_unload_if_needed (FolksBackendStore* self, FolksBackend* backend, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	FolksBackendStoreBackendUnloadIfNeededData* _data_;
	FolksBackendStore* _tmp0_ = NULL;
	FolksBackend* _tmp1_ = NULL;
	FolksBackend* _tmp2_ = NULL;
	_data_ = g_slice_new0 (FolksBackendStoreBackendUnloadIfNeededData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, _folks_backend_store_backend_unload_if_needed);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, _folks_backend_store_backend_unload_if_needed_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = backend;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	_g_object_unref0 (_data_->backend);
	_data_->backend = _tmp2_;
	_folks_backend_store_backend_unload_if_needed_co (_data_);
}


static gboolean _folks_backend_store_backend_unload_if_needed_finish (FolksBackendStore* self, GAsyncResult* _res_) {
	gboolean result;
	FolksBackendStoreBackendUnloadIfNeededData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
	result = _data_->result;
	return result;
}


static void _folks_backend_store_backend_unload_if_needed_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	FolksBackendStoreBackendUnloadIfNeededData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	_folks_backend_store_backend_unload_if_needed_co (_data_);
}


static gboolean _folks_backend_store_backend_unload_if_needed_co (FolksBackendStoreBackendUnloadIfNeededData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->unloaded = FALSE;
	_data_->_tmp0_ = NULL;
	_data_->_tmp0_ = _data_->backend;
	_data_->_tmp1_ = NULL;
	_data_->_tmp1_ = folks_backend_get_name (_data_->_tmp0_);
	_data_->_tmp2_ = NULL;
	_data_->_tmp2_ = _data_->_tmp1_;
	_data_->_tmp3_ = FALSE;
	_data_->_tmp3_ = _folks_backend_store_backend_is_enabled (_data_->self, _data_->_tmp2_);
	if (!_data_->_tmp3_) {
		_data_->_tmp4_ = NULL;
		_data_->_tmp4_ = _data_->self->priv->_backend_hash;
		_data_->_tmp5_ = NULL;
		_data_->_tmp5_ = _data_->backend;
		_data_->_tmp6_ = NULL;
		_data_->_tmp6_ = folks_backend_get_name (_data_->_tmp5_);
		_data_->_tmp7_ = NULL;
		_data_->_tmp7_ = _data_->_tmp6_;
		_data_->_tmp8_ = NULL;
		_data_->_tmp8_ = gee_abstract_map_get ((GeeAbstractMap*) _data_->_tmp4_, _data_->_tmp7_);
		_data_->backend_existing = (FolksBackend*) _data_->_tmp8_;
		_data_->_tmp9_ = NULL;
		_data_->_tmp9_ = _data_->backend_existing;
		if (_data_->_tmp9_ != NULL) {
			{
				_data_->_tmp10_ = NULL;
				_data_->_tmp10_ = _data_->backend_existing;
				_data_->_state_ = 1;
				folks_backend_unprepare (G_TYPE_CHECK_INSTANCE_CAST (_data_->_tmp10_, FOLKS_TYPE_BACKEND, FolksBackend), _folks_backend_store_backend_unload_if_needed_ready, _data_);
				return FALSE;
				_state_1:
				folks_backend_unprepare_finish (G_TYPE_CHECK_INSTANCE_CAST (_data_->_tmp10_, FOLKS_TYPE_BACKEND, FolksBackend), _data_->_res_, &_data_->_inner_error_);
				if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
					goto __catch1_g_error;
				}
			}
			goto __finally1;
			__catch1_g_error:
			{
				_data_->e = _data_->_inner_error_;
				_data_->_inner_error_ = NULL;
				_data_->_tmp11_ = NULL;
				_data_->_tmp11_ = _data_->backend;
				_data_->_tmp12_ = NULL;
				_data_->_tmp12_ = folks_backend_get_name (_data_->_tmp11_);
				_data_->_tmp13_ = NULL;
				_data_->_tmp13_ = _data_->_tmp12_;
				_data_->_tmp14_ = NULL;
				_data_->_tmp14_ = _data_->e;
				_data_->_tmp15_ = NULL;
				_data_->_tmp15_ = _data_->_tmp14_->message;
				g_warning ("backend-store.vala:457: Error unpreparing Backend '%s': %s", _data_->_tmp13_, _data_->_tmp15_);
				_g_error_free0 (_data_->e);
			}
			__finally1:
			if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
				_g_object_unref0 (_data_->backend_existing);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
				g_clear_error (&_data_->_inner_error_);
				return FALSE;
			}
			_data_->_tmp16_ = NULL;
			_data_->_tmp16_ = _data_->self->priv->_prepared_backends;
			_data_->_tmp17_ = NULL;
			_data_->_tmp17_ = _data_->backend_existing;
			_data_->_tmp18_ = NULL;
			_data_->_tmp18_ = folks_backend_get_name (G_TYPE_CHECK_INSTANCE_CAST (_data_->_tmp17_, FOLKS_TYPE_BACKEND, FolksBackend));
			_data_->_tmp19_ = NULL;
			_data_->_tmp19_ = _data_->_tmp18_;
			gee_abstract_map_unset ((GeeAbstractMap*) _data_->_tmp16_, _data_->_tmp19_, NULL);
			_data_->unloaded = TRUE;
		}
		_g_object_unref0 (_data_->backend_existing);
	}
	_data_->result = _data_->unloaded;
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


/**
   * Add a new {@link Backend} to the BackendStore.
   *
   * @param backend the {@link Backend} to add
   */
void folks_backend_store_add_backend (FolksBackendStore* self, FolksBackend* backend) {
	FolksBackend* backend_existing = NULL;
	GeeHashMap* _tmp0_ = NULL;
	FolksBackend* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gpointer _tmp4_ = NULL;
	gboolean _tmp5_ = FALSE;
	FolksBackend* _tmp6_ = NULL;
	FolksDebug* _tmp14_ = NULL;
	FolksBackend* _tmp15_ = NULL;
	const gchar* _tmp16_ = NULL;
	const gchar* _tmp17_ = NULL;
	GeeHashMap* _tmp18_ = NULL;
	FolksBackend* _tmp19_ = NULL;
	const gchar* _tmp20_ = NULL;
	const gchar* _tmp21_ = NULL;
	FolksBackend* _tmp22_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (backend != NULL);
	_tmp0_ = self->priv->_backend_hash;
	_tmp1_ = backend;
	_tmp2_ = folks_backend_get_name (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp0_, _tmp3_);
	backend_existing = (FolksBackend*) _tmp4_;
	_tmp6_ = backend_existing;
	if (_tmp6_ != NULL) {
		FolksBackend* _tmp7_ = NULL;
		FolksBackend* _tmp8_ = NULL;
		_tmp7_ = backend_existing;
		_tmp8_ = backend;
		_tmp5_ = _tmp7_ != _tmp8_;
	} else {
		_tmp5_ = FALSE;
	}
	if (_tmp5_) {
		FolksBackend* _tmp9_ = NULL;
		GeeHashMap* _tmp10_ = NULL;
		FolksBackend* _tmp11_ = NULL;
		const gchar* _tmp12_ = NULL;
		const gchar* _tmp13_ = NULL;
		_tmp9_ = backend_existing;
		folks_backend_unprepare (G_TYPE_CHECK_INSTANCE_CAST (_tmp9_, FOLKS_TYPE_BACKEND, FolksBackend), NULL, NULL);
		_tmp10_ = self->priv->_prepared_backends;
		_tmp11_ = backend_existing;
		_tmp12_ = folks_backend_get_name (G_TYPE_CHECK_INSTANCE_CAST (_tmp11_, FOLKS_TYPE_BACKEND, FolksBackend));
		_tmp13_ = _tmp12_;
		gee_abstract_map_unset ((GeeAbstractMap*) _tmp10_, _tmp13_, NULL);
	}
	_tmp14_ = self->priv->_debug;
	_tmp15_ = backend;
	_tmp16_ = folks_backend_get_name (_tmp15_);
	_tmp17_ = _tmp16_;
	_folks_debug_register_domain (_tmp14_, _tmp17_);
	_tmp18_ = self->priv->_backend_hash;
	_tmp19_ = backend;
	_tmp20_ = folks_backend_get_name (_tmp19_);
	_tmp21_ = _tmp20_;
	_tmp22_ = backend;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp18_, _tmp21_, _tmp22_);
	_g_object_unref0 (backend_existing);
}


static gboolean _folks_backend_store_backend_is_enabled (FolksBackendStore* self, const gchar* name) {
	gboolean result = FALSE;
	gboolean all_others_enabled = FALSE;
	gboolean _tmp0_ = FALSE;
	FolksSmallSet* _tmp1_ = NULL;
	gboolean _tmp5_ = FALSE;
	FolksSmallSet* _tmp6_ = NULL;
	gboolean enabled = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (name != NULL, FALSE);
	all_others_enabled = TRUE;
	_tmp1_ = self->priv->_backends_allowed;
	if (_tmp1_ != NULL) {
		FolksSmallSet* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		gboolean _tmp4_ = FALSE;
		_tmp2_ = self->priv->_backends_allowed;
		_tmp3_ = name;
		_tmp4_ = gee_abstract_collection_contains ((GeeAbstractCollection*) G_TYPE_CHECK_INSTANCE_CAST (_tmp2_, FOLKS_TYPE_SMALL_SET, FolksSmallSet), _tmp3_);
		_tmp0_ = !_tmp4_;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		result = FALSE;
		return result;
	}
	_tmp6_ = self->priv->_backends_disabled;
	if (_tmp6_ != NULL) {
		FolksSmallSet* _tmp7_ = NULL;
		const gchar* _tmp8_ = NULL;
		gboolean _tmp9_ = FALSE;
		_tmp7_ = self->priv->_backends_disabled;
		_tmp8_ = name;
		_tmp9_ = gee_abstract_collection_contains ((GeeAbstractCollection*) G_TYPE_CHECK_INSTANCE_CAST (_tmp7_, FOLKS_TYPE_SMALL_SET, FolksSmallSet), _tmp8_);
		_tmp5_ = _tmp9_;
	} else {
		_tmp5_ = FALSE;
	}
	if (_tmp5_) {
		result = FALSE;
		return result;
	}
	{
		gboolean _tmp10_ = FALSE;
		GKeyFile* _tmp11_ = NULL;
		const gchar* _tmp12_ = NULL;
		gboolean _tmp13_ = FALSE;
		_tmp11_ = self->priv->_backends_key_file;
		_tmp12_ = folks_backend_store_KEY_FILE_GROUP_ALL_OTHERS;
		_tmp13_ = g_key_file_get_boolean (_tmp11_, _tmp12_, "enabled", &_inner_error_);
		_tmp10_ = _tmp13_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch2_g_key_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
		all_others_enabled = _tmp10_;
	}
	goto __finally2;
	__catch2_g_key_file_error:
	{
		GError* e = NULL;
		gboolean _tmp14_ = FALSE;
		GError* _tmp15_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp15_ = e;
		if (!g_error_matches (_tmp15_, G_KEY_FILE_ERROR, G_KEY_FILE_ERROR_GROUP_NOT_FOUND)) {
			GError* _tmp16_ = NULL;
			_tmp16_ = e;
			_tmp14_ = !g_error_matches (_tmp16_, G_KEY_FILE_ERROR, G_KEY_FILE_ERROR_KEY_NOT_FOUND);
		} else {
			_tmp14_ = FALSE;
		}
		if (_tmp14_) {
			const gchar* _tmp17_ = NULL;
			gboolean _tmp18_ = FALSE;
			_tmp18_ = all_others_enabled;
			if (_tmp18_) {
				_tmp17_ = "enabled";
			} else {
				_tmp17_ = "disabled";
			}
			g_warning ("Couldn't determine whether to enable or disable " "backends not listed in backend key file. Defaulting to %s.", _tmp17_);
		} else {
			const gchar* _tmp19_ = NULL;
			gboolean _tmp20_ = FALSE;
			_tmp20_ = all_others_enabled;
			if (_tmp20_) {
				_tmp19_ = "Enabling";
			} else {
				_tmp19_ = "Disabling";
			}
			g_debug ("No catch-all entry in the backend key file. %s " "unlisted backends.", _tmp19_);
		}
		_g_error_free0 (e);
	}
	__finally2:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	enabled = TRUE;
	{
		gboolean _tmp21_ = FALSE;
		GKeyFile* _tmp22_ = NULL;
		const gchar* _tmp23_ = NULL;
		gboolean _tmp24_ = FALSE;
		_tmp22_ = self->priv->_backends_key_file;
		_tmp23_ = name;
		_tmp24_ = g_key_file_get_boolean (_tmp22_, _tmp23_, "enabled", &_inner_error_);
		_tmp21_ = _tmp24_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch3_g_key_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
		enabled = _tmp21_;
	}
	goto __finally3;
	__catch3_g_key_file_error:
	{
		GError* e = NULL;
		gboolean _tmp25_ = FALSE;
		GError* _tmp26_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp26_ = e;
		if (g_error_matches (_tmp26_, G_KEY_FILE_ERROR, G_KEY_FILE_ERROR_GROUP_NOT_FOUND)) {
			_tmp25_ = TRUE;
		} else {
			GError* _tmp27_ = NULL;
			_tmp27_ = e;
			_tmp25_ = g_error_matches (_tmp27_, G_KEY_FILE_ERROR, G_KEY_FILE_ERROR_KEY_NOT_FOUND);
		}
		if (_tmp25_) {
			const gchar* _tmp28_ = NULL;
			gboolean _tmp29_ = FALSE;
			const gchar* _tmp30_ = NULL;
			const gchar* _tmp31_ = NULL;
			gboolean _tmp32_ = FALSE;
			_tmp29_ = all_others_enabled;
			if (_tmp29_) {
				_tmp28_ = "Enabling";
			} else {
				_tmp28_ = "Disabling";
			}
			_tmp30_ = name;
			_tmp31_ = folks_backend_store_KEY_FILE_GROUP_ALL_OTHERS;
			g_debug ("Found no entry for backend '%s'.enabled in backend " "keyfile. %s according to '%s' setting.", _tmp30_, _tmp28_, _tmp31_);
			_tmp32_ = all_others_enabled;
			enabled = _tmp32_;
		} else {
			gboolean _tmp33_ = FALSE;
			GError* _tmp34_ = NULL;
			_tmp34_ = e;
			if (!g_error_matches (_tmp34_, G_KEY_FILE_ERROR, G_KEY_FILE_ERROR_GROUP_NOT_FOUND)) {
				GError* _tmp35_ = NULL;
				_tmp35_ = e;
				_tmp33_ = !g_error_matches (_tmp35_, G_KEY_FILE_ERROR, G_KEY_FILE_ERROR_KEY_NOT_FOUND);
			} else {
				_tmp33_ = FALSE;
			}
			if (_tmp33_) {
				const gchar* _tmp36_ = NULL;
				GError* _tmp37_ = NULL;
				const gchar* _tmp38_ = NULL;
				_tmp36_ = name;
				_tmp37_ = e;
				_tmp38_ = _tmp37_->message;
				g_warning ("Couldn't check enabled state of backend '%s': %s\n" "Disabling backend.", _tmp36_, _tmp38_);
				enabled = FALSE;
			}
		}
		_g_error_free0 (e);
	}
	__finally3:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	result = enabled;
	return result;
}


/**
   * Get a backend from the store by name. If a backend is returned, its
   * reference count is increased.
   *
   * @param name the backend name to retrieve
   * @return the backend, or ``null`` if none could be found
   *
   * @since 0.3.5
   */
FolksBackend* folks_backend_store_dup_backend_by_name (FolksBackendStore* self, const gchar* name) {
	FolksBackend* result = NULL;
	GeeHashMap* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gpointer _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (name != NULL, NULL);
	_tmp0_ = self->priv->_backend_hash;
	_tmp1_ = name;
	_tmp2_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp0_, _tmp1_);
	result = (FolksBackend*) _tmp2_;
	return result;
}


/**
   * List the currently loaded backends.
   *
   * @return a list of the backends currently in the BackendStore
   */
GeeCollection* folks_backend_store_list_backends (FolksBackendStore* self) {
	GeeCollection* result = NULL;
	GeeHashMap* _tmp0_ = NULL;
	GeeCollection* _tmp1_ = NULL;
	GeeCollection* _tmp2_ = NULL;
	GeeCollection* _tmp3_ = NULL;
	GeeCollection* _tmp4_ = NULL;
	GeeCollection* _tmp5_ = NULL;
	GeeCollection* _tmp6_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_backend_hash;
	_tmp1_ = gee_abstract_map_get_values ((GeeMap*) _tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = _tmp2_;
	_tmp4_ = gee_collection_get_read_only_view (_tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = _tmp5_;
	_g_object_unref0 (_tmp3_);
	result = _tmp6_;
	return result;
}


static void folks_backend_store_enable_backend_data_free (gpointer _data) {
	FolksBackendStoreEnableBackendData* _data_;
	_data_ = _data;
	_g_free0 (_data_->name);
	_g_object_unref0 (_data_->self);
	g_slice_free (FolksBackendStoreEnableBackendData, _data_);
}


void folks_backend_store_enable_backend (FolksBackendStore* self, const gchar* name, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	FolksBackendStoreEnableBackendData* _data_;
	FolksBackendStore* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	_data_ = g_slice_new0 (FolksBackendStoreEnableBackendData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, folks_backend_store_enable_backend);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, folks_backend_store_enable_backend_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = name;
	_tmp2_ = g_strdup (_tmp1_);
	_g_free0 (_data_->name);
	_data_->name = _tmp2_;
	folks_backend_store_enable_backend_co (_data_);
}


void folks_backend_store_enable_backend_finish (FolksBackendStore* self, GAsyncResult* _res_) {
	FolksBackendStoreEnableBackendData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


/**
   * Enable a backend.
   *
   * Mark a backend as enabled, such that the BackendStore will always attempt
   * to load it when {@link BackendStore.load_backends} is called. This will
   * not load the backend if it's not currently loaded.
   *
   * This method is safe to call multiple times concurrently (e.g. an
   * asynchronous call may begin after a previous asynchronous call for the same
   * backend name has begun and before it has finished).
   *
   * If the backend is disallowed by the FOLKS_BACKENDS_ALLOWED
   * and/or FOLKS_BACKENDS_DISABLED environment variables, this method
   * will store the fact that it should be enabled in future, but will
   * not enable it during this application run.
   *
   * @param name the name of the backend to enable
   * @since 0.3.2
   */
static void folks_backend_store_enable_backend_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	FolksBackendStoreEnableBackendData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	folks_backend_store_enable_backend_co (_data_);
}


static gboolean folks_backend_store_enable_backend_co (FolksBackendStoreEnableBackendData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = NULL;
	_data_->_tmp0_ = _data_->self->priv->_backends_key_file;
	_data_->_tmp1_ = NULL;
	_data_->_tmp1_ = _data_->name;
	g_key_file_set_boolean (_data_->_tmp0_, _data_->_tmp1_, "enabled", TRUE);
	_data_->_state_ = 1;
	_folks_backend_store_save_key_file (_data_->self, folks_backend_store_enable_backend_ready, _data_);
	return FALSE;
	_state_1:
	_folks_backend_store_save_key_file_finish (_data_->self, _data_->_res_);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void folks_backend_store_disable_backend_data_free (gpointer _data) {
	FolksBackendStoreDisableBackendData* _data_;
	_data_ = _data;
	_g_free0 (_data_->name);
	_g_object_unref0 (_data_->self);
	g_slice_free (FolksBackendStoreDisableBackendData, _data_);
}


void folks_backend_store_disable_backend (FolksBackendStore* self, const gchar* name, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	FolksBackendStoreDisableBackendData* _data_;
	FolksBackendStore* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	_data_ = g_slice_new0 (FolksBackendStoreDisableBackendData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, folks_backend_store_disable_backend);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, folks_backend_store_disable_backend_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = name;
	_tmp2_ = g_strdup (_tmp1_);
	_g_free0 (_data_->name);
	_data_->name = _tmp2_;
	folks_backend_store_disable_backend_co (_data_);
}


void folks_backend_store_disable_backend_finish (FolksBackendStore* self, GAsyncResult* _res_) {
	FolksBackendStoreDisableBackendData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


/**
   * Disable a backend.
   *
   * Mark a backend as disabled, such that it won't be loaded even when the
   * client application is restarted. This will not remove the backend if it's
   * already loaded.
   *
   * This method is safe to call multiple times concurrently (e.g. an
   * asynchronous call may begin after a previous asynchronous call for the same
   * backend name has begun and before it has finished).
   *
   * @param name the name of the backend to disable
   * @since 0.3.2
   */
static void folks_backend_store_disable_backend_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	FolksBackendStoreDisableBackendData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	folks_backend_store_disable_backend_co (_data_);
}


static gboolean folks_backend_store_disable_backend_co (FolksBackendStoreDisableBackendData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = NULL;
	_data_->_tmp0_ = _data_->self->priv->_backends_key_file;
	_data_->_tmp1_ = NULL;
	_data_->_tmp1_ = _data_->name;
	g_key_file_set_boolean (_data_->_tmp0_, _data_->_tmp1_, "enabled", FALSE);
	_data_->_state_ = 1;
	_folks_backend_store_save_key_file (_data_->self, folks_backend_store_disable_backend_ready, _data_);
	return FALSE;
	_state_1:
	_folks_backend_store_save_key_file_finish (_data_->self, _data_->_res_);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void _folks_backend_store_get_modules_from_dir_data_free (gpointer _data) {
	FolksBackendStoreGetModulesFromDirData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->dir);
	_g_object_unref0 (_data_->result);
	_g_object_unref0 (_data_->self);
	g_slice_free (FolksBackendStoreGetModulesFromDirData, _data_);
}


static void _folks_backend_store_get_modules_from_dir (FolksBackendStore* self, GFile* dir, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	FolksBackendStoreGetModulesFromDirData* _data_;
	FolksBackendStore* _tmp0_ = NULL;
	GFile* _tmp1_ = NULL;
	GFile* _tmp2_ = NULL;
	_data_ = g_slice_new0 (FolksBackendStoreGetModulesFromDirData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, _folks_backend_store_get_modules_from_dir);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, _folks_backend_store_get_modules_from_dir_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = dir;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	_g_object_unref0 (_data_->dir);
	_data_->dir = _tmp2_;
	_folks_backend_store_get_modules_from_dir_co (_data_);
}


static GeeHashMap* _folks_backend_store_get_modules_from_dir_finish (FolksBackendStore* self, GAsyncResult* _res_) {
	GeeHashMap* result;
	FolksBackendStoreGetModulesFromDirData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
	result = _data_->result;
	_data_->result = NULL;
	return result;
}


static void _folks_backend_store_get_modules_from_dir_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	FolksBackendStoreGetModulesFromDirData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	_folks_backend_store_get_modules_from_dir_co (_data_);
}


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void _g_list_free__g_object_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_object_unref0_, NULL);
	g_list_free (self);
}


static gboolean _folks_backend_store_get_modules_from_dir_co (FolksBackendStoreGetModulesFromDirData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		case 3:
		goto _state_3;
		case 4:
		goto _state_4;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = NULL;
	_data_->_tmp0_ = _data_->dir;
	_data_->_tmp1_ = NULL;
	_data_->_tmp1_ = g_file_get_path (_data_->_tmp0_);
	_data_->_tmp2_ = NULL;
	_data_->_tmp2_ = _data_->_tmp1_;
	g_debug ("backend-store.vala:629: Searching for modules in folder '%s' ..", _data_->_tmp2_);
	_g_free0 (_data_->_tmp2_);
	_data_->_tmp3_ = NULL;
	_data_->_tmp3_ = g_strdup (G_FILE_ATTRIBUTE_STANDARD_NAME "," G_FILE_ATTRIBUTE_STANDARD_TYPE "," G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK "," G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET "," G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE);
	_data_->attributes = _data_->_tmp3_;
	{
		_data_->_tmp4_ = NULL;
		_data_->_tmp4_ = _data_->dir;
		_data_->_tmp5_ = NULL;
		_data_->_tmp5_ = _data_->attributes;
		_data_->_state_ = 1;
		g_file_enumerate_children_async (_data_->_tmp4_, _data_->_tmp5_, G_FILE_QUERY_INFO_NONE, G_PRIORITY_DEFAULT, NULL, _folks_backend_store_get_modules_from_dir_ready, _data_);
		return FALSE;
		_state_1:
		_data_->_tmp6_ = NULL;
		_data_->_tmp6_ = g_file_enumerate_children_finish (_data_->_tmp4_, _data_->_res_, &_data_->_inner_error_);
		_data_->enumerator = _data_->_tmp6_;
		if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
			goto __catch4_g_error;
		}
		_data_->_tmp8_ = NULL;
		_data_->_tmp8_ = _data_->enumerator;
		_data_->_state_ = 2;
		g_file_enumerator_next_files_async (_data_->_tmp8_, G_MAXINT, G_PRIORITY_DEFAULT, NULL, _folks_backend_store_get_modules_from_dir_ready, _data_);
		return FALSE;
		_state_2:
		_data_->_tmp9_ = NULL;
		_data_->_tmp9_ = g_file_enumerator_next_files_finish (_data_->_tmp8_, _data_->_res_, &_data_->_inner_error_);
		_data_->_tmp7_ = _data_->_tmp9_;
		if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
			_g_object_unref0 (_data_->enumerator);
			goto __catch4_g_error;
		}
		_data_->_tmp10_ = NULL;
		_data_->_tmp10_ = _data_->_tmp7_;
		_data_->_tmp7_ = NULL;
		__g_list_free__g_object_unref0_0 (_data_->infos);
		_data_->infos = _data_->_tmp10_;
		__g_list_free__g_object_unref0_0 (_data_->_tmp7_);
		_g_object_unref0 (_data_->enumerator);
	}
	goto __finally4;
	__catch4_g_error:
	{
		_data_->_error_ = _data_->_inner_error_;
		_data_->_inner_error_ = NULL;
		_data_->_tmp11_ = NULL;
		_data_->_tmp11_ = _ ("Error listing contents of folder '%s': %s");
		_data_->_tmp12_ = NULL;
		_data_->_tmp12_ = _data_->dir;
		_data_->_tmp13_ = NULL;
		_data_->_tmp13_ = g_file_get_path (_data_->_tmp12_);
		_data_->_tmp14_ = NULL;
		_data_->_tmp14_ = _data_->_tmp13_;
		_data_->_tmp15_ = NULL;
		_data_->_tmp15_ = _data_->_error_;
		_data_->_tmp16_ = NULL;
		_data_->_tmp16_ = _data_->_tmp15_->message;
		g_critical (_data_->_tmp11_, _data_->_tmp14_, _data_->_tmp16_);
		_g_free0 (_data_->_tmp14_);
		_data_->result = NULL;
		_g_error_free0 (_data_->_error_);
		__g_list_free__g_object_unref0_0 (_data_->infos);
		_g_free0 (_data_->attributes);
		if (_data_->_state_ == 0) {
			g_simple_async_result_complete_in_idle (_data_->_async_result);
		} else {
			g_simple_async_result_complete (_data_->_async_result);
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	__finally4:
	if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
		__g_list_free__g_object_unref0_0 (_data_->infos);
		_g_free0 (_data_->attributes);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
		g_clear_error (&_data_->_inner_error_);
		return FALSE;
	}
	_data_->_tmp17_ = NULL;
	_data_->_tmp17_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_FILE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	_data_->modules_final = _data_->_tmp17_;
	_data_->_tmp18_ = NULL;
	_data_->_tmp18_ = g_getenv ("FOLKS_BACKEND_PATH");
	_data_->_tmp19_ = NULL;
	_data_->_tmp19_ = g_strdup (_data_->_tmp18_);
	_data_->_path = _data_->_tmp19_;
	_data_->_tmp20_ = NULL;
	_data_->_tmp20_ = _data_->infos;
	{
		_data_->info_collection = _data_->_tmp20_;
		for (_data_->info_it = _data_->info_collection; _data_->info_it != NULL; _data_->info_it = _data_->info_it->next) {
			_data_->_tmp21_ = NULL;
			_data_->_tmp21_ = _g_object_ref0 ((GFileInfo*) _data_->info_it->data);
			_data_->info = _data_->_tmp21_;
			{
				_data_->_tmp22_ = NULL;
				_data_->_tmp22_ = _data_->dir;
				_data_->_tmp23_ = NULL;
				_data_->_tmp23_ = _data_->info;
				_data_->_tmp24_ = NULL;
				_data_->_tmp24_ = g_file_info_get_name (_data_->_tmp23_);
				_data_->_tmp25_ = NULL;
				_data_->_tmp25_ = g_file_get_child (_data_->_tmp22_, _data_->_tmp24_);
				_data_->file = _data_->_tmp25_;
				_data_->_tmp26_ = NULL;
				_data_->_tmp26_ = _data_->info;
				_data_->_tmp27_ = FALSE;
				_data_->_tmp27_ = g_file_info_get_is_symlink (_data_->_tmp26_);
				if (_data_->_tmp27_) {
					_data_->_tmp28_ = NULL;
					_data_->_tmp28_ = _data_->file;
					_data_->_tmp29_ = NULL;
					_data_->_tmp29_ = g_file_get_path (_data_->_tmp28_);
					_data_->_tmp30_ = NULL;
					_data_->_tmp30_ = _data_->_tmp29_;
					_data_->_tmp31_ = NULL;
					_data_->_tmp31_ = _data_->info;
					_data_->_tmp32_ = NULL;
					_data_->_tmp32_ = g_file_info_get_symlink_target (_data_->_tmp31_);
					g_debug ("backend-store.vala:677: Handling symlink %s to %s.", _data_->_tmp30_, _data_->_tmp32_);
					_g_free0 (_data_->_tmp30_);
					_data_->_tmp33_ = NULL;
					_data_->_tmp33_ = _data_->file;
					_data_->_tmp34_ = NULL;
					_data_->_tmp34_ = _g_object_ref0 (_data_->_tmp33_);
					_data_->old_file = _data_->_tmp34_;
					_data_->_tmp35_ = NULL;
					_data_->_tmp35_ = _data_->dir;
					_data_->_tmp36_ = NULL;
					_data_->_tmp36_ = _data_->info;
					_data_->_tmp37_ = NULL;
					_data_->_tmp37_ = g_file_info_get_symlink_target (_data_->_tmp36_);
					_data_->_tmp38_ = NULL;
					_data_->_tmp38_ = g_file_resolve_relative_path (_data_->_tmp35_, _data_->_tmp37_);
					_g_object_unref0 (_data_->file);
					_data_->file = _data_->_tmp38_;
					{
						_data_->_tmp40_ = NULL;
						_data_->_tmp40_ = _data_->file;
						_data_->_tmp41_ = NULL;
						_data_->_tmp41_ = _data_->attributes;
						_data_->_state_ = 3;
						g_file_query_info_async (_data_->_tmp40_, _data_->_tmp41_, G_FILE_QUERY_INFO_NONE, G_PRIORITY_DEFAULT, NULL, _folks_backend_store_get_modules_from_dir_ready, _data_);
						return FALSE;
						_state_3:
						_data_->_tmp42_ = NULL;
						_data_->_tmp42_ = g_file_query_info_finish (_data_->_tmp40_, _data_->_res_, &_data_->_inner_error_);
						_data_->_tmp39_ = _data_->_tmp42_;
						if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
							goto __catch5_g_error;
						}
						_data_->_tmp43_ = NULL;
						_data_->_tmp43_ = _data_->_tmp39_;
						_data_->_tmp39_ = NULL;
						_g_object_unref0 (_data_->info);
						_data_->info = _data_->_tmp43_;
						_g_object_unref0 (_data_->_tmp39_);
					}
					goto __finally5;
					__catch5_g_error:
					{
						_data_->_vala1__error_ = _data_->_inner_error_;
						_data_->_inner_error_ = NULL;
						_data_->_tmp44_ = NULL;
						_data_->_tmp44_ = _ ("Error querying info for target %s of symlink %s: %s");
						_data_->_tmp45_ = NULL;
						_data_->_tmp45_ = _data_->file;
						_data_->_tmp46_ = NULL;
						_data_->_tmp46_ = g_file_get_path (_data_->_tmp45_);
						_data_->_tmp47_ = NULL;
						_data_->_tmp47_ = _data_->_tmp46_;
						_data_->_tmp48_ = NULL;
						_data_->_tmp48_ = _data_->old_file;
						_data_->_tmp49_ = NULL;
						_data_->_tmp49_ = g_file_get_path (_data_->_tmp48_);
						_data_->_tmp50_ = NULL;
						_data_->_tmp50_ = _data_->_tmp49_;
						_data_->_tmp51_ = NULL;
						_data_->_tmp51_ = _data_->_vala1__error_;
						_data_->_tmp52_ = NULL;
						_data_->_tmp52_ = _data_->_tmp51_->message;
						g_warning (_data_->_tmp44_, _data_->_tmp47_, _data_->_tmp50_, _data_->_tmp52_);
						_g_free0 (_data_->_tmp50_);
						_g_free0 (_data_->_tmp47_);
						_g_error_free0 (_data_->_vala1__error_);
						_g_object_unref0 (_data_->old_file);
						_g_object_unref0 (_data_->file);
						_g_object_unref0 (_data_->info);
						continue;
					}
					__finally5:
					if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
						_g_object_unref0 (_data_->old_file);
						_g_object_unref0 (_data_->file);
						_g_object_unref0 (_data_->info);
						_g_free0 (_data_->_path);
						_g_object_unref0 (_data_->modules_final);
						__g_list_free__g_object_unref0_0 (_data_->infos);
						_g_free0 (_data_->attributes);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
						g_clear_error (&_data_->_inner_error_);
						return FALSE;
					}
					_g_object_unref0 (_data_->old_file);
				}
				_data_->_tmp53_ = NULL;
				_data_->_tmp53_ = _data_->info;
				_data_->_tmp54_ = 0;
				_data_->_tmp54_ = g_file_info_get_file_type (_data_->_tmp53_);
				_data_->file_type = _data_->_tmp54_;
				_data_->_tmp55_ = NULL;
				_data_->_tmp55_ = _data_->info;
				_data_->_tmp56_ = NULL;
				_data_->_tmp56_ = g_file_info_get_content_type (_data_->_tmp55_);
				_data_->content_type = _data_->_tmp56_;
				_data_->_tmp57_ = NULL;
				_data_->_tmp57_ = _data_->content_type;
				_data_->_tmp58_ = NULL;
				_data_->_tmp58_ = g_content_type_get_mime_type (_data_->_tmp57_);
				_data_->mime = _data_->_tmp58_;
				_data_->_tmp59_ = 0;
				_data_->_tmp59_ = _data_->file_type;
				if (_data_->_tmp59_ == G_FILE_TYPE_DIRECTORY) {
					_data_->_tmp60_ = NULL;
					_data_->_tmp60_ = _data_->file;
					_data_->_state_ = 4;
					_folks_backend_store_get_modules_from_dir (_data_->self, _data_->_tmp60_, _folks_backend_store_get_modules_from_dir_ready, _data_);
					return FALSE;
					_state_4:
					_data_->_tmp61_ = NULL;
					_data_->_tmp61_ = _folks_backend_store_get_modules_from_dir_finish (_data_->self, _data_->_res_);
					_data_->modules = _data_->_tmp61_;
					_data_->_tmp62_ = NULL;
					_data_->_tmp62_ = _data_->modules;
					if (_data_->_tmp62_ != NULL) {
						{
							_data_->_tmp63_ = NULL;
							_data_->_tmp63_ = _data_->modules;
							_data_->_tmp64_ = NULL;
							_data_->_tmp64_ = gee_abstract_map_get_entries ((GeeMap*) G_TYPE_CHECK_INSTANCE_CAST (_data_->_tmp63_, GEE_TYPE_HASH_MAP, GeeHashMap));
							_data_->_tmp65_ = NULL;
							_data_->_tmp65_ = _data_->_tmp64_;
							_data_->_tmp66_ = NULL;
							_data_->_tmp66_ = _data_->_tmp65_;
							_data_->_tmp67_ = NULL;
							_data_->_tmp67_ = gee_iterable_iterator ((GeeIterable*) _data_->_tmp66_);
							_data_->_tmp68_ = NULL;
							_data_->_tmp68_ = _data_->_tmp67_;
							_g_object_unref0 (_data_->_tmp66_);
							_data_->_entry_it = _data_->_tmp68_;
							while (TRUE) {
								_data_->_tmp69_ = NULL;
								_data_->_tmp69_ = _data_->_entry_it;
								_data_->_tmp70_ = FALSE;
								_data_->_tmp70_ = gee_iterator_next (_data_->_tmp69_);
								if (!_data_->_tmp70_) {
									break;
								}
								_data_->_tmp71_ = NULL;
								_data_->_tmp71_ = _data_->_entry_it;
								_data_->_tmp72_ = NULL;
								_data_->_tmp72_ = gee_iterator_get (_data_->_tmp71_);
								_data_->entry = (GeeMapEntry*) _data_->_tmp72_;
								_data_->_tmp73_ = NULL;
								_data_->_tmp73_ = _data_->modules_final;
								_data_->_tmp74_ = NULL;
								_data_->_tmp74_ = _data_->entry;
								_data_->_tmp75_ = NULL;
								_data_->_tmp75_ = gee_map_entry_get_key (_data_->_tmp74_);
								_data_->_tmp76_ = NULL;
								_data_->_tmp76_ = _data_->_tmp75_;
								_data_->_tmp77_ = NULL;
								_data_->_tmp77_ = _data_->entry;
								_data_->_tmp78_ = NULL;
								_data_->_tmp78_ = gee_map_entry_get_value (_data_->_tmp77_);
								_data_->_tmp79_ = NULL;
								_data_->_tmp79_ = _data_->_tmp78_;
								gee_abstract_map_set ((GeeAbstractMap*) _data_->_tmp73_, (const gchar*) _data_->_tmp76_, (GFile*) _data_->_tmp79_);
								_g_object_unref0 (_data_->entry);
							}
							_g_object_unref0 (_data_->_entry_it);
						}
					}
					_g_object_unref0 (_data_->modules);
				} else {
					_data_->_tmp80_ = NULL;
					_data_->_tmp80_ = _data_->mime;
					if (g_strcmp0 (_data_->_tmp80_, "application/x-sharedlib") == 0) {
						_data_->_tmp81_ = NULL;
						_data_->_tmp81_ = _data_->file;
						_data_->_tmp82_ = NULL;
						_data_->_tmp82_ = g_file_get_path (_data_->_tmp81_);
						_data_->path = _data_->_tmp82_;
						_data_->_tmp83_ = NULL;
						_data_->_tmp83_ = _data_->path;
						if (_data_->_tmp83_ != NULL) {
							_data_->_tmp84_ = NULL;
							_data_->_tmp84_ = _data_->modules_final;
							_data_->_tmp85_ = NULL;
							_data_->_tmp85_ = _data_->path;
							_data_->_tmp86_ = NULL;
							_data_->_tmp86_ = _data_->file;
							gee_abstract_map_set ((GeeAbstractMap*) _data_->_tmp84_, (const gchar*) _data_->_tmp85_, _data_->_tmp86_);
						}
						_g_free0 (_data_->path);
					} else {
						_data_->_tmp87_ = NULL;
						_data_->_tmp87_ = _data_->mime;
						if (_data_->_tmp87_ == NULL) {
							_data_->_tmp88_ = NULL;
							_data_->_tmp88_ = _data_->file;
							_data_->_tmp89_ = NULL;
							_data_->_tmp89_ = g_file_get_path (_data_->_tmp88_);
							_data_->_tmp90_ = NULL;
							_data_->_tmp90_ = _data_->_tmp89_;
							g_warning ("backend-store.vala:727: The content type of '%s' could not be determin" \
"ed. Have you installed shared-mime-info?", _data_->_tmp90_);
							_g_free0 (_data_->_tmp90_);
						} else {
							_data_->_tmp94_ = NULL;
							_data_->_tmp94_ = _data_->_path;
							if (_data_->_tmp94_ == NULL) {
								_data_->_tmp95_ = NULL;
								_data_->_tmp95_ = _data_->mime;
								_data_->_tmp93_ = g_strcmp0 (_data_->_tmp95_, "application/x-sharedlib") != 0;
							} else {
								_data_->_tmp93_ = FALSE;
							}
							if (_data_->_tmp93_) {
								_data_->_tmp96_ = NULL;
								_data_->_tmp96_ = _data_->mime;
								_data_->_tmp92_ = g_strcmp0 (_data_->_tmp96_, "application/x-shared-library-la") != 0;
							} else {
								_data_->_tmp92_ = FALSE;
							}
							if (_data_->_tmp92_) {
								_data_->_tmp97_ = NULL;
								_data_->_tmp97_ = _data_->mime;
								_data_->_tmp91_ = g_strcmp0 (_data_->_tmp97_, "inode/directory") != 0;
							} else {
								_data_->_tmp91_ = FALSE;
							}
							if (_data_->_tmp91_) {
								_data_->_tmp98_ = NULL;
								_data_->_tmp98_ = _data_->file;
								_data_->_tmp99_ = NULL;
								_data_->_tmp99_ = g_file_get_path (_data_->_tmp98_);
								_data_->_tmp100_ = NULL;
								_data_->_tmp100_ = _data_->_tmp99_;
								_data_->_tmp101_ = NULL;
								_data_->_tmp101_ = _data_->mime;
								g_warning ("backend-store.vala:740: The content type of '%s' appears to be '%s' wh" \
"ich looks suspicious. Have you installed shared-mime-info?", _data_->_tmp100_, _data_->_tmp101_);
								_g_free0 (_data_->_tmp100_);
							}
						}
					}
				}
				_g_free0 (_data_->mime);
				_g_object_unref0 (_data_->file);
				_g_object_unref0 (_data_->info);
			}
		}
	}
	_data_->_tmp102_ = NULL;
	_data_->_tmp102_ = _data_->dir;
	_data_->_tmp103_ = NULL;
	_data_->_tmp103_ = g_file_get_path (_data_->_tmp102_);
	_data_->_tmp104_ = NULL;
	_data_->_tmp104_ = _data_->_tmp103_;
	g_debug ("backend-store.vala:744: Finished searching for modules in folder '%s'", _data_->_tmp104_);
	_g_free0 (_data_->_tmp104_);
	_data_->result = _data_->modules_final;
	_g_free0 (_data_->_path);
	__g_list_free__g_object_unref0_0 (_data_->infos);
	_g_free0 (_data_->attributes);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
	_g_free0 (_data_->_path);
	_g_object_unref0 (_data_->modules_final);
	__g_list_free__g_object_unref0_0 (_data_->infos);
	_g_free0 (_data_->attributes);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void _folks_backend_store_load_module_from_file (FolksBackendStore* self, GFile* file) {
	gchar* _file_path = NULL;
	GFile* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* file_path = NULL;
	const gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	GeeHashMap* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	gboolean _tmp7_ = FALSE;
	GModule* _module = NULL;
	const gchar* _tmp8_ = NULL;
	GModule* _tmp9_ = NULL;
	GModule* _tmp10_ = NULL;
	GModule* module = NULL;
	GModule* _tmp13_ = NULL;
	void* function = NULL;
	GModule* _tmp14_ = NULL;
	void* _tmp15_ = NULL;
	gboolean _tmp16_ = FALSE;
	FolksBackendStoreModuleInitFunc module_init = NULL;
	void* _tmp19_ = NULL;
	FolksBackendStoreModuleInitFunc _tmp20_ = NULL;
	GeeHashMap* _tmp21_ = NULL;
	const gchar* _tmp22_ = NULL;
	GModule* _tmp23_ = NULL;
	GModule* _tmp24_ = NULL;
	FolksBackendStoreModuleInitFunc _tmp25_ = NULL;
	GModule* _tmp26_ = NULL;
	const gchar* _tmp27_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (file != NULL);
	_tmp0_ = file;
	_tmp1_ = g_file_get_path (_tmp0_);
	_file_path = _tmp1_;
	_tmp2_ = _file_path;
	if (_tmp2_ == NULL) {
		_g_free0 (_file_path);
		return;
	}
	_tmp3_ = _file_path;
	_tmp4_ = g_strdup ((const gchar*) _tmp3_);
	file_path = _tmp4_;
	_tmp5_ = self->priv->_modules;
	_tmp6_ = file_path;
	_tmp7_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp5_, _tmp6_);
	if (_tmp7_) {
		_g_free0 (file_path);
		_g_free0 (_file_path);
		return;
	}
	_tmp8_ = file_path;
	_tmp9_ = g_module_open (_tmp8_, G_MODULE_BIND_LOCAL);
	_module = _tmp9_;
	_tmp10_ = _module;
	if (_tmp10_ == NULL) {
		const gchar* _tmp11_ = NULL;
		const gchar* _tmp12_ = NULL;
		_tmp11_ = file_path;
		_tmp12_ = g_module_error ();
		g_warning ("backend-store.vala:765: Failed to load module from path '%s': %s", _tmp11_, _tmp12_);
		_g_module_close0 (_module);
		_g_free0 (file_path);
		_g_free0 (_file_path);
		return;
	}
	_tmp13_ = _module;
	module = (GModule*) _tmp13_;
	_tmp14_ = module;
	_tmp16_ = g_module_symbol (_tmp14_, "module_init", &_tmp15_);
	function = _tmp15_;
	if (!_tmp16_) {
		const gchar* _tmp17_ = NULL;
		const gchar* _tmp18_ = NULL;
		_tmp17_ = file_path;
		_tmp18_ = g_module_error ();
		g_warning ("backend-store.vala:779: Failed to find entry point function '%s' in '%" \
"s': %s", "module_init", _tmp17_, _tmp18_);
		_g_module_close0 (_module);
		_g_free0 (file_path);
		_g_free0 (_file_path);
		return;
	}
	_tmp19_ = function;
	module_init = (FolksBackendStoreModuleInitFunc) _tmp19_;
	_tmp20_ = module_init;
	_vala_assert (_tmp20_ != NULL, "module_init != null");
	_tmp21_ = self->priv->_modules;
	_tmp22_ = file_path;
	_tmp23_ = module;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp21_, _tmp22_, _tmp23_);
	_tmp24_ = module;
	g_module_make_resident (_tmp24_);
	_tmp25_ = module_init;
	_tmp25_ (self);
	_tmp26_ = module;
	_tmp27_ = g_module_name (_tmp26_);
	g_debug ("backend-store.vala:797: Loaded module source: '%s'", _tmp27_);
	_g_module_close0 (_module);
	_g_free0 (file_path);
	_g_free0 (_file_path);
}


static void _folks_backend_store_get_file_info_data_free (gpointer _data) {
	FolksBackendStoreGetFileInfoData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->file);
	g_slice_free (FolksBackendStoreGetFileInfoData, _data_);
}


static void _folks_backend_store_get_file_info (GFile* file, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	FolksBackendStoreGetFileInfoData* _data_;
	GFile* _tmp0_ = NULL;
	GFile* _tmp1_ = NULL;
	_data_ = g_slice_new0 (FolksBackendStoreGetFileInfoData);
	_data_->_async_result = g_simple_async_result_new (NULL, _callback_, _user_data_, _folks_backend_store_get_file_info);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, _folks_backend_store_get_file_info_data_free);
	_tmp0_ = file;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (_data_->file);
	_data_->file = _tmp1_;
	_folks_backend_store_get_file_info_co (_data_);
}


static void _folks_backend_store_get_file_info_finish (GAsyncResult* _res_, gboolean* is_file, gboolean* is_dir) {
	FolksBackendStoreGetFileInfoData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
	if (is_file) {
		*is_file = _data_->is_file;
	}
	if (is_dir) {
		*is_dir = _data_->is_dir;
	}
}


static void _folks_backend_store_get_file_info_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	FolksBackendStoreGetFileInfoData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	_folks_backend_store_get_file_info_co (_data_);
}


static gboolean _folks_backend_store_get_file_info_co (FolksBackendStoreGetFileInfoData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->is_file = FALSE;
	_data_->is_dir = FALSE;
	{
		_data_->_tmp1_ = NULL;
		_data_->_tmp1_ = _data_->file;
		_data_->_state_ = 1;
		g_file_query_info_async (_data_->_tmp1_, G_FILE_ATTRIBUTE_STANDARD_TYPE, G_FILE_QUERY_INFO_NONE, G_PRIORITY_DEFAULT, NULL, _folks_backend_store_get_file_info_ready, _data_);
		return FALSE;
		_state_1:
		_data_->_tmp2_ = NULL;
		_data_->_tmp2_ = g_file_query_info_finish (_data_->_tmp1_, _data_->_res_, &_data_->_inner_error_);
		_data_->_tmp0_ = _data_->_tmp2_;
		if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
			goto __catch6_g_error;
		}
		_data_->_tmp3_ = NULL;
		_data_->_tmp3_ = _data_->_tmp0_;
		_data_->_tmp0_ = NULL;
		_g_object_unref0 (_data_->file_info);
		_data_->file_info = _data_->_tmp3_;
		_g_object_unref0 (_data_->_tmp0_);
	}
	goto __finally6;
	__catch6_g_error:
	{
		_data_->_error_ = _data_->_inner_error_;
		_data_->_inner_error_ = NULL;
		_data_->_tmp4_ = NULL;
		_data_->_tmp4_ = _data_->_error_;
		if (g_error_matches (_data_->_tmp4_, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {
			_data_->_tmp5_ = NULL;
			_data_->_tmp5_ = _ ("File or directory '%s' does not exist.");
			_data_->_tmp6_ = NULL;
			_data_->_tmp6_ = _data_->file;
			_data_->_tmp7_ = NULL;
			_data_->_tmp7_ = g_file_get_path (_data_->_tmp6_);
			_data_->_tmp8_ = NULL;
			_data_->_tmp8_ = _data_->_tmp7_;
			g_critical (_data_->_tmp5_, _data_->_tmp8_);
			_g_free0 (_data_->_tmp8_);
		} else {
			_data_->_tmp9_ = NULL;
			_data_->_tmp9_ = _ ("Failed to get content type for '%s'.");
			_data_->_tmp10_ = NULL;
			_data_->_tmp10_ = _data_->file;
			_data_->_tmp11_ = NULL;
			_data_->_tmp11_ = g_file_get_path (_data_->_tmp10_);
			_data_->_tmp12_ = NULL;
			_data_->_tmp12_ = _data_->_tmp11_;
			g_critical (_data_->_tmp9_, _data_->_tmp12_);
			_g_free0 (_data_->_tmp12_);
		}
		_g_error_free0 (_data_->_error_);
		_g_object_unref0 (_data_->file_info);
		if (_data_->_state_ == 0) {
			g_simple_async_result_complete_in_idle (_data_->_async_result);
		} else {
			g_simple_async_result_complete (_data_->_async_result);
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	__finally6:
	if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
		_g_object_unref0 (_data_->file_info);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
		g_clear_error (&_data_->_inner_error_);
		return FALSE;
	}
	_data_->_tmp13_ = NULL;
	_data_->_tmp13_ = _data_->file_info;
	_data_->_tmp14_ = 0;
	_data_->_tmp14_ = g_file_info_get_file_type (_data_->_tmp13_);
	_data_->is_file = _data_->_tmp14_ == G_FILE_TYPE_REGULAR;
	_data_->_tmp15_ = NULL;
	_data_->_tmp15_ = _data_->file_info;
	_data_->_tmp16_ = 0;
	_data_->_tmp16_ = g_file_info_get_file_type (_data_->_tmp15_);
	_data_->is_dir = _data_->_tmp16_ == G_FILE_TYPE_DIRECTORY;
	_g_object_unref0 (_data_->file_info);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void _folks_backend_store_load_disabled_backend_names_data_free (gpointer _data) {
	FolksBackendStoreLoadDisabledBackendNamesData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (FolksBackendStoreLoadDisabledBackendNamesData, _data_);
}


static void _folks_backend_store_load_disabled_backend_names (FolksBackendStore* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	FolksBackendStoreLoadDisabledBackendNamesData* _data_;
	FolksBackendStore* _tmp0_ = NULL;
	_data_ = g_slice_new0 (FolksBackendStoreLoadDisabledBackendNamesData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, _folks_backend_store_load_disabled_backend_names);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, _folks_backend_store_load_disabled_backend_names_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_folks_backend_store_load_disabled_backend_names_co (_data_);
}


static void _folks_backend_store_load_disabled_backend_names_finish (FolksBackendStore* self, GAsyncResult* _res_) {
	FolksBackendStoreLoadDisabledBackendNamesData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void _folks_backend_store_load_disabled_backend_names_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	FolksBackendStoreLoadDisabledBackendNamesData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	_folks_backend_store_load_disabled_backend_names_co (_data_);
}


static gboolean _folks_backend_store_load_disabled_backend_names_co (FolksBackendStoreLoadDisabledBackendNamesData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = NULL;
	_data_->_tmp0_ = g_getenv ("FOLKS_BACKENDS_ALLOWED");
	_data_->_tmp1_ = NULL;
	_data_->_tmp1_ = g_strdup (_data_->_tmp0_);
	_data_->envvar = _data_->_tmp1_;
	_data_->_tmp2_ = NULL;
	_data_->_tmp2_ = _data_->envvar;
	if (_data_->_tmp2_ != NULL) {
		_data_->_tmp3_ = NULL;
		_data_->_tmp3_ = _data_->envvar;
		_data_->_tmp4_ = NULL;
		_data_->_tmp5_ = NULL;
		_data_->_tmp5_ = _data_->_tmp4_ = g_strsplit_set (_data_->_tmp3_, " ,:", 0);
		_data_->tokens_length1 = 0;
		_data_->_tokens_size_ = 0;
		_data_->tokens = _data_->_tmp5_;
		_data_->tokens_length1 = _vala_array_length (_data_->_tmp4_);
		_data_->_tokens_size_ = _data_->tokens_length1;
		_data_->_tmp6_ = NULL;
		_data_->_tmp6_ = folks_small_set_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL, NULL, NULL, NULL);
		_g_object_unref0 (_data_->self->priv->_backends_allowed);
		_data_->self->priv->_backends_allowed = _data_->_tmp6_;
		_data_->_tmp7_ = NULL;
		_data_->_tmp7__length1 = 0;
		_data_->_tmp7_ = _data_->tokens;
		_data_->_tmp7__length1 = _data_->tokens_length1;
		{
			_data_->s_collection_length1 = 0;
			_data_->_s_collection_size_ = 0;
			_data_->s_collection = _data_->_tmp7_;
			_data_->s_collection_length1 = _data_->_tmp7__length1;
			for (_data_->s_it = 0; _data_->s_it < _data_->_tmp7__length1; _data_->s_it = _data_->s_it + 1) {
				_data_->s = _data_->s_collection[_data_->s_it];
				{
					_data_->_tmp8_ = NULL;
					_data_->_tmp8_ = _data_->s;
					if (g_strcmp0 (_data_->_tmp8_, "all") == 0) {
						_g_object_unref0 (_data_->self->priv->_backends_allowed);
						_data_->self->priv->_backends_allowed = NULL;
						break;
					}
					_data_->_tmp9_ = NULL;
					_data_->_tmp9_ = _data_->s;
					if (g_strcmp0 (_data_->_tmp9_, "") != 0) {
						_data_->_tmp10_ = NULL;
						_data_->_tmp10_ = _data_->self->priv->_backends_allowed;
						_data_->_tmp11_ = NULL;
						_data_->_tmp11_ = _data_->s;
						gee_abstract_collection_add ((GeeAbstractCollection*) _data_->_tmp10_, _data_->_tmp11_);
					}
				}
			}
		}
		_data_->_tmp12_ = NULL;
		_data_->_tmp12_ = _data_->self->priv->_backends_allowed;
		if (_data_->_tmp12_ != NULL) {
			g_debug ("backend-store.vala:872: Backends limited by FOLKS_BACKENDS_ALLOWED:");
			_data_->_tmp13_ = NULL;
			_data_->_tmp13__length1 = 0;
			_data_->_tmp13_ = _data_->tokens;
			_data_->_tmp13__length1 = _data_->tokens_length1;
			{
				_data_->_vala1_s_collection_length1 = 0;
				_data_->__vala1_s_collection_size_ = 0;
				_data_->_vala1_s_collection = _data_->_tmp13_;
				_data_->_vala1_s_collection_length1 = _data_->_tmp13__length1;
				for (_data_->_vala1_s_it = 0; _data_->_vala1_s_it < _data_->_tmp13__length1; _data_->_vala1_s_it = _data_->_vala1_s_it + 1) {
					_data_->_vala1_s = _data_->_vala1_s_collection[_data_->_vala1_s_it];
					{
						_data_->_tmp14_ = NULL;
						_data_->_tmp14_ = _data_->_vala1_s;
						g_debug ("backend-store.vala:875: Backend '%s' is allowed", _data_->_tmp14_);
					}
				}
			}
			g_debug ("backend-store.vala:877: All other backends disabled by FOLKS_BACKENDS_" \
"ALLOWED");
		}
		_data_->tokens = (_vala_array_free (_data_->tokens, _data_->tokens_length1, (GDestroyNotify) g_free), NULL);
	}
	_data_->_tmp15_ = NULL;
	_data_->_tmp15_ = g_getenv ("FOLKS_BACKENDS_DISABLED");
	_data_->_tmp16_ = NULL;
	_data_->_tmp16_ = g_strdup (_data_->_tmp15_);
	_g_free0 (_data_->envvar);
	_data_->envvar = _data_->_tmp16_;
	_data_->_tmp17_ = NULL;
	_data_->_tmp17_ = _data_->envvar;
	if (_data_->_tmp17_ != NULL) {
		_data_->_tmp18_ = NULL;
		_data_->_tmp18_ = _data_->envvar;
		_data_->_tmp19_ = NULL;
		_data_->_tmp20_ = NULL;
		_data_->_tmp20_ = _data_->_tmp19_ = g_strsplit_set (_data_->_tmp18_, " ,:", 0);
		_data_->_vala1_tokens_length1 = 0;
		_data_->__vala1_tokens_size_ = 0;
		_data_->_vala1_tokens = _data_->_tmp20_;
		_data_->_vala1_tokens_length1 = _vala_array_length (_data_->_tmp19_);
		_data_->__vala1_tokens_size_ = _data_->_vala1_tokens_length1;
		_data_->_tmp21_ = NULL;
		_data_->_tmp21_ = folks_small_set_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL, NULL, NULL, NULL);
		_g_object_unref0 (_data_->self->priv->_backends_disabled);
		_data_->self->priv->_backends_disabled = _data_->_tmp21_;
		_data_->_tmp22_ = NULL;
		_data_->_tmp22__length1 = 0;
		_data_->_tmp22_ = _data_->_vala1_tokens;
		_data_->_tmp22__length1 = _data_->_vala1_tokens_length1;
		{
			_data_->_vala2_s_collection_length1 = 0;
			_data_->__vala2_s_collection_size_ = 0;
			_data_->_vala2_s_collection = _data_->_tmp22_;
			_data_->_vala2_s_collection_length1 = _data_->_tmp22__length1;
			for (_data_->_vala2_s_it = 0; _data_->_vala2_s_it < _data_->_tmp22__length1; _data_->_vala2_s_it = _data_->_vala2_s_it + 1) {
				_data_->_vala2_s = _data_->_vala2_s_collection[_data_->_vala2_s_it];
				{
					_data_->_tmp23_ = NULL;
					_data_->_tmp23_ = _data_->_vala2_s;
					if (g_strcmp0 (_data_->_tmp23_, "") != 0) {
						_data_->_tmp24_ = NULL;
						_data_->_tmp24_ = _data_->_vala2_s;
						g_debug ("backend-store.vala:895: Backend '%s' disabled by FOLKS_BACKENDS_DISABL" \
"ED", _data_->_tmp24_);
						_data_->_tmp25_ = NULL;
						_data_->_tmp25_ = _data_->self->priv->_backends_disabled;
						_data_->_tmp26_ = NULL;
						_data_->_tmp26_ = _data_->_vala2_s;
						gee_abstract_collection_add ((GeeAbstractCollection*) _data_->_tmp25_, _data_->_tmp26_);
					}
				}
			}
		}
		_data_->_vala1_tokens = (_vala_array_free (_data_->_vala1_tokens, _data_->_vala1_tokens_length1, (GDestroyNotify) g_free), NULL);
	}
	_data_->_tmp27_ = NULL;
	_data_->_tmp27_ = g_getenv ("FOLKS_BACKEND_STORE_KEY_FILE_PATH");
	_data_->path = _data_->_tmp27_;
	_data_->_tmp28_ = NULL;
	_data_->_tmp28_ = _data_->path;
	if (_data_->_tmp28_ == NULL) {
		_data_->_tmp29_ = NULL;
		_data_->_tmp29_ = g_get_user_data_dir ();
		_data_->_tmp30_ = NULL;
		_data_->_tmp30_ = g_file_new_for_path (_data_->_tmp29_);
		_g_object_unref0 (_data_->file);
		_data_->file = _data_->_tmp30_;
		_data_->_tmp31_ = NULL;
		_data_->_tmp31_ = _data_->file;
		_data_->_tmp32_ = NULL;
		_data_->_tmp32_ = g_file_get_child (_data_->_tmp31_, "folks");
		_g_object_unref0 (_data_->file);
		_data_->file = _data_->_tmp32_;
		_data_->_tmp33_ = NULL;
		_data_->_tmp33_ = _data_->file;
		_data_->_tmp34_ = NULL;
		_data_->_tmp34_ = g_file_get_child (_data_->_tmp33_, "backends.ini");
		_g_object_unref0 (_data_->file);
		_data_->file = _data_->_tmp34_;
		_data_->_tmp35_ = NULL;
		_data_->_tmp35_ = _data_->file;
		_data_->_tmp36_ = NULL;
		_data_->_tmp36_ = g_file_get_path (_data_->_tmp35_);
		_data_->_tmp37_ = NULL;
		_data_->_tmp37_ = _data_->_tmp36_;
		g_debug ("Using built-in backends key file '%s' (override with " "environment variable FOLKS_BACKEND_STORE_KEY_FILE_PATH)", _data_->_tmp37_);
		_g_free0 (_data_->_tmp37_);
	} else {
		_data_->_tmp38_ = NULL;
		_data_->_tmp38_ = _data_->path;
		_data_->_tmp39_ = NULL;
		_data_->_tmp39_ = g_file_new_for_path ((const gchar*) _data_->_tmp38_);
		_g_object_unref0 (_data_->file);
		_data_->file = _data_->_tmp39_;
		_data_->_tmp40_ = NULL;
		_data_->_tmp40_ = _data_->path;
		g_debug ("Using environment variable " "FOLKS_BACKEND_STORE_KEY_FILE_PATH = '%s' to load the backends " "key file.", (const gchar*) _data_->_tmp40_);
	}
	_data_->_tmp41_ = NULL;
	_data_->_tmp41_ = _data_->file;
	_data_->_tmp42_ = NULL;
	_data_->_tmp42_ = _g_object_ref0 (_data_->_tmp41_);
	_g_object_unref0 (_data_->self->priv->_config_file);
	_data_->self->priv->_config_file = _data_->_tmp42_;
	_data_->_tmp43_ = NULL;
	_data_->_tmp43_ = g_key_file_new ();
	_data_->key_file = _data_->_tmp43_;
	{
		_data_->contents_length1 = 0;
		_data_->_contents_size_ = 0;
		_data_->_tmp44_ = NULL;
		_data_->_tmp44_ = _data_->file;
		_data_->_tmp45_ = NULL;
		memset (&_data_->_tmp46_, 0, sizeof (gsize));
		_data_->_state_ = 1;
		g_file_load_contents_async (_data_->_tmp44_, NULL, _folks_backend_store_load_disabled_backend_names_ready, _data_);
		return FALSE;
		_state_1:
		g_file_load_contents_finish (_data_->_tmp44_, _data_->_res_, &_data_->_tmp45_, &_data_->_tmp46_, NULL, &_data_->_inner_error_);
		_data_->contents = (g_free (_data_->contents), NULL);
		_data_->contents = _data_->_tmp45_;
		_data_->contents_length1 = _data_->_tmp46_;
		_data_->_contents_size_ = _data_->contents_length1;
		if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
			_data_->contents = (g_free (_data_->contents), NULL);
			goto __catch7_g_error;
		}
		_data_->_tmp47_ = NULL;
		_data_->_tmp47__length1 = 0;
		_data_->_tmp47_ = _data_->contents;
		_data_->_tmp47__length1 = _data_->contents_length1;
		_data_->contents_s = (const gchar*) _data_->_tmp47_;
		_data_->_tmp48_ = NULL;
		_data_->_tmp48_ = _data_->contents_s;
		_data_->_tmp49_ = 0;
		_data_->_tmp49_ = strlen (_data_->_tmp48_);
		_data_->_tmp50_ = 0;
		_data_->_tmp50_ = _data_->_tmp49_;
		if (_data_->_tmp50_ > 0) {
			_data_->_tmp51_ = NULL;
			_data_->_tmp51_ = _data_->key_file;
			_data_->_tmp52_ = NULL;
			_data_->_tmp52_ = _data_->contents_s;
			_data_->_tmp53_ = NULL;
			_data_->_tmp53_ = _data_->contents_s;
			_data_->_tmp54_ = 0;
			_data_->_tmp54_ = strlen (_data_->_tmp53_);
			_data_->_tmp55_ = 0;
			_data_->_tmp55_ = _data_->_tmp54_;
			g_key_file_load_from_data (_data_->_tmp51_, _data_->_tmp52_, (gsize) _data_->_tmp55_, G_KEY_FILE_KEEP_COMMENTS, &_data_->_inner_error_);
			if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
				_data_->contents = (g_free (_data_->contents), NULL);
				goto __catch7_g_error;
			}
		}
		_data_->contents = (g_free (_data_->contents), NULL);
	}
	goto __finally7;
	__catch7_g_error:
	{
		_data_->e1 = _data_->_inner_error_;
		_data_->_inner_error_ = NULL;
		_data_->_tmp56_ = NULL;
		_data_->_tmp56_ = _data_->e1;
		if (!g_error_matches (_data_->_tmp56_, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {
			_data_->_tmp57_ = NULL;
			_data_->_tmp57_ = _data_->file;
			_data_->_tmp58_ = NULL;
			_data_->_tmp58_ = g_file_get_path (_data_->_tmp57_);
			_data_->_tmp59_ = NULL;
			_data_->_tmp59_ = _data_->_tmp58_;
			_data_->_tmp60_ = NULL;
			_data_->_tmp60_ = _data_->e1;
			_data_->_tmp61_ = NULL;
			_data_->_tmp61_ = _data_->_tmp60_->message;
			g_warning ("backend-store.vala:943: The backends key file '%s' could not be loaded" \
": %s", _data_->_tmp59_, _data_->_tmp61_);
			_g_free0 (_data_->_tmp59_);
			_g_error_free0 (_data_->e1);
			{
				_data_->_tmp62_ = NULL;
				_data_->_tmp62_ = _data_->key_file;
				_data_->key_file = NULL;
				_g_key_file_free0 (_data_->self->priv->_backends_key_file);
				_data_->self->priv->_backends_key_file = _data_->_tmp62_;
			}
			_g_key_file_free0 (_data_->key_file);
			_g_object_unref0 (_data_->file);
			_g_free0 (_data_->envvar);
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		}
		_g_error_free0 (_data_->e1);
	}
	__finally7:
	{
		_data_->_tmp63_ = NULL;
		_data_->_tmp63_ = _data_->key_file;
		_data_->key_file = NULL;
		_g_key_file_free0 (_data_->self->priv->_backends_key_file);
		_data_->self->priv->_backends_key_file = _data_->_tmp63_;
	}
	if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
		_g_key_file_free0 (_data_->key_file);
		_g_object_unref0 (_data_->file);
		_g_free0 (_data_->envvar);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
		g_clear_error (&_data_->_inner_error_);
		return FALSE;
	}
	_g_key_file_free0 (_data_->key_file);
	_g_object_unref0 (_data_->file);
	_g_free0 (_data_->envvar);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void _folks_backend_store_save_key_file_data_free (gpointer _data) {
	FolksBackendStoreSaveKeyFileData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (FolksBackendStoreSaveKeyFileData, _data_);
}


static void _folks_backend_store_save_key_file (FolksBackendStore* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	FolksBackendStoreSaveKeyFileData* _data_;
	FolksBackendStore* _tmp0_ = NULL;
	_data_ = g_slice_new0 (FolksBackendStoreSaveKeyFileData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, _folks_backend_store_save_key_file);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, _folks_backend_store_save_key_file_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_folks_backend_store_save_key_file_co (_data_);
}


static void _folks_backend_store_save_key_file_finish (FolksBackendStore* self, GAsyncResult* _res_) {
	FolksBackendStoreSaveKeyFileData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static guint8* string_get_data (const gchar* self, int* result_length1) {
	guint8* result;
	guint8* res = NULL;
	gint res_length1 = 0;
	gint _res_size_ = 0;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	guint8* _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	guint8* _tmp4_ = NULL;
	gint _tmp4__length1 = 0;
	g_return_val_if_fail (self != NULL, NULL);
	res = (guint8*) self;
	res_length1 = -1;
	_res_size_ = res_length1;
	_tmp0_ = strlen (self);
	_tmp1_ = _tmp0_;
	res_length1 = (gint) _tmp1_;
	_tmp2_ = res_length1;
	_tmp3_ = res;
	_tmp3__length1 = res_length1;
	_tmp4_ = _tmp3_;
	_tmp4__length1 = _tmp3__length1;
	if (result_length1) {
		*result_length1 = _tmp4__length1;
	}
	result = _tmp4_;
	return result;
}


static void _folks_backend_store_save_key_file_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	FolksBackendStoreSaveKeyFileData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	_folks_backend_store_save_key_file_co (_data_);
}


static gboolean _folks_backend_store_save_key_file_co (FolksBackendStoreSaveKeyFileData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = NULL;
	_data_->_tmp0_ = _data_->self->priv->_backends_key_file;
	_data_->_tmp1_ = NULL;
	_data_->_tmp1_ = g_key_file_to_data (_data_->_tmp0_, NULL, NULL);
	_data_->key_file_data = _data_->_tmp1_;
	_data_->_tmp2_ = NULL;
	_data_->_tmp2_ = _data_->self->priv->_config_file;
	_data_->_tmp3_ = NULL;
	_data_->_tmp3_ = g_file_get_path (_data_->_tmp2_);
	_data_->_tmp4_ = NULL;
	_data_->_tmp4_ = _data_->_tmp3_;
	g_debug ("backend-store.vala:961: Saving backend key file '%s'.", _data_->_tmp4_);
	_g_free0 (_data_->_tmp4_);
	{
		_data_->_tmp5_ = NULL;
		_data_->_tmp5_ = _data_->self->priv->_config_file;
		_data_->_tmp6_ = NULL;
		_data_->_tmp6__length1 = 0;
		_data_->_tmp6_ = string_get_data (_data_->key_file_data, &_data_->_tmp6__length1);
		_data_->_tmp7_ = NULL;
		_data_->_tmp7__length1 = 0;
		_data_->_tmp7_ = _data_->_tmp6_;
		_data_->_tmp7__length1 = _data_->_tmp6__length1;
		_data_->_state_ = 1;
		g_file_replace_contents_async (_data_->_tmp5_, _data_->_tmp7_, (gsize) _data_->_tmp7__length1, NULL, FALSE, G_FILE_CREATE_PRIVATE, NULL, _folks_backend_store_save_key_file_ready, _data_);
		return FALSE;
		_state_1:
		g_file_replace_contents_finish (_data_->_tmp5_, _data_->_res_, NULL, &_data_->_inner_error_);
		if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
			goto __catch8_g_error;
		}
	}
	goto __finally8;
	__catch8_g_error:
	{
		_data_->e = _data_->_inner_error_;
		_data_->_inner_error_ = NULL;
		_data_->_tmp8_ = NULL;
		_data_->_tmp8_ = _data_->self->priv->_config_file;
		_data_->_tmp9_ = NULL;
		_data_->_tmp9_ = g_file_get_path (_data_->_tmp8_);
		_data_->_tmp10_ = NULL;
		_data_->_tmp10_ = _data_->_tmp9_;
		_data_->_tmp11_ = NULL;
		_data_->_tmp11_ = _data_->e;
		_data_->_tmp12_ = NULL;
		_data_->_tmp12_ = _data_->_tmp11_->message;
		g_warning ("backend-store.vala:978: Could not write updated backend key file '%s':" \
" %s", _data_->_tmp10_, _data_->_tmp12_);
		_g_free0 (_data_->_tmp10_);
		_g_error_free0 (_data_->e);
	}
	__finally8:
	if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
		_g_free0 (_data_->key_file_data);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
		g_clear_error (&_data_->_inner_error_);
		return FALSE;
	}
	_g_free0 (_data_->key_file_data);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


GeeMap* folks_backend_store_get_enabled_backends (FolksBackendStore* self) {
	GeeMap* result;
	GeeMap* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_prepared_backends_ro;
	result = _tmp0_;
	return result;
}


static void folks_backend_store_set_enabled_backends (FolksBackendStore* self, GeeMap* value) {
	g_return_if_fail (self != NULL);
	g_object_notify ((GObject *) self, "enabled-backends");
}


gboolean folks_backend_store_get_is_prepared (FolksBackendStore* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_is_prepared;
	result = _tmp0_;
	return result;
}


static void folks_backend_store_set_is_prepared (FolksBackendStore* self, gboolean value) {
	g_return_if_fail (self != NULL);
	g_object_notify ((GObject *) self, "is-prepared");
}


static GObject * folks_backend_store_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	FolksBackendStore * self;
	gchar* debug_no_colour = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	const gchar* _tmp3_ = NULL;
	const gchar* _tmp5_ = NULL;
	FolksDebug* _tmp6_ = NULL;
	FolksDebug* _tmp7_ = NULL;
	FolksDebug* _tmp8_ = NULL;
	GeeHashMap* _tmp9_ = NULL;
	GeeHashMap* _tmp10_ = NULL;
	GeeHashMap* _tmp11_ = NULL;
	GeeHashMap* _tmp12_ = NULL;
	GeeMap* _tmp13_ = NULL;
	GeeMap* _tmp14_ = NULL;
	parent_class = G_OBJECT_CLASS (folks_backend_store_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FOLKS_TYPE_BACKEND_STORE, FolksBackendStore);
	_tmp0_ = g_getenv ("FOLKS_DEBUG_NO_COLOUR");
	_tmp1_ = g_strdup (_tmp0_);
	debug_no_colour = _tmp1_;
	_tmp3_ = debug_no_colour;
	if (_tmp3_ == NULL) {
		_tmp2_ = TRUE;
	} else {
		const gchar* _tmp4_ = NULL;
		_tmp4_ = debug_no_colour;
		_tmp2_ = g_strcmp0 (_tmp4_, "0") == 0;
	}
	_tmp5_ = g_getenv ("G_MESSAGES_DEBUG");
	_tmp6_ = folks_debug_dup_with_flags (_tmp5_, _tmp2_);
	_g_object_unref0 (self->priv->_debug);
	self->priv->_debug = _tmp6_;
	_tmp7_ = self->priv->_debug;
	_folks_debug_register_domain (_tmp7_, G_LOG_DOMAIN);
	_tmp8_ = self->priv->_debug;
	g_signal_connect_object (_tmp8_, "print-status", (GCallback) __folks_backend_store_debug_print_status_folks_debug_print_status, self, 0);
	_tmp9_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_POINTER, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->_modules);
	self->priv->_modules = _tmp9_;
	_tmp10_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, FOLKS_TYPE_BACKEND, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->_backend_hash);
	self->priv->_backend_hash = _tmp10_;
	_tmp11_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, FOLKS_TYPE_BACKEND, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->_prepared_backends);
	self->priv->_prepared_backends = _tmp11_;
	_tmp12_ = self->priv->_prepared_backends;
	_tmp13_ = gee_abstract_map_get_read_only_view ((GeeAbstractMap*) _tmp12_);
	_tmp14_ = _tmp13_;
	_g_object_unref0 (self->priv->_prepared_backends_ro);
	self->priv->_prepared_backends_ro = _tmp14_;
	_g_free0 (debug_no_colour);
	return obj;
}


static void folks_backend_store_class_init (FolksBackendStoreClass * klass) {
	gchar* _tmp0_ = NULL;
	folks_backend_store_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (FolksBackendStorePrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_folks_backend_store_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_folks_backend_store_set_property;
	G_OBJECT_CLASS (klass)->constructor = folks_backend_store_constructor;
	G_OBJECT_CLASS (klass)->finalize = folks_backend_store_finalize;
	/**
	   * The list of backends visible to this store which have not been explicitly
	   * disabled.
	   *
	   * This list will be empty before {@link BackendStore.load_backends} has been
	   * called.
	   *
	   * The backends in this list have been prepared and are ready to use.
	   *
	   * @since 0.5.1
	   */
	g_object_class_install_property (G_OBJECT_CLASS (klass), FOLKS_BACKEND_STORE_ENABLED_BACKENDS, g_param_spec_object ("enabled-backends", "enabled-backends", "enabled-backends", GEE_TYPE_MAP, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	/**
	   * Whether {@link BackendStore.prepare} has successfully completed for this
	   * store.
	   *
	   * @since 0.3.0
	   */
	g_object_class_install_property (G_OBJECT_CLASS (klass), FOLKS_BACKEND_STORE_IS_PREPARED, g_param_spec_boolean ("is-prepared", "is-prepared", "is-prepared", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	/**
	   * Emitted when a backend has been added to the BackendStore.
	   *
	   * This will not be emitted until after {@link BackendStore.load_backends}
	   * has been called.
	   *
	   * {@link Backend}s referenced in this signal are also included in
	   * {@link BackendStore.enabled_backends}.
	   *
	   * @param backend the new {@link Backend}
	   */
	g_signal_new ("backend_available", FOLKS_TYPE_BACKEND_STORE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, FOLKS_TYPE_BACKEND);
	_tmp0_ = g_strdup ("all-others");
	folks_backend_store_KEY_FILE_GROUP_ALL_OTHERS = _tmp0_;
}


static void folks_backend_store_instance_init (FolksBackendStore * self) {
	self->priv = FOLKS_BACKEND_STORE_GET_PRIVATE (self);
	self->priv->_is_prepared = FALSE;
}


static void folks_backend_store_finalize (GObject* obj) {
	FolksBackendStore * self;
	GeeMapIterator* iter = NULL;
	GeeHashMap* _tmp0_ = NULL;
	GeeMapIterator* _tmp1_ = NULL;
	GeeHashMap* _tmp7_ = NULL;
	GeeHashMap* _tmp23_ = NULL;
	FolksDebug* _tmp24_ = NULL;
	guint _tmp25_ = 0U;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FOLKS_TYPE_BACKEND_STORE, FolksBackendStore);
	_tmp0_ = self->priv->_prepared_backends;
	_tmp1_ = gee_abstract_map_map_iterator ((GeeAbstractMap*) _tmp0_);
	iter = _tmp1_;
	while (TRUE) {
		GeeMapIterator* _tmp2_ = NULL;
		gboolean _tmp3_ = FALSE;
		FolksBackend* backend = NULL;
		GeeMapIterator* _tmp4_ = NULL;
		gpointer _tmp5_ = NULL;
		FolksBackend* _tmp6_ = NULL;
		_tmp2_ = iter;
		_tmp3_ = gee_map_iterator_next (_tmp2_);
		if (!(_tmp3_ == TRUE)) {
			break;
		}
		_tmp4_ = iter;
		_tmp5_ = gee_map_iterator_get_value (_tmp4_);
		backend = (FolksBackend*) _tmp5_;
		_tmp6_ = backend;
		folks_backend_unprepare (_tmp6_, NULL, NULL);
		_g_object_unref0 (backend);
	}
	_tmp7_ = self->priv->_prepared_backends;
	gee_abstract_map_clear ((GeeAbstractMap*) _tmp7_);
	{
		GeeIterator* _module_it = NULL;
		GeeHashMap* _tmp8_ = NULL;
		GeeCollection* _tmp9_ = NULL;
		GeeCollection* _tmp10_ = NULL;
		GeeCollection* _tmp11_ = NULL;
		GeeIterator* _tmp12_ = NULL;
		GeeIterator* _tmp13_ = NULL;
		_tmp8_ = self->priv->_modules;
		_tmp9_ = gee_abstract_map_get_values ((GeeMap*) _tmp8_);
		_tmp10_ = _tmp9_;
		_tmp11_ = _tmp10_;
		_tmp12_ = gee_iterable_iterator ((GeeIterable*) _tmp11_);
		_tmp13_ = _tmp12_;
		_g_object_unref0 (_tmp11_);
		_module_it = _tmp13_;
		while (TRUE) {
			GeeIterator* _tmp14_ = NULL;
			gboolean _tmp15_ = FALSE;
			GModule* module = NULL;
			GeeIterator* _tmp16_ = NULL;
			gpointer _tmp17_ = NULL;
			void* func = NULL;
			GModule* _tmp18_ = NULL;
			void* _tmp19_ = NULL;
			gboolean _tmp20_ = FALSE;
			_tmp14_ = _module_it;
			_tmp15_ = gee_iterator_next (_tmp14_);
			if (!_tmp15_) {
				break;
			}
			_tmp16_ = _module_it;
			_tmp17_ = gee_iterator_get (_tmp16_);
			module = (GModule*) _tmp17_;
			_tmp18_ = module;
			_tmp20_ = g_module_symbol (_tmp18_, "module_finalize", &_tmp19_);
			func = _tmp19_;
			if (_tmp20_) {
				FolksBackendStoreModuleFinalizeFunc module_finalize = NULL;
				void* _tmp21_ = NULL;
				FolksBackendStoreModuleFinalizeFunc _tmp22_ = NULL;
				_tmp21_ = func;
				module_finalize = (FolksBackendStoreModuleFinalizeFunc) _tmp21_;
				_tmp22_ = module_finalize;
				_tmp22_ (self);
			}
		}
		_g_object_unref0 (_module_it);
	}
	_tmp23_ = self->priv->_modules;
	gee_abstract_map_clear ((GeeAbstractMap*) _tmp23_);
	_tmp24_ = self->priv->_debug;
	g_signal_parse_name ("print-status", FOLKS_TYPE_DEBUG, &_tmp25_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (_tmp24_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp25_, 0, NULL, (GCallback) __folks_backend_store_debug_print_status_folks_debug_print_status, self);
	folks_backend_store__instance = NULL;
	_g_object_unref0 (iter);
	_g_object_unref0 (self->priv->_backend_hash);
	_g_object_unref0 (self->priv->_backends_allowed);
	_g_object_unref0 (self->priv->_backends_disabled);
	_g_object_unref0 (self->priv->_prepared_backends);
	_g_object_unref0 (self->priv->_prepared_backends_ro);
	_g_object_unref0 (self->priv->_config_file);
	_g_key_file_free0 (self->priv->_backends_key_file);
	_g_object_unref0 (self->priv->_modules);
	_g_object_unref0 (self->priv->_debug);
	G_OBJECT_CLASS (folks_backend_store_parent_class)->finalize (obj);
}


/**
 * Responsible for backend loading.
 *
 * The BackendStore manages the set of available Folks backends. The
 * {@link BackendStore.load_backends} function loads all compatible and enabled
 * backends and the {@link BackendStore.backend_available} signal notifies when
 * these backends are ready.
 */
GType folks_backend_store_get_type (void) {
	static volatile gsize folks_backend_store_type_id__volatile = 0;
	if (g_once_init_enter (&folks_backend_store_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FolksBackendStoreClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) folks_backend_store_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FolksBackendStore), 0, (GInstanceInitFunc) folks_backend_store_instance_init, NULL };
		GType folks_backend_store_type_id;
		folks_backend_store_type_id = g_type_register_static (G_TYPE_OBJECT, "FolksBackendStore", &g_define_type_info, 0);
		g_once_init_leave (&folks_backend_store_type_id__volatile, folks_backend_store_type_id);
	}
	return folks_backend_store_type_id__volatile;
}


static void _vala_folks_backend_store_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	FolksBackendStore * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, FOLKS_TYPE_BACKEND_STORE, FolksBackendStore);
	switch (property_id) {
		case FOLKS_BACKEND_STORE_ENABLED_BACKENDS:
		g_value_set_object (value, folks_backend_store_get_enabled_backends (self));
		break;
		case FOLKS_BACKEND_STORE_IS_PREPARED:
		g_value_set_boolean (value, folks_backend_store_get_is_prepared (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_folks_backend_store_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	FolksBackendStore * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, FOLKS_TYPE_BACKEND_STORE, FolksBackendStore);
	switch (property_id) {
		case FOLKS_BACKEND_STORE_ENABLED_BACKENDS:
		folks_backend_store_set_enabled_backends (self, g_value_get_object (value));
		break;
		case FOLKS_BACKEND_STORE_IS_PREPARED:
		folks_backend_store_set_is_prepared (self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



