/* tp-zeitgeist-dummy.c generated by valac 0.35.3.10-6b27, the Vala compiler
 * generated from tp-zeitgeist-dummy.vala, do not modify */

/*
 * Copyright (C) 2013 Philip Withnall
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Authors:
 * 	Philip Withnall <philip@tecnocode.co.uk>
 */

#include <glib.h>
#include <glib-object.h>
#include <folks/folks.h>
#include <telepathy-glib/telepathy-glib.h>
#include <gio/gio.h>


#define FOLKS_TP_ZEITGEIST_TYPE_CONTROLLER (folks_tp_zeitgeist_controller_get_type ())
#define FOLKS_TP_ZEITGEIST_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FOLKS_TP_ZEITGEIST_TYPE_CONTROLLER, FolksTpZeitgeistController))
#define FOLKS_TP_ZEITGEIST_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FOLKS_TP_ZEITGEIST_TYPE_CONTROLLER, FolksTpZeitgeistControllerClass))
#define FOLKS_TP_ZEITGEIST_IS_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FOLKS_TP_ZEITGEIST_TYPE_CONTROLLER))
#define FOLKS_TP_ZEITGEIST_IS_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FOLKS_TP_ZEITGEIST_TYPE_CONTROLLER))
#define FOLKS_TP_ZEITGEIST_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FOLKS_TP_ZEITGEIST_TYPE_CONTROLLER, FolksTpZeitgeistControllerClass))

typedef struct _FolksTpZeitgeistController FolksTpZeitgeistController;
typedef struct _FolksTpZeitgeistControllerClass FolksTpZeitgeistControllerClass;
typedef struct _FolksTpZeitgeistControllerPrivate FolksTpZeitgeistControllerPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _FolksTpZeitgeistControllerPopulateCountersData FolksTpZeitgeistControllerPopulateCountersData;

struct _FolksTpZeitgeistController {
	GObject parent_instance;
	FolksTpZeitgeistControllerPrivate * priv;
};

struct _FolksTpZeitgeistControllerClass {
	GObjectClass parent_class;
};

typedef void (*FolksTpZeitgeistControllerIncreasePersonaCounter) (FolksPersona* p, GDateTime* converted_datetime);
struct _FolksTpZeitgeistControllerPopulateCountersData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	FolksTpZeitgeistController* self;
};


static gpointer folks_tp_zeitgeist_controller_parent_class = NULL;

GType folks_tp_zeitgeist_controller_get_type (void) G_GNUC_CONST;
enum  {
	FOLKS_TP_ZEITGEIST_CONTROLLER_DUMMY_PROPERTY
};
FolksTpZeitgeistController* folks_tp_zeitgeist_controller_new (FolksPersonaStore* store, TpAccount* account, FolksTpZeitgeistControllerIncreasePersonaCounter im_interaction_cb, FolksTpZeitgeistControllerIncreasePersonaCounter last_call_interaction_cb);
FolksTpZeitgeistController* folks_tp_zeitgeist_controller_construct (GType object_type, FolksPersonaStore* store, TpAccount* account, FolksTpZeitgeistControllerIncreasePersonaCounter im_interaction_cb, FolksTpZeitgeistControllerIncreasePersonaCounter last_call_interaction_cb);
static void folks_tp_zeitgeist_controller_populate_counters_data_free (gpointer _data);
void folks_tp_zeitgeist_controller_populate_counters (FolksTpZeitgeistController* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void folks_tp_zeitgeist_controller_populate_counters_finish (FolksTpZeitgeistController* self, GAsyncResult* _res_);
static gboolean folks_tp_zeitgeist_controller_populate_counters_co (FolksTpZeitgeistControllerPopulateCountersData* _data_);


FolksTpZeitgeistController* folks_tp_zeitgeist_controller_construct (GType object_type, FolksPersonaStore* store, TpAccount* account, FolksTpZeitgeistControllerIncreasePersonaCounter im_interaction_cb, FolksTpZeitgeistControllerIncreasePersonaCounter last_call_interaction_cb) {
	FolksTpZeitgeistController * self = NULL;
	g_return_val_if_fail (store != NULL, NULL);
	g_return_val_if_fail (account != NULL, NULL);
	self = (FolksTpZeitgeistController*) g_object_new (object_type, NULL);
	return self;
}


FolksTpZeitgeistController* folks_tp_zeitgeist_controller_new (FolksPersonaStore* store, TpAccount* account, FolksTpZeitgeistControllerIncreasePersonaCounter im_interaction_cb, FolksTpZeitgeistControllerIncreasePersonaCounter last_call_interaction_cb) {
	return folks_tp_zeitgeist_controller_construct (FOLKS_TP_ZEITGEIST_TYPE_CONTROLLER, store, account, im_interaction_cb, last_call_interaction_cb);
}


static void folks_tp_zeitgeist_controller_populate_counters_data_free (gpointer _data) {
	FolksTpZeitgeistControllerPopulateCountersData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (FolksTpZeitgeistControllerPopulateCountersData, _data_);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void folks_tp_zeitgeist_controller_populate_counters (FolksTpZeitgeistController* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	FolksTpZeitgeistControllerPopulateCountersData* _data_;
	FolksTpZeitgeistController* _tmp0_;
	_data_ = g_slice_new0 (FolksTpZeitgeistControllerPopulateCountersData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, folks_tp_zeitgeist_controller_populate_counters);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, folks_tp_zeitgeist_controller_populate_counters_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	folks_tp_zeitgeist_controller_populate_counters_co (_data_);
}


void folks_tp_zeitgeist_controller_populate_counters_finish (FolksTpZeitgeistController* self, GAsyncResult* _res_) {
	FolksTpZeitgeistControllerPopulateCountersData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static gboolean folks_tp_zeitgeist_controller_populate_counters_co (FolksTpZeitgeistControllerPopulateCountersData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void folks_tp_zeitgeist_controller_class_init (FolksTpZeitgeistControllerClass * klass) {
	folks_tp_zeitgeist_controller_parent_class = g_type_class_peek_parent (klass);
}


static void folks_tp_zeitgeist_controller_instance_init (FolksTpZeitgeistController * self) {
}


/**
 * Dummy interface for the Zeitgeist code for libfolks-telepathy.la. This must
 * implement exactly the same interface as tp-zeitgeist.vala, but without
 * linking to Zeitgeist.
 *
 * See the note in Makefile.am, and
 * [[https://bugzilla.gnome.org/show_bug.cgi?id=701099]].
 */
GType folks_tp_zeitgeist_controller_get_type (void) {
	static volatile gsize folks_tp_zeitgeist_controller_type_id__volatile = 0;
	if (g_once_init_enter (&folks_tp_zeitgeist_controller_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FolksTpZeitgeistControllerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) folks_tp_zeitgeist_controller_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FolksTpZeitgeistController), 0, (GInstanceInitFunc) folks_tp_zeitgeist_controller_instance_init, NULL };
		GType folks_tp_zeitgeist_controller_type_id;
		folks_tp_zeitgeist_controller_type_id = g_type_register_static (G_TYPE_OBJECT, "FolksTpZeitgeistController", &g_define_type_info, 0);
		g_once_init_leave (&folks_tp_zeitgeist_controller_type_id__volatile, folks_tp_zeitgeist_controller_type_id);
	}
	return folks_tp_zeitgeist_controller_type_id__volatile;
}



